c   July 29, 2005
c
c   Add two real variables:  
c
c     ecosw is the phase difference between secondary and primary eclipse
c
c     tratio  is the ratio of T_2/T_1
c
c
c   August 10, 2004
c
c   This is version 3.  Some improvements:
c
c   o  There is the option to use a Monte Carlo technique to
c      account for fractional pixels.
c
c   o  The user can input and fit for the primary mass, the K-velocity
c      of the primary, the radaius of the primary, and the ratio
c      of the radii.
c
c
c
c
c   UPDATE JUNE 11, 2003
c
c   This version will have most of the two dimensional
c   arrays replaced with 1D arrays.  For example, the
c   code fragment
c
c          do 10 ialf=1,Nalf
c            do 9 ibet=1,ibetlim(ialf)
c               temp=surf(ialf,ibet)
c
c    becomes
c
c          do 10 ialf=1,Nalf
c            do 9 ibet=1,ibetlim(ialf)
c               index=(ialf-i)*ibetlim(ialf)+ibet
c               temp=surf(index)
c          
c
c
c   May 12, 2000
c
c   This is version 2.  Some improvements:
c
c   o  A polar coordinate system is now used.
c
c   o  The star horizons are now more accurately found.
c
c   o  Fractionaly eclipsed pixels are not accounted for.
c
c   o  A more robust reflection effect routine.
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   UPDATE August 13, 2001
c
c   Replace in the *format* statements, the string isw9 (curren....)
c   with 'ielite'
c
c
c   UPDATE NOVEMBER 27, 2006
c
c   Add NRVphase and xRVmod to the list.  This will allow for the
c   velocity curve to have points every dphase when iecheck=5.
c
          subroutine lightcurve(Nphase,Nmaxphase,xmod,ymodU,ymodB,
     $      ymodV,ymodR,ymodI,ymodJ,ymodH,ymodK,ymods1,ymods2,ymods3,
     &      ymodd,RV1,RV2,drv1,drv2,obsparm,ifastflag,NRVphase,xRVmod,
     &      fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     @      Ncycle,Ttimes,Tseps,RV3,parmstring,planetparm,dynparm,line,
     @    fill1,fill2,omega1,
     @    omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,betarim,
     @    rinner,router,tdisk,xi,alb1,alb2,rLx,Period,fm,separ,
     @    gamma,wave,dbolx,dboly,dwavex,dwavey,t3,g3,SA3,density,
     @    sw1,sw2,sw3,T0,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,
     @    primmass,primK,primrad,ratrad,frac1,frac2,ecosw,temprat,
     @    bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,
     @    sw29,sw30,contam,Tconj,beam1,beam2,ocose,osine,omegadot,
     @    contamS0,contamS1,contamS2,contamS3,sw47,sw48,sw49,gaplow,
     @    gaphigh,P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,
     @    P2Q,P2ratrad,P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,
     @    P3Omega,P3Q,P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,
     @    P4incl,P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,
     @    P5esin,P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,
     @    P6ecos,P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,
     @    P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,P8tconj,
     @    P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,P8ratrad,
     @    xSC,ySC,spot1parm,spot2parm,spotdparm,Nalph1,Nbet1,Nalph2,
     @    Nbet2,Ntheta,Nradius,Nref,idraw,iecheck,iidint,iatm,ism1,
     @    ilaw,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,icnRV1,icnRV2,
     @    iRVfilt,isw1,isw2,isw3,isw4,ikeep,isynch,isw5,isw6,isw7,
     @    isw8,isw9,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,
     @    isw25,isw26,isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,
     @    NSC,compfracs,tertperiod,tertt0,tertecos,tertesin,
     @    tertincl,tertOmega,tertQ,tertconj,tertratrad,hh,sw72,sw73,
     @    Nmaxeclipse,Tdur1,Tdur2)
c
c   October 6, 1999
c
c   This subroutine will call all of the needed subroutines
c   to set up geometry, etc.
c
c   Adjust the maximum limits as needed.
c
c
c   March 13, 2000
c
c   change the integer flag iswe1 to ionephase.  If ionephase=1, then
c   compute only one phase, given by sw1.
c
c
c   March 20, 2000
c
c   I have speeded up the interpolation of the atmosphere intensities
c   from the table by about a factor of 3.
c
c
c   July 24, 2000
c
c   Add the array obsparm to the argument list.  This contains the 
c   computed physical parameters of stars 1 and 2
c
c   UPDATE September 21, 2008
c
c   Add K_1 and K_2 to the list
c
c   UPDATE October 10, 2008
c
c   Add finc, Q, ecc, arg, Teff1, Teff2 to the list 
c
c   UPDATE March 15, 2011
c
c   Add sum of fractional radii (string sum)
c
c   obsparm(1) = mass of star 1      (solar)
c   obsparm(2) = radius of star 1    (solar)
c   obsparm(3) = gravity of star 1   (log cgs)
c   obsparm(4) = V_rot*sin(i) star 1 (km/sec)
c   obsparm(5) = mass of star 2      (solar)
c   obsparm(6) = radius of star 2    (solar)
c   obsparm(7) = gravity of star 2   (log cgs)
c   obsparm(8) = V_rot*sin(i) star 2 (km/sec)
c   obsparm(9) = duration of X-ray eclipse (degrees)
c   obsparm(10) = K_1 (km/sec)
c   obsparm(11) = K_2 (km/sec)
c   obsparm(12) = finc (deg)
c   obsparm(13) = Q
c   obsparm(14) = ecc
c   obsparm(15) = argper (deg)
c   obsparm(16) = Teff1
c   obsparm(17) = Teff2
c   obsparm(18) = (R1+R2)/separ
c   obsparm(19) = Teff3 (t3)

c   UPDATE September 11, 2001
c
c   Add the X-ray eclipse duration in degrees (if any) to obsparm(9).
c
c   **************************************************
c
c   February 5, 2001
c
c   This major revision includes the generalization to eccentric orbits.
c
c
c   NEW BUG August 2, 2001
c
c   Do a global replace and put 'T0' in place of sw4.
c
c   UPDATE June 17, 2002
c
c   Replace all cases of eq.. with eqv..
c   This will make statements with logical orperands like this:
c
c   if(left.eqv..false.)   rather than   if(left.eq..false.)
c
          implicit double precision(a-h,o-z)

c          implicit none
c
          integer iedgehor3
          integer nmaxphase,ncycle,ialphmax1,ibetmax1,ialphmax2
          integer ibetmax2,ialphmax3,ibetmax3,nthetamax,nrmax
          integer maxlines,maxmu,nmu,mmdx1,mmdx2,mmdx3,ibetlim3
          integer ibetlim1,ibetlim2,iedgestar1,iedgestar2,iedgestar3
          integer iedgehor1,iedgehor2,Ndyn,nalph1,nbet1,nalph2,nbet2
          integer ntheta,nradius,nref,idraw,iecheck,iidint,iatm,ism1
          integer ilaw,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,icnRV1
          integer icnRV2,iRVfilt,isw1,isw2,isw3,isw4,ikeep,isynch,isw5
          integer isw6,isw7,isw8,isw9,idark1,idark2,isw12,isw13,isw21
          integer isw22,isw23,isw24,isw25,isw26,isw27,isw28,isw29,isw30
          integer isw31,isw32,isw33,isw34,nSC,itconj,it1,it2,it3,it4
          integer nlines,nalph3,nbet3,Nphase,ifastflag,nRVphase,ijk
          integer ipstep,iVsave,ij,ik,itide,iGR,i3flag,Ngap,iseason
          integer icountx,ididscale3,i,ibody,nbody,nstep,nsec,nprim
          integer icount,ina2save,inb1save,inb2save,iesave,ialign,igrav
          integer ionephase,isquare,iusepot,ina1save,isimp,ispotprof
          integer ispot1,ispot2,ispotd,ii,ivrt,ntime,nnn,iverb,Nloopp
          integer montecarlo,nhoriz1,nhoriz2,neclipse3,nsky3,jj,jjj
          integer ialfmin,ialfmax,idcheck,itoggle,icounttime,iloopp

          real*8 phaseout,em,bigE,rnu,bdist1,emnew,bigEnew,rnunew,phase
          real*8 tertrnu,tertppp,xxoff1,tertxcen,yyoff1,tertycen
          real*8 tideparm

          real*8 gpole1,pots1,size1,fincr,ppp,total_mass,tertmass,gmsun
          real*8 tt1,smet,tertsep,axisscale,psi0,flimbx,flimby,flux3
          real*8 rldint3,fluxlat,gscale3,fluxU3,fluxB3,fluxV3,fluxR3
          real*8 fluxI3,fluxJ3,fluxH3,fluxK3,rl2,tpole2,regg2,SA2,gpole2
          real*8 pots2,darkbol2,rocheradius,overQ,x0,redge,stepr,stepz
          real*8 reper,rsper,pstart,pend,pconj2,pstartout,pstopout,sf2
          real*8 togglephase,argrad,trc,htrc,ecan,xmc,phper,phper2,pup
          real*8 thetatan,pp,phaser,delta,tt2,diff1,diff2,dummyphase
          real*8 xhmin2,xhmax2,yhmin2,yhmax2,tertbdist,tertphase,xhmin
          real*8 xhmax,yhmin,yhmax,flux1,rldint1,flux2,rldint2,fluxU1
          real*8 fluxB1,fluxV1,fluxR1,fluxI1,fluxJ1,fluxH1,fluxK1
          real*8 xmod,ymodU,ymodB,ymodV,ymodR,ymodI,ymodJ,ymodH,ymodK
          real*8 ymods1,ymods2,ymods3,ymodd,rv1,rv2,drv1,drv2,obsparm
          real*8 xrvmod,fracs1,fracs2,fracs3,fracs4,fracs5,fracs6
          real*8 fracs7,fracs8,ttimes,tseps,rv3,atmt,atmg,atmmu
          real*8 atmint1,atmint2,atmint3,atmint4,atmint5,atmint6
          real*8 atmint7,atmint8,corr1,corr2,refflux1,refflux2
          real*8 rlatflux,gimvel,darkint1,darkint2,darkint3,ttiny
          real*8 temp3,rad3,dtemp,dx,dy,dz,dinty,drad,einty,dyhoriz
          real*8 savedinty,saveeinty,tedge,xedge,yedge,zedge,dxhoriz
          real*8 dtopx,dtopy,diskproj,edgeproj,dvisib,evisib,xskydisk
          real*8 yskydisk,zskydisk,xskyedge,yskyedge,x1,y1,z1,x2,y2,z2
          real*8 visib1,visib2,visib3,rinty1,rinty2,flum1,flum2,flum3
          real*8 saveinty1,saveinty2,phiar1,phiar2,delphi1,delphi2
          real*8 delphie1,delphie2,phiar3,rinty3,saveinty3
          real*8 delphie3,delphi3,phihor1,phihor2,phihor3,surf1,surf2
          real*8 gradx1,gradx2,gradx3,grady1,grady2,grady3,gradz1
          real*8 gradz2,gradz3,surf3,gthird,x3,y3,z3,grav3,rad1,rad2
          real*8 temp1,temp2,g1,g2,rpol1,rpol2,xhoriz3,yhoriz3,xhoriz1
          real*8 yhoriz1,xhoriz2,yhoriz2,xsky1,xsky2,xsky3,ysky1,ysky2
          real*8 ysky3,xend1,xend2,ratio1,ratio2,tempold1,tempold2
          real*8 projarray1,projarray2,projarray3,dumxsky1,dumysky1
          real*8 dumxsky2,dumysky2,coprat1,coprat2,toldspot1,toldspot2
          real*8 xtop2horiz,ytop2horiz,wave,dbolx,dboly,dwavex,dwavey
          real*8 zdcorr,third,yeclipse,phistart1,phistart2,phistart3
          real*8 powercoeff,xecx,xecy,spotdparm,spot1parm,spot2parm
          real*8 xsob,timearray,compfracs,gaplow,gaphigh,flux3keep
          real*8 thirdkeep,dynpp,dynqq,rmass,posarray,velarray,zzq
          real*8 qqm2,ppm2,esec,odetime,timeinterp,eprim,distprim
          real*8 distsec,ribcinp,xsc,ysc,fill1,fill2,omega1,omega2
          real*8 dphase,Q,finc,teff1,teff2,teff3,tgrav1,tgrav2,betarim
          real*8 rinner,router,tdisk,xi,alb1,alb2,rlx,period,fm,separ
          real*8 gamma,t3,g3,sa3,density,sw1,sw2,sw3,T0,ecc,argper,pshift
          real*8 sw5,sw6,sw7,sw8,sw9,primmass,primK,primrad,ratrad,frac1
          real*8 frac2,ecosw,temprat,bigI,bigbeta,sw23,sw24,sw25,sw26
          real*8 sw27,sw28,sw29,sw30,contam,tconj,beam1,beam2,ocose,osine
          real*8 omegadot,contams0,contams1,contams2,contams3,sw47,sw48
          real*8 sw49,p2ratrad,p3ratrad,p4ratrad,p5ratrad,p6ratrad
          real*8 p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q
          real*8 p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,p3q
          real*8 p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,p4omega,p4q
          real*8 p5tconj,p5period,p5t0,p5ecos,p5esin,p5incl,p5omega,p5q
          real*8 p6tconj,p6period,p6t0,p6ecos,p6esin,p6incl,p6omega,p6q
          real*8 p7tconj,p7period,p7t0,p7ecos,p7esin,p7incl,p7omega,p7q
          real*8 p8tconj,p8period,p8t0,p8ecos,p8esin,p8incl,p8omega,p8q
          real*8 p7ratrad,p8ratrad,tmin,tmax,gmin,gmax,tertperiod,tertesin
          real*8 tertecos,tertincl,tertOmega,tertQ,tertconj,tertT0
          real*8 tertratrad,hh,sw72,sw73,pie,www,emphase,savethetamis
          real*8 savephimis,pstep,pstop,tertecc,tertargrad,tertarg,sneed
          real*8 reff1,reff2,reff3,reff4,reff5,reff6,reff7,reff8,SA1,ssref
          real*8 thetamis,phimis,vrot1,vrot2,gp1,gp2,rm1,rm2,gscale1,gscale2
          real*8 tidephi,reff9,reff10,tstart,tend,tref,tdiff,temphh
          real*8 timein,eccout,argout,rinclout,omegaout,astarout,rmeanout
          real*8 trueanomout,periodout,arg1,ecc1,period1,tstart1,ecc2,arg2
          real*8 period2,tstart2,omegadotgr,cyclenum,deltaomega,pconj,rpole1
          real*8 rpole2,bdist,pot1,pot2,ave11,ave12,ave21,ave22,ave1,ave2
          real*8 rdepth,eshift,savedphase,onephase,usepot1,usepot2,fluxu2
          real*8 fluxb2,fluxv2,fluxr2,fluxi2,fluxj2,fluxh2,fluxk2,tteff2
          real*8 fillper1,fillper2,pervol1,pervol2,sss,tstep,tstop
          real*8 radfill1,radfill2,rl1,tpole1,regg1,durprim1,dursec1
          real*8 Tdur1,Tdur2,durprim2,dursec2

c
c   UPDATE MAY 21, 2004
C
C   Add separate ialphmax and ibetmax parameters for star 1 and star 2.
c   The argument lists for copyinty, writepoints, detailref, simpleref
c   initratio, and checkinput need to be modified:  add ialphmax2 and
c   ibetmax2 to the end.
c 
c
          parameter(ialphmax1=120,ibetmax1=230)
          parameter(ialphmax2=120,ibetmax2=230)
          parameter(ialphmax3=120,ibetmax3=230)
          parameter(Nthetamax=120,Nrmax=160)
c
c          parameter(ialphmax1=200,ibetmax1=200)
c          parameter(ialphmax2=200,ibetmax2=200)
c          parameter(ialphmax3=100,ibetmax3=100)

c
c   Caution:  adjust also the values of tempalf,tempbet in the 
c   subroutine getATMflux!
c
c
          parameter (maxlines=1300,maxmu=115)   ! was 1100
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
c
c   UPDATE September 11, 2001
c
c   Change the dimension of obsparm to 9
c
c   UPDATE September 20, 2008
c
c   Make the dimension of obsparm 11
c
c   UPDATE October 10, 2008
c
c   Make the dimension of obsparm 17
c
          dimension corr1(8),corr2(8),tideparm(10)
          dimension refflux1(8),refflux2(8),rlatflux(8),gimvel(8)
          dimension obsparm(19)
          dimension darkint1(8),darkint2(8),darkint3(8)
          dimension mmdx1(ialphmax1,ibetmax1),mmdx2(ialphmax2,ibetmax2)
          dimension mmdx3(ialphmax3,ibetmax3),temp3(ialphmax3*ibetmax3)
          dimension ibetlim3(ialphmax3),rad3(ialphmax3*ibetmax3)
          dimension dtemp(Nrmax*Nthetamax),dx(Nrmax*Nthetamax),
     &      dy(Nrmax*Nthetamax),dz(Nrmax*Nthetamax),dinty(Nrmax*Nthetamax),
     $      drad(Nrmax),einty(Nthetamax*11),savedinty(Nrmax*Nthetamax),
     &      saveeinty(Nthetamax*11),ibetlim1(ialphmax1),ibetlim2(ialphmax2),
     %      tedge(Nthetamax*11),xedge(Nthetamax*11),yedge(Nthetamax*11),
     &      zedge(Nthetamax*11),dxhoriz(2*Nthetamax),dyhoriz(2*Nthetamax),
     $      dtopx(2*Nthetamax),dtopy(2*Nthetamax)
          dimension diskproj(Nrmax*Nthetamax),edgeproj(Nthetamax*11),
     &      dvisib(Nrmax*Nthetamax),evisib(Nthetamax*11),
     &      xskydisk(Nthetamax*Nrmax),yskydisk(Nthetamax*Nrmax),
     &      zskydisk(Nthetamax*Nrmax),
     &      xskyedge(Nthetamax*11),yskyedge(Nthetamax*11)
          dimension x1(ialphmax1*ibetmax1),y1(ialphmax1*ibetmax1),
     $      z1(ialphmax1*ibetmax1),x2(ialphmax2*ibetmax2),
     &      y2(ialphmax2*ibetmax2),visib3(ialphmax3*ibetmax3),
     $      z2(ialphmax2*ibetmax2),visib1(ialphmax1*ibetmax1),
     %      visib2(ialphmax2*ibetmax2),rinty1(ialphmax1*ibetmax1),
     @      rinty2(ialphmax2*ibetmax2),flum1(ialphmax1*ibetmax1),
     @      flum3(ialphmax3*ibetmax3),
     %      flum2(ialphmax2*ibetmax2),saveinty1(ialphmax1*ibetmax1),
     $      saveinty2(ialphmax2*ibetmax2),phiar1(ialphmax1*ibetmax1),
     &      phiar2(ialphmax2*ibetmax2),delphi1(ialphmax1*ibetmax1),
     %      delphi2(ialphmax2*ibetmax2),iedgestar1(ialphmax1*ibetmax1),
     @      iedgestar3(ialphmax3*ibetmax3),
     @      iedgestar2(ialphmax2*ibetmax2),iedgehor2(ialphmax2*ibetmax2),
     %      iedgehor1(ialphmax1*ibetmax1),delphie1(ialphmax1*ibetmax1),  
     $      delphie2(ialphmax2*ibetmax2),phiar3(ialphmax3*ibetmax3),
     @      iedgehor3(ialphmax3*ibetmax3),rinty3(ialphmax3*ibetmax3),
     @      saveinty3(ialphmax3*ibetmax3),delphie3(ialphmax3*ibetmax3)
          dimension delphi3(ialphmax3*ibetmax3)
          dimension phihor1(ialphmax1,4),phihor2(ialphmax2,4),
     @         phihor3(ialphmax1,4)
          dimension surf1(ialphmax1*ibetmax1),surf2(ialphmax2*ibetmax2),
     $      gradx1(ialphmax1*ibetmax1),gradx2(ialphmax2*ibetmax2),
     $      grady1(ialphmax1*ibetmax1),grady2(ialphmax2*ibetmax2),
     $      gradz1(ialphmax1*ibetmax1),gradz2(ialphmax2*ibetmax2)
          dimension surf3(ialphmax3*ibetmax3),gthird(ialphmax3*ibetmax3),
     @      gradx3(ialphmax3*ibetmax3),
     @      grady3(ialphmax3*ibetmax3),gradz3(ialphmax3*ibetmax3),
     @      x3(ialphmax3*ibetmax3),y3(ialphmax3*ibetmax3),
     @      z3(ialphmax3*ibetmax3),grav3(ialphmax3*ibetmax3)
          dimension rad1(ialphmax1*ibetmax1),rad2(ialphmax2*ibetmax2),
     $      temp1(ialphmax1*ibetmax1),temp2(ialphmax2*ibetmax2),
     $      g1(ialphmax1*ibetmax1),g2(ialphmax2*ibetmax2),
     @      Rpol1(ialphmax1),Rpol2(ialphmax2)
          dimension xhoriz3(4*ibetmax3),yhoriz3(4*ibetmax1)
          dimension xhoriz1(4*ibetmax1),yhoriz1(4*ibetmax1),
     $       xhoriz2(4*ibetmax2),yhoriz2(4*ibetmax2),
     %       xsky1(ialphmax1*ibetmax1*4),xsky3(ialphmax1*ibetmax1*4),
     $       ysky1(ialphmax1*ibetmax1*4),xsky2(ialphmax2*ibetmax2*4),
     %       ysky2(ialphmax2*ibetmax2*4),xend1(4),xend2(4),
     $       ratio1(ialphmax1*ibetmax1),ratio2(ialphmax2*ibetmax2),
     $       tempold1(ialphmax1*ibetmax1),tempold2(ialphmax2*ibetmax2),
     $       projarray1(ialphmax1*ibetmax1),ysky3(ialphmax3*ibetmax3*4),
     @       projarray2(ialphmax2*ibetmax2),projarray3(ialphmax3*ibetmax3*4),
     %       dumxsky1(ialphmax1*ibetmax1*4),
     $       dumysky1(ialphmax1*ibetmax1*4),
     @       dumxsky2(ialphmax2*ibetmax2*4),
     %       dumysky2(ialphmax2*ibetmax2*4),coprat1(ialphmax1*ibetmax1),
     @       coprat2(ialphmax2*ibetmax2),toldspot1(ialphmax1*ibetmax1),
     @       toldspot2(ialphmax2*ibetmax2)
          dimension xtop2horiz(4*ibetmax2),ytop2horiz(4*ibetmax2)
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @      dwavey(8,3)
          dimension xmod(Nmaxphase),ymodU(Nmaxphase),ymodB(Nmaxphase),
     $      ymodV(Nmaxphase),ymodR(Nmaxphase),ymodI(Nmaxphase),
     $      ymodJ(Nmaxphase),ymodH(Nmaxphase),ymodK(Nmaxphase),
     &      ymods1(Nmaxphase),ymods2(Nmaxphase),ymodd(Nmaxphase),
     &      RV1(Nmaxphase),RV2(Nmaxphase),zdcorr(8),dRV1(Nmaxphase),
     %      dRV2(Nmaxphase),third(8),ymods3(Nmaxphase)
          dimension xRVmod(Nmaxphase),yeclipse(1500001)  !Nmaxphase
          dimension RV3(Nmaxphase)
          dimension phistart1(ialphmax1),phistart2(ialphmax2),
     @      phistart3(ialphmax3)
c
c
          dimension powercoeff(8,9)
c
c   UPDATE September 10, 2001
c
c   Add these arrays for X-ray eclipse duration computations
c
          dimension xecx(5000),xecy(5000)
c
c   RVG BUG ALERT   May 8, 2001
c
c   Define the variables needed for spots
c
          dimension spotdparm(2,4),spot1parm(2,4),spot2parm(2,4)
c
c   UPDATE JULY 7, 2004
c
c   Use the sub-random Sobel sequence instead of ran9.  xsob is needed
c   for this.
c
          dimension xsob(2)
c
c   UPDATE DECEMBER 10, 2004
c
c   Add these arrays to compute light curves in time units rather
c   than phase
c 
          dimension timearray(9000000)
c
c   UPDATE OCTOBER 10, 2007
c
c   Add this array to keep track of the light curves of the individual
c   components in all band passes.
c
c   UPDATE January 12, 2009
c
c   make fracs fracs1, fracs2, .... fracs8 and put them in the
c   argument of subroutine lightcurve.  In this was one can use
c   Nmaxphase in the dimension statement
c
          dimension compfracs(8,3),fracs1(Nmaxphase,4)
          dimension fracs2(Nmaxphase,4)
          dimension fracs3(Nmaxphase,4),fracs4(Nmaxphase,4)
          dimension fracs5(Nmaxphase,4),fracs6(Nmaxphase,4)
          dimension fracs7(Nmaxphase,4),fracs8(Nmaxphase,4)
c
c   UPDATE December 15, 2012
c
c   When itime=2, have the ability to exclude gaps in the model.  The
c   file ELCgap.inp will have Ngap pairs of numbers, and times between
c   these two numbers will be excluded
c
          dimension gaplow(9999),gaphigh(9999),flux3keep(8)
          dimension thirdkeep(8)
c
c   Add variables for dynamics
c
          parameter (Ndyn=400000)    !(Ndyn=1000000)
          DIMENSION dynPP(30),dynQQ(30)
          dimension rmass(10),posarray(Ndyn,30),velarray(Ndyn,30)
          dimension zzq(6,60,Ndyn),QQm2(3),PPm2(3),Esec(Nmaxeclipse)
          dimension odetime(Ndyn),timeinterp(6),Eprim(Nmaxeclipse)
          dimension durprim1(Nmaxeclipse),dursec1(Nmaxeclipse)
          dimension durprim2(Nmaxeclipse),dursec2(Nmaxeclipse)
          dimension Distprim(Nmaxeclipse),Distsec(Nmaxeclipse)
          dimension rIBCinp(10,6)
          dimension Ncycle(34),Ttimes(34,Nmaxeclipse)
          dimension Tseps(34,Nmaxeclipse),Tdur1(34,Nmaxeclipse)
          character*9 extension
          dimension xSC(9999),ySC(9999),Tdur2(34,Nmaxeclipse)
c
c   NEW BUG ALERT  July 13, 2001
c
c   Add a new character string and common block for a 'parameter string'
c   This string of parameters will be fed to the genetic code to make it
c   easier to compute uncertainties on the physical quantities like mass
c   and radius.
c
c   UPDATE November 28, 2001
c
c   parmstring was character*199, now should be character*201
c
c   UPDATE January 16, 2002
c
c   parmstring was character*201, now should be character*227
c
c   UPDATE June 7, 2002
c
c   Make the length of parmstring character*237.
c   Also, make a two scratch strings, one of length character*227
c   and one of length 10
c
c   UPDATE October 28, 2002
c
c   Make the length of parmstring character*249, and add 12 to the
c   length of scr1string
c
c   UPDATE October 22, 2008
c
c   Make the length of parmstring character*259, and add 12 to the
c   length of scr1string
c
          character*1000 parmstring
          character*2000 planetparm
          character*1700 dynparm,line
c          character*227 scr1string
          character*1000 scr1string
          character*12  scr2string
c
c          common /stringblock/ parmstring,planetparm,dynparm,line
cc
c          common /realblock/ fill1,fill2,omega1,omega2,dphase,Q,finc,
c     @      Teff1,Teff2,Tgrav1,Tgrav2,betarim,rinner,router,tdisk,xi,
c     @      alb1,alb2,rLx,Period,fm,separ,gamma,wave,dbolx,dboly,dwavex,
c     @      dwavey,t3,g3,SA3,density,sw1,sw2,sw3,T0,ecc,argper,pshift,
c     @      sw5,sw6,sw7,sw8,sw9,primmass,primK,primrad,ratrad,frac1,
c     @      frac2,ecosw,temprat,bigI,bigbeta,sw23,sw24,powercoeff,sw25,
c     @      sw26,sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,ocose,
c     @      osine,omegadot,contamS0,contamS1,contamS2,contamS3,
c     @      sw47,sw48,sw49,gaplow,gaphigh,
c     @      P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
c     @         P2ratrad,
c     @         P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
c     @         P3ratrad,
c     @         P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,P4Omega,P4Q,
c     @         P4ratrad,
c     @         P5tconj,P5period,P5T0,P5ecos,P5esin,P5incl,P5Omega,P5Q,
c     @         P5ratrad,   
c     @         P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
c     @         P6ratrad,
c     @         P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
c     @         P7ratrad,
c     @         P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
c     @         P8ratrad,xSC,ySC
cc
c          common /spotblock/ spot1parm,spot2parm,spotdparm
cc
c          common /intblock/ Nalph1,Nbet1,Nalph2,Nbet2,Ntheta,Nradius,
c     @      Nref,idraw,iecheck,iidint,iatm,ism1,ilaw,icnU,icnB,icnV,icnR,
c     @      icnI,icnJ,icnH,icnK,icnRV1,icnRV2,iRVfilt,isw1,isw2,isw3,
c     @      isw4,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,idark1,idark2,
c     @      isw12,isw13,isw21,isw22,isw23,isw24,isw25,isw26,isw27,isw28,
c     @      isw29,isw30,isw31,isw32,isw33,isw34,NSC
cc
c          common /fracblock/ compfracs
cc
c          common /thirdblock/ tertperiod,tertt0,tertecos,tertesin,
c     @        tertincl,tertOmega,tertQ,tertconj,tertratrad,hh,sw72,sw73
cc
          common /realatm/ atmT,atmg,atmmu,atmint1,atmint2,atmint3,
     @       atmint4,atmint5,atmint6,atmint7,atmint8,Tmax,Tmin,gmax,gmin
c
          common /intatm/  Nlines,Nmu,Nalph3,Nbet3,itconj,it1,it2,it3,
     @      it4
c
c
c   Initialize variables that may be uninitialized   
c
          pie=4.0d0*datan(1.0d0)
          if(isw30.eq.0)then
            do ijk=1,8
              dwavex(ijk,3)=dwavex(ijk,1)
              dwavey(ijk,3)=dwavey(ijk,1)
            enddo
          endif
          www=0.0d0
          emphase=0.0d0
          ipstep=0
          iVsave=0 
          savethetamis=0.0d0
          savephimis=0.0d0
          pstep=0.0d0
          pstop=0.0d0
          icountx=0
c
          do ij=1,34
            Ncycle(ij)=0
            do ik=1,Nmaxeclipse
              Ttimes(ij,ik)=0.0d0
              Tseps(ij,ik)=0.0d0
              Tdur1(ij,ik)=0.0d0
              Tdur2(ij,ik)=0.0d0
            enddo
          enddo
c
c   Start here.  First check the input for goofs.
c
          itide=0
          iGR=isw26
          tidephi=0.0d0
          i3flag=0
c
c   UPDATE December 15, 2012
c
c   Set Ngap=isw31
c
          Ngap=isw31
c
c   UPDATE JULY 5, 2011
c
c   Add a variable called contam, which will be sw31.
c   This will be the Kepler contamination value, between
c   0.0 and 1.0.  It will be assumed the Kepler position is
c   in in the U position, so modelU is altered.
c
c          contam=sw31
c
          if(contam.lt.0.0d0)contam=0.0d0
          if(contam.ge.1.0d0)contam=0.999999d0
c
c   UPDATE MAY 5, 2013
c
c   Add contamination by seasons
c
           Iseason=isw34
c           contamS0=contamS0
c           contamS1=contamS1
c           contamS2=contamS2
c           contamS3=contamS3
c
c   If itime is less than 2, disable the Ngap
c
          if(isw7.le.1)Ngap=0
c

c  UPDATE September 5, 2012
c 
c  The flag isw29 will let the user specify e*cos(omega),esin(omega)
c
          if(isw29.gt.0)then
            ecc=dsqrt(ocose*ocose+osine*osine)
            argper=datan2(osine,ocose)*180.0d0/pie
            if(argper.lt.0.0d0)argper=argper+360.0d0
            if(argper.gt.360.0d0)argper=argper-360.0d0
          endif
c
          if(isw30.gt.0)then
            tertecc=dsqrt(tertecos**2+tertesin**2)
            tertargrad=datan2(tertesin,tertecos) !-0.5d0*pie
            if(tertargrad.lt.0.0d0)tertargrad=tertargrad+2.0d0*pie
            if(tertargrad.gt.pie+pie)tertargrad=tertargrad-2.0d0*pie
c            tertarg=(datan2(tertesin,tertecos)-0.5d0*pie)*180.0d0/pie
            tertarg=(datan2(tertesin,tertecos))*180.0d0/pie
            if(tertarg.lt.0.0d0)tertarg=tertarg+360.0d0
            if(tertarg.gt.360.0d0)tertarg=tertarg-360.0d0
c            write(*,*)tertecc,tertarg
          endif
c
c   UPDATE JULY 15, 2011
c
c   Here is a flag for third light scaling
c
          ididscale3=0
c
c    Update October 15, 2010
c
c    Add Doppler boosting.  beam1=sw33 and beam2=sw34
c
          if(ilaw.gt.10)then
            do i=1,8
              dwavex(i,2)=dwavex(i,1)
              dwavey(i,2)=dwavey(i,1)
            enddo
          endif
c         
          call recordparm(Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,omega1,
     $       omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,betarim,
     $       rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,Nref,rLx,
     &       Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,sw3,T0,
     $       idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,icnI,
     @       icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,
     %       dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,
     $       ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,
     %       spotdparm,primmass,primK,primrad,ratrad,frac1,frac2,ecosw,
     @       temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,
     @       bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,
     @       sw30,contam,Tconj,beam1,beam2,isw25,isw26,isw27,isw28,
     @       isw29,isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,
     @       contamS0,contamS1,contamS2,contamS3,sw47,sw48,sw49)
c
c    July 29, 2005
c
c    If ecosw > 0 and ecc > 0 then set the value of argper
c
          call checkinput(ialphmax1,ibetmax1,Nthetamax,Nrmax,
     &       Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,omega1,
     $       omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,betarim,
     $       rinner,router,Ntheta,Nradius,alb1,
     @       alb2,Nref,Period,fm,separ,
     $       idraw,iecheck,iidint,ism1,
     %       icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     &       ecc,pshift,ialphmax2,ibetmax2,ecosw,
     @       argper,temprat,ilaw,dwavex,dwavey,tertQ,P2Q,P3Q,P4Q,
     @       P5Q,P6Q,P7Q,P8Q)
c
c  UPDATE October 10, 2008
c 
c  Add the routine setdensity which sets the mass ratio given the density
c  and the fill factor of star 1
c
c
c   Record parameters that could be optimized into the ELC.parm file
c
          call recordparm1(fill1,fill2,omega1,
     $       omega2,Q,finc,Teff1,Teff2,betarim,
     $       rinner,router,tdisk,xi,
     %       rLx,separ,gamma,t3,g3,SA3,density)
c
c  UPDATE DECEMBER 7, 2009
c
c  Add a very fast analytic mode for transiting planets.  set isw27=1.
c  also needed are frac1,frac2,period,T0,primmass,primK,ecc,argper,
c  omega1,finc,ilaw,dwavex,dwavey,axis_I,axis_beta,bin size
c  for light curves, bin size for velocity curve,ialign,ikeep
c
          thetamis=0.0d0
          phimis=0.0d0
          obsparm(19)=t3

          if(isw27.ge.1)then
c
c   Determine the masses, radii, and rotational velocities
c
            call analyticscale(Q,finc,period,primmass,primK,ecc,frac1,
     @        frac2,primrad,ratrad,reff1,reff2,separ,vrot1,vrot2,gp1,
     @        gp2,rM1,rM2)
c
c   Determine the reference fluxes.  These will be stored in darkint(k)
c
            gscale1=1.0d0
            gscale2=1.0d0

            call getATMint(maxlines,maxmu,Nlines,
     &            atmT,atmg,atmmu,Nmu,
     &            atmint1,atmint2,atmint3,atmint4,atmint5,
     &            atmint6,atmint7,atmint8,
     &            gscale1,darkint1,teff1,gp1,
     %            dwavex,dwavey,ilaw,iatm,1)
c
            call getATMint(maxlines,maxmu,Nlines,
     &            atmT,atmg,atmmu,Nmu,
     &            atmint1,atmint2,atmint3,atmint4,atmint5,
     &            atmint6,atmint7,atmint8,
     &            gscale2,darkint2,teff2,gp2,
     %            dwavex,dwavey,ilaw,iatm,2)
c
           if(isw30.eq.0)then
             SSref=reff1/dsqrt(pie)
             call thirdlight(iatm,t3,g3,SA3,third,
     &          maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &          atmint1,atmint2,atmint3,atmint4,atmint5,
     &          atmint6,atmint7,atmint8,
     %          icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,separ,
     &          dwavex,dwavey,ilaw,3,SSref)
            else
              SSref=reff1/(pie)
              call thirdlight(iatm,t3,g3,SA3,third,
     &          maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &          atmint1,atmint2,atmint3,atmint4,atmint5,
     &          atmint6,atmint7,atmint8,
     %          icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,separ,
     &          dwavex,dwavey,ilaw,3,SSref)
            endif
c
            call getanalyticint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @        Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @        atmint7,atmint8,gp1,darkint1,teff1,dwavex,dwavey,ilaw,
     @        iatm,1,wave,reff1,separ)
c
            call getanalyticint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @        Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @        atmint7,atmint8,gp2,darkint2,teff2,dwavex,dwavey,ilaw,
     @        iatm,2,wave,reff2,separ)
c
c            write(*,*)darkint1(1),darkint2(1),dwavex(1,3)
            SA1=reff1*reff1*4.0d0*pie
            Sneed=abs(SA1*SA3)
            reff3=dsqrt(Sneed/4.0d0/pie)
            call getanalyticint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @        Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @        atmint7,atmint8,10.0d0**(abs(g3)),darkint3,abs(t3),
     @        dwavex,dwavey,ilaw,iatm,3,wave,reff3,separ)
c
            if(ilaw.gt.10)then
              do i=1,8
                dwavex(i,2)=dwavex(i,1)
                dwavey(i,2)=dwavey(i,1)
              enddo
            endif
c
c   dynamics
c
            if(isw30.gt.2)then
c
              if(isw30.eq.3)then
                P4period=0.0d0
                P5period=0.0d0
                P6period=0.0d0
                P7period=0.0d0
                P8period=0.0d0
              endif
c
              if(isw30.eq.4)then
                P5period=0.0d0
                P6period=0.0d0
                P7period=0.0d0
                P8period=0.0d0
              endif
c
              if(isw30.eq.5)then
                P6period=0.0d0
                P7period=0.0d0
                P8period=0.0d0
              endif
c
              if(isw30.eq.6)then
                P7period=0.0d0
                P8period=0.0d0
              endif
c
              if(isw30.eq.7)then
                P8period=0.0d0
              endif
c
              if(P2ratrad.eq.0.0d0)then
                reff4=0.0d0
              else
                reff4=reff1/P2ratrad
              endif
c
              if(P3ratrad.eq.0.0d0)then
                reff5=0.0d0
              else
                reff5=reff1/P3ratrad
              endif
c
              if(P4ratrad.eq.0.0d0)then
                reff6=0.0d0
              else
                reff6=reff1/P4ratrad
              endif
c
              if(P5ratrad.eq.0.0d0)then
                reff7=0.0d0
              else
                reff7=reff1/P5ratrad
              endif
c
              if(P6ratrad.eq.0.0d0)then
                reff8=0.0d0
              else
                reff8=reff1/P6ratrad
              endif
c
              if(P7ratrad.eq.0.0d0)then
                reff9=0.0d0
              else
                reff9=reff1/P7ratrad
              endif
c
              if(P8ratrad.eq.0.0d0)then
                reff10=0.0d0
              else
                reff10=reff1/P8ratrad
              endif
c
              rmass(1)=0.0d0
              rmass(2)=0.0d0
              rmass(3)=0.0d0
              rmass(4)=0.0d0
              rmass(5)=0.0d0
              rmass(6)=0.0d0
              rmass(7)=0.0d0
              rmass(8)=0.0d0
              rmass(9)=0.0d0
              rmass(10)=0.0d0
              tstart=sw23
              tend=sw24
              tstep=sw9

              call counttime(Ngap,gaplow,gaphigh,
     @           ntime,timearray,tstart,tend,tstep,Nmaxphase)

              Nbody=isw30
              rmass(1)=rM1
              rmass(2)=rM2
              rmass(3)=(rM1+rM2)/tertQ
              if(Nbody.ge.4)then
                if(P2Q.eq.0.0d0)then
                  rmass(4)=0.0d0
                else
                  rmass(4)=(rM1+rM2)/P2Q
                endif
              endif
              if(Nbody.ge.5)then
                if(P3Q.eq.0.0d0)then
                  rmass(5)=0.0d0
                else
                  rmass(5)=(rM1+rM2)/P3Q
                endif
              endif
              if(Nbody.ge.6)then
                if(P4Q.eq.0.0d0)then
                  rmass(6)=0.0d0
                else
                  rmass(6)=(rM1+rM2)/P4Q
                endif
              endif
              if(Nbody.ge.7)then
                if(P5Q.eq.0.0d0)then
                  rmass(7)=0.0d0
                else
                  rmass(7)=(rM1+rM2)/P5Q
                endif
              endif
              if(Nbody.ge.8)then
                if(P6Q.eq.0.0d0)then
                  rmass(8)=0.0d0
                else
                  rmass(8)=(rM1+rM2)/P6Q
                endif
              endif
              if(Nbody.ge.9)then
                if(P7Q.eq.0.0d0)then
                  rmass(9)=0.0d0
                else
                  rmass(9)=(rM1+rM2)/P7Q
                endif
              endif
              if(Nbody.ge.10)then
                if(P8Q.eq.0.0d0)then
                  rmass(10)=0.0d0
                else
                  rmass(10)=(rM1+rM2)/P8Q
                endif
              endif
              rIBCinp(1,1)=period
              rIBCinp(2,1)=tertperiod
              rIBCinp(3,1)=P2period
              rIBCinp(4,1)=P3period
              rIBCinp(5,1)=P4period
              rIBCinp(6,1)=P5period
              rIBCinp(7,1)=P6period
              rIBCinp(8,1)=P7period
              rIBCinp(9,1)=P8period
         
              rIBCinp(1,2)=ecc*dcos(argper*pie/180.0d0)
              rIBCinp(2,2)=tertecos
              rIBCinp(3,2)=P2ecos
              rIBCinp(4,2)=P3ecos
              rIBCinp(5,2)=P4ecos
              rIBCinp(6,2)=P5ecos
              rIBCinp(7,2)=P6ecos
              rIBCinp(8,2)=P7ecos
              rIBCinp(9,2)=P8ecos

              rIBCinp(1,3)=ecc*dsin(argper*pie/180.0d0)
              rIBCinp(2,3)=tertesin
              rIBCinp(3,3)=P2esin
              rIBCinp(4,3)=P3esin
              rIBCinp(5,3)=P4esin
              rIBCinp(6,3)=P5esin
              rIBCinp(7,3)=P6esin
              rIBCinp(8,3)=P7esin
              rIBCinp(9,3)=P8esin

              rIBCinp(1,4)=finc*pie/180.0d0
              rIBCinp(2,4)=tertincl*pie/180.0d0  
              rIBCinp(3,4)=P2incl*pie/180.0d0  
              rIBCinp(4,4)=P3incl*pie/180.0d0  
              rIBCinp(5,4)=P4incl*pie/180.0d0  
              rIBCinp(6,4)=P5incl*pie/180.0d0  
              rIBCinp(7,4)=P6incl*pie/180.0d0  
              rIBCinp(8,4)=P7incl*pie/180.0d0  
              rIBCinp(9,4)=P8incl*pie/180.0d0  

              rIBCinp(1,5)=0.0d0
              rIBCinp(2,5)=tertOmega*pie/180.0d0
              rIBCinp(3,5)=P2Omega*pie/180.0d0
              rIBCinp(4,5)=P3Omega*pie/180.0d0
              rIBCinp(5,5)=P4Omega*pie/180.0d0
              rIBCinp(6,5)=P5Omega*pie/180.0d0
              rIBCinp(7,5)=P6Omega*pie/180.0d0
              rIBCinp(8,5)=P7Omega*pie/180.0d0
              rIBCinp(9,5)=P8Omega*pie/180.0d0

              rIBCinp(1,6)=Tconj 
              rIBCinp(2,6)=tertconj
              rIBCinp(3,6)=P2tconj
              rIBCinp(4,6)=P3tconj
              rIBCinp(5,6)=P4tconj
              rIBCinp(6,6)=P5tconj
              rIBCinp(7,6)=P6tconj
              rIBCinp(8,6)=P7tconj
              rIBCinp(9,6)=P8tconj

              tref=sw47
              call getIBC(Nbody,rmass,rIBCinp,dynQQ,dynPP,tref,itconj,
     @             isw28)
c
              call writedynparm(dynparm,rmass,dynQQ,dynPP,Tref)
c
              finccos=cos(pie*finc/180.0d0)
              fincsin=sin(pie*finc/180.0d0)
c
              hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
c
              otemp1=omega1*hutfac*(2.0d0*pie/period)
              otemp2=omega2*hutfac*(2.0d0*pie/period)
              tideparm(1)=sw72
              tideparm(2)=sw73
              tideparm(3)=reff1*separ*0.0046491d0
              tideparm(4)=reff2*separ*0.0046491d0
              tideparm(5)=0.0d0
              tideparm(6)=otemp1*fincsin
              tideparm(7)=-otemp1*finccos
              tideparm(8)=0.0d0
              tideparm(9)=otemp2*fincsin
              tideparm(10)=-otemp2*finccos
c
 1122         format(1pe24.17,10x,a)
 1123         format('#  Second-order system, integration step = ',
     @           f10.7,' days')
 1124         format('#  First-order system, GR included,', 
     @           ' integration step = ',f10.7,' days')
 1125         format('#  First-order system, tidal apsidal included,', 
     @           ' integration step = ',f10.7,' days')
 1126         format('#  First-order system, GR and tidal apsidal',/
     @               '#  included, integration step = ',f10.7,' days')
 1127         format('#  First-order system,',
     @           ' integration step = ',f10.7,' days')
 1128         format('#')
 1129         format('#  Cartesian coordinates at day ',f15.5)
 1130         format('#  Number of bodies = ',i1)
 1131         format('#  Keplerian elements at day ',f15.9)
              if(it2.gt.0)then
                open(unit=91,file='ELCdynamics.out',status='unknown')
                if(iGR.eq.0) write(91,1123)hh
                if(iGR.eq.1) write(91,1124)hh
                if(iGR.eq.2) write(91,1125)hh
                if(iGR.eq.3) write(91,1126)hh
                if(iGR.eq.4) write(91,1127)hh

                write(91,1130)Nbody
                write(91,1128)
                write(91,1122)rmass(1),'mass #1 (solar)'
                write(91,1122)rmass(2),'mass #2 (solar)'
                write(91,1122)rmass(3),'mass #3 (solar)'
                if(Nbody.ge.4)then
                  write(91,1122)rmass(4),'mass #4 (solar)'
                endif
                if(Nbody.ge.5)then
                  write(91,1122)rmass(5),'mass #5 (solar)'
                endif
                if(Nbody.ge.6)then
                  write(91,1122)rmass(6),'mass #6 (solar)'
                endif
                if(Nbody.ge.7)then
                  write(91,1122)rmass(7),'mass #7 (solar)'
                endif
                if(Nbody.ge.8)then
                  write(91,1122)rmass(8),'mass #8 (solar)'
                endif
                if(Nbody.ge.9)then
                  write(91,1122)rmass(9),'mass #9 (solar)'
                endif
                if(Nbody.ge.10)then
                  write(91,1122)rmass(10),'mass #10 (solar)'
                endif
c
                write(91,1122)reff1*separ*0.0046491d0,
     @                  'radius #1 (AU)'
                write(91,1122)reff2*separ*0.0046491d0,
     @                  'radius #2 (AU)'
                write(91,1122)reff3*separ*0.0046491d0,
     @                  'radius #3 (AU)'
                if(Nbody.ge.4)then
                  write(91,1122)reff4*separ*0.0046491d0,
     @                  'radius #4 (AU)'
                endif
                if(Nbody.ge.5)then
                  write(91,1122)reff5*separ*0.0046491d0,
     @                   'radius #5 (AU)'
                endif
                if(Nbody.ge.6)then
                  write(91,1122)reff6*separ*0.0046491d0,
     @                   'radius #6 (AU)'
                endif
                if(Nbody.ge.7)then
                  write(91,1122)reff7*separ*0.0046491d0,
     @                   'radius #7 (AU)'
                endif
                if(Nbody.ge.8)then
                  write(91,1122)reff8*separ*0.0046491d0,
     @                   'radius #8 (AU)'
                endif
                if(Nbody.ge.9)then
                  write(91,1122)reff9,
     @                   'radius #9 (AU)'
                endif
                if(Nbody.ge.10)then
                  write(91,1122)reff10*separ*0.0046491d0,
     @                   'radius #10 (AU)'
                endif


                write(91,1128)
                write(91,1131)Tref
                write(91,1128)
                write(91,1122)rIBCinp(1,1),'period 1 (days)'
                write(91,1122)rIBCinp(1,2),'e*cos(omega) 1'
                write(91,1122)rIBCinp(1,3),'e*sin(omega) 1'
                write(91,1122)rIBCinp(1,4),'inclination 1 (rad)'
                write(91,1122)rIBCinp(1,5),'Omega 1 (rad)'
                write(91,1122)rIBCinp(1,6),'Tconj 1'
                write(91,1128)
                write(91,1122)rIBCinp(2,1),'period 2 (days)'
                write(91,1122)rIBCinp(2,2),'e*cos(omega) 2'
                write(91,1122)rIBCinp(2,3),'e*sin(omega) 2'
                write(91,1122)rIBCinp(2,4),'inclination 2 (rad)'
                write(91,1122)rIBCinp(2,5),'Omega 2 (rad)'
                write(91,1122)rIBCinp(2,6),'Tconj 2'
                write(91,1128)               
                if(Nbody.ge.4)then
                  write(91,1122)rIBCinp(3,1),'period 3 (days)'
                  write(91,1122)rIBCinp(3,2),'e*cos(omega) 3'
                  write(91,1122)rIBCinp(3,3),'e*sin(omega) 3'
                  write(91,1122)rIBCinp(3,4),'inclination 3 (rad)'
                  write(91,1122)rIBCinp(3,5),'Omega 3 (rad)'
                  write(91,1122)rIBCinp(3,6),'Tconj 3'
                  write(91,1128)                
                endif
                if(Nbody.ge.5)then
                  write(91,1122)rIBCinp(4,1),'period 4 (days)'
                  write(91,1122)rIBCinp(4,2),'e*cos(omega) 4'
                  write(91,1122)rIBCinp(4,3),'e*sin(omega) 4'
                  write(91,1122)rIBCinp(4,4),'inclination 4 (rad)'
                  write(91,1122)rIBCinp(4,5),'Omega 4 (rad)'
                  write(91,1122)rIBCinp(4,6),'Tconj 4'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)rIBCinp(5,1),'period 5 (days)'
                  write(91,1122)rIBCinp(5,2),'e*cos(omega) 5'
                  write(91,1122)rIBCinp(5,3),'e*sin(omega) 5'
                  write(91,1122)rIBCinp(5,4),'inclination 5 (rad)'
                  write(91,1122)rIBCinp(5,5),'Omega 5 (rad)'
                  write(91,1122)rIBCinp(5,6),'Tconj 5'
                  write(91,1128)                 
                endif
                if(Nbody.ge.7)then
                  write(91,1122)rIBCinp(6,1),'period 6 (days)'
                  write(91,1122)rIBCinp(6,2),'e*cos(omega) 6'
                  write(91,1122)rIBCinp(6,3),'e*sin(omega) 6'
                  write(91,1122)rIBCinp(6,4),'inclination 6 (rad)'
                  write(91,1122)rIBCinp(6,5),'Omega 6 (rad)'
                  write(91,1122)rIBCinp(6,6),'Tconj 6'
                  write(91,1128)                  
                endif
                if(Nbody.ge.8)then
                  write(91,1122)rIBCinp(7,1),'period 7 (days)'
                  write(91,1122)rIBCinp(7,2),'e*cos(omega) 7'
                  write(91,1122)rIBCinp(7,3),'e*sin(omega) 7'
                  write(91,1122)rIBCinp(7,4),'inclination 7 (rad)'
                  write(91,1122)rIBCinp(7,5),'Omega 7 (rad)'
                  write(91,1122)rIBCinp(7,6),'Tconj 7'
                  write(91,1128)                  
                endif
                if(Nbody.ge.9)then
                  write(91,1122)rIBCinp(8,1),'period 8 (days)'
                  write(91,1122)rIBCinp(8,2),'e*cos(omega) 8'
                  write(91,1122)rIBCinp(8,3),'e*sin(omega) 8'
                  write(91,1122)rIBCinp(8,4),'inclination 8 (rad)'
                  write(91,1122)rIBCinp(8,5),'Omega 8 (rad)'
                  write(91,1122)rIBCinp(8,6),'Tconj 8'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)rIBCinp(9,1),'period 9 (days)'
                  write(91,1122)rIBCinp(9,2),'e*cos(omega) 9'
                  write(91,1122)rIBCinp(9,3),'e*sin(omega) 9'
                  write(91,1122)rIBCinp(9,4),'inclination 9 (rad)'
                  write(91,1122)rIBCinp(9,5),'Omega 9 (rad)'
                  write(91,1122)rIBCinp(9,6),'Tconj 9'
                  write(91,1128)                  
                endif
                write(91,1129)Tref
                write(91,1128)
                write(91,1122)dynQQ(1),'x-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(2),'y-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(3),'z-coordinate, body 1 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(4),'x-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(5),'y-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(6),'z-coordinate, body 2 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(7),'x-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(8),'y-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(9),'z-coordinate, body 3 (AU)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynQQ(10),'x-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(11),'y-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(12),'z-coordinate, body 4 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynQQ(13),'x-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(14),'y-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(15),'z-coordinate, body 5 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynQQ(16),'x-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(17),'y-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(18),'z-coordinate, body 6 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynQQ(19),'x-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(20),'y-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(21),'z-coordinate, body 7 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynQQ(22),'x-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(23),'y-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(24),'z-coordinate, body 8 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynQQ(25),'x-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(26),'y-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(27),'z-coordinate, body 9 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynQQ(28),'x-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(29),'y-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(30),'z-coordinate, body 10 (AU)'
                  write(91,1128)
                endif
c
                write(91,1122)dynPP(1),'x-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(2),'y-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(3),'z-velocity, body 1 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(4),'x-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(5),'y-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(6),'z-velocity, body 2 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(7),'x-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(8),'y-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(9),'z-velocity, body 3 (AU/day)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynPP(10),'x-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(11),'y-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(12),'z-velocity, body 4 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynPP(13),'x-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(14),'y-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(15),'z-velocity, body 5 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynPP(16),'x-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(17),'y-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(18),'z-velocity, body 6 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynPP(19),'x-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(20),'y-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(21),'z-velocity, body 7 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynPP(22),'x-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(23),'y-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(24),'z-velocity, body 8 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynPP(25),'x-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(26),'y-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(27),'z-velocity, body 9 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynPP(28),'x-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(29),'y-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(30),'z-velocity, body 10 (AU/day)'
                  write(91,1128)
                endif
              endif
c
              if(it2.ge.1)then
                call writetex(Nbody,rIBCinp,dynPP,dynQQ,rmass,Tref,hh)
              endif
              if(tref.ne.tstart)then
                tdiff=dabs(tstart-tref)
                temphh=hh
                if(tstart.lt.tref)then
                  temphh=-temphh
                endif
                call goback(Nbody,temphh,tref,tstart,Nstep,
     @            dynQQ,dynPP,rmass,posarray,velarray,odetime,zzq,
     @            timeinterp,Ndyn,iGR,tideparm)
              endif
c
              if(it2.gt.0)then
                write(91,1129)Tstart
                write(91,1128)
                write(91,1122)dynQQ(1),'x-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(2),'y-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(3),'z-coordinate, body 1 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(4),'x-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(5),'y-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(6),'z-coordinate, body 2 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(7),'x-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(8),'y-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(9),'z-coordinate, body 3 (AU)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynQQ(10),'x-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(11),'y-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(12),'z-coordinate, body 4 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynQQ(13),'x-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(14),'y-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(15),'z-coordinate, body 5 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynQQ(16),'x-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(17),'y-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(18),'z-coordinate, body 6 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynQQ(19),'x-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(20),'y-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(21),'z-coordinate, body 7 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynQQ(22),'x-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(23),'y-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(24),'z-coordinate, body 8 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynQQ(25),'x-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(26),'y-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(27),'z-coordinate, body 9 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynQQ(28),'x-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(29),'y-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(30),'z-coordinate, body 10 (AU)'
                  write(91,1128)
                endif
c
                write(91,1122)dynPP(1),'x-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(2),'y-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(3),'z-velocity, body 1 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(4),'x-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(5),'y-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(6),'z-velocity, body 2 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(7),'x-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(8),'y-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(9),'z-velocity, body 3 (AU/day)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynPP(10),'x-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(11),'y-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(12),'z-velocity, body 4 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynPP(13),'x-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(14),'y-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(15),'z-velocity, body 5 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynPP(16),'x-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(17),'y-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(18),'z-velocity, body 6 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynPP(19),'x-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(20),'y-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(21),'z-velocity, body 7 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynPP(22),'x-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(23),'y-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(24),'z-velocity, body 8 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynPP(25),'x-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(26),'y-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(27),'z-velocity, body 9 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynPP(28),'x-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(29),'y-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(30),'z-velocity, body 10 (AU/day)'
                  write(91,1128)
                endif
                write(91,1128)
              endif

              timein=0.0d0
              ibody=2 
              call cartKep(Nbody,ibody,rmass,dynQQ,dynPP,Tref,timein,
     @          eccout1,
     @          argout1,rinclout1,Omegaout1,astarout1,rmeanou1t,
     @          trueanomout1,periodout1)
c
 6970         format('#  initial separation (solar radii):',2x,f20.13)
 6971         format('#  initial eccentricty:',19x,f15.13,/
     @               '#  initial omega (deg):',17x,f15.10,/
     @               '#  initial period (days):',15x,f15.10/)
c
              arg1=argout1
              ecc1=eccout1
              period1=periodout1
              tstart1=tstart
              call solveorbit(Nbody,hh,tstart,tend,Nstep,dynQQ,dynPP,
     @          rmass,posarray,velarray,odetime,zzq,timeinterp,Ndyn,iGR,
     @          tideparm)
c
 5972         format(f16.5,2x,30(1pe25.17,1x))
              if(it2.ge.1)then
                open(unit=92,file='ELCdynamics.pos',status='unknown')
                open(unit=93,file='ELCdynamics.vel',status='unknown')
                do jjj=1,Nstep
                  write(92,5972)odetime(jjj),
     @                (posarray(jjj,lbody),lbody=1,3*Nbody)
                  write(93,5972)odetime(jjj),
     @                (velarray(jjj,lbody),lbody=1,3*Nbody)
                enddo
                close(92)
                close(93)
              endif
              if(it2.gt.0)then
                write(91,1129)odetime(Nstep)
                write(91,1128)
                write(91,1122)dynQQ(1),'x-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(2),'y-coordinate, body 1 (AU)'
                write(91,1122)dynQQ(3),'z-coordinate, body 1 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(4),'x-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(5),'y-coordinate, body 2 (AU)'
                write(91,1122)dynQQ(6),'z-coordinate, body 2 (AU)'
                write(91,1128)
                write(91,1122)dynQQ(7),'x-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(8),'y-coordinate, body 3 (AU)'
                write(91,1122)dynQQ(9),'z-coordinate, body 3 (AU)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynQQ(10),'x-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(11),'y-coordinate, body 4 (AU)'
                  write(91,1122)dynQQ(12),'z-coordinate, body 4 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynQQ(13),'x-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(14),'y-coordinate, body 5 (AU)'
                  write(91,1122)dynQQ(15),'z-coordinate, body 5 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynQQ(16),'x-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(17),'y-coordinate, body 6 (AU)'
                  write(91,1122)dynQQ(18),'z-coordinate, body 6 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynQQ(19),'x-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(20),'y-coordinate, body 7 (AU)'
                  write(91,1122)dynQQ(21),'z-coordinate, body 7 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynQQ(22),'x-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(23),'y-coordinate, body 8 (AU)'
                  write(91,1122)dynQQ(24),'z-coordinate, body 8 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynQQ(25),'x-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(26),'y-coordinate, body 9 (AU)'
                  write(91,1122)dynQQ(27),'z-coordinate, body 9 (AU)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynQQ(28),'x-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(29),'y-coordinate, body 10 (AU)'
                  write(91,1122)dynQQ(30),'z-coordinate, body 10 (AU)'
                  write(91,1128)
                endif
c
                write(91,1122)dynPP(1),'x-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(2),'y-velocity, body 1 (AU/day)'
                write(91,1122)dynPP(3),'z-velocity, body 1 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(4),'x-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(5),'y-velocity, body 2 (AU/day)'
                write(91,1122)dynPP(6),'z-velocity, body 2 (AU/day)'
                write(91,1128)
                write(91,1122)dynPP(7),'x-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(8),'y-velocity, body 3 (AU/day)'
                write(91,1122)dynPP(9),'z-velocity, body 3 (AU/day)'
                write(91,1128)
                if(Nbody.ge.4)then
                  write(91,1122)dynPP(10),'x-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(11),'y-velocity, body 4 (AU/day)'
                  write(91,1122)dynPP(12),'z-velocity, body 4 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.5)then
                  write(91,1122)dynPP(13),'x-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(14),'y-velocity, body 5 (AU/day)'
                  write(91,1122)dynPP(15),'z-velocity, body 5 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.6)then
                  write(91,1122)dynPP(16),'x-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(17),'y-velocity, body 6 (AU/day)'
                  write(91,1122)dynPP(18),'z-velocity, body 6 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.7)then
                  write(91,1122)dynPP(19),'x-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(20),'y-velocity, body 7 (AU/day)'
                  write(91,1122)dynPP(21),'z-velocity, body 7 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.8)then
                  write(91,1122)dynPP(22),'x-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(23),'y-velocity, body 8 (AU/day)'
                  write(91,1122)dynPP(24),'z-velocity, body 8 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.9)then
                  write(91,1122)dynPP(25),'x-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(26),'y-velocity, body 9 (AU/day)'
                  write(91,1122)dynPP(27),'z-velocity, body 9 (AU/day)'
                  write(91,1128)
                endif
                if(Nbody.ge.10)then
                  write(91,1122)dynPP(28),'x-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(29),'y-velocity, body 10 (AU/day)'
                  write(91,1122)dynPP(30),'z-velocity, body 10 (AU/day)'
                  write(91,1128)
                endif
                write(91,1128)
              endif
c
              timein=0.0d0
              ibody=2 
              call cartKep(Nbody,ibody,rmass,dynQQ,dynPP,Tref,timein,
     @          eccout,
     @          argout,rinclout,Omegaout,astarout,rmeanout,trueanomout,
     @          periodout)
c
 6972         format('#  final separation (solar radii):',4x,f20.13)
 6973         format('#  final eccentricty:',21x,f15.13,/
     @               '#  final omega (deg):',19x,f15.10,/
     @               '#  final period (days):',17x,f15.10/)
c
              if((it2.ge.1).and.(iGR.ge.1))then
                write(91,6970)astarout1/0.0046491d0
                write(91,6971)eccout1,argout1*180.0d0/pie,periodout1
              endif

              if((it2.ge.1).and.(iGR.ge.1))then
                write(91,6972)astarout/0.0046491d0
                write(91,6973)eccout,argout*180.0d0/pie,periodout
              endif
c
              ecc2=eccout
              arg2=argout
              period2=periodout
              tstart2=odetime(Nstep)
c
              if((it2.ge.1).and.(iGR.ge.1))then
                write(91,6974)ecc1-ecc2,period1-period2
              endif
 6974         format('#  Delta ecc:',22x,f15.12,2x,/
     @         '#  Delta Period (days):',12x,f15.12)

              omegadotgr=2.29d-3*(rmass(1)+rmass(2))
              omegadotgr=omegadotgr/((astarout/0.0046491)*(1.0d0
     @           -ecc1*ecc1))
c
              if((it2.ge.1).and.(iGR.ge.1))then
                write(91,6975)(arg2-arg1)*180.0d0/pie,tstart2-tstart1
              endif
 6975         format('#  Delta omega (deg):',14x,f15.9,2x,/
     @               '#  Delta t (days): ',15x, f15.9/)
c
              cyclenum=(tstart2-tstart1)/period1
              deltaomega=(arg2-arg1)*180.0d0/pie/cyclenum

              if((it2.ge.1).and.(iGR.ge.1))then
                write(2,6976)deltaomega
              endif
 6976         format('#  Delta omega (deg/cycle):',10x,f15.12)

              if((it2.ge.1).and.(iGR.eq.2))then
                george= apsidalrate(sw72,sw73,rmass(1),rmass(2),omega1,
     @           omega2,period,reff1,reff2,astarout/0.0046491d0,ecc1)
                if(it2.ge.1)then
                  write(91,6977)george,deltaomega/george
                endif
 6977           format('#  Analytic Delta omega (deg/cycle):',1x,
     @            f15.12,2x,/'#  ratio of numerical to analytic: ',2x,
     @            f15.9)
              endif
c
             if((it2.ge.1).and.(iGR.eq.1))then
                omegadotgr=2.29d-3*(rmass(1)+rmass(2))
                omegadotgr=omegadotgr/((astarout/0.0046491d0)*(1.0d0
     @            -ecc1*ecc1))
                if(it2.ge.1)then
                  write(91,6977)omegadotgr,deltaomega/omegadotgr
                endif
              endif
c
              if(it2.ge.1)close(91)
c
c   find the times of primary and secondary eclipses
c
              Nprim=0
              Nsec=0
              call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @          zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @          Distprim,Distsec,reff1,reff2,separ,1,2,Nmaxeclipse,
     @          durprim1,dursec1,durprim2,dursec2)

              Ncycle(1)=Nprim
              Ncycle(2)=Nsec
              do ij=1,Nprim
                Ttimes(1,ij)=Eprim(ij)
                Tseps(1,ij)=Distprim(ij)
                Tdur1(1,ij)=durprim1(ij)
                Tdur2(1,ij)=durprim2(ij)
              enddo
              do ij=1,Nsec
                Ttimes(2,ij)=Esec(ij)
                Tseps(2,ij)=Distsec(ij)                
                Tdur1(2,ij)=dursec1(ij)
                Tdur2(2,ij)=dursec2(ij)
              enddo
c
c   find the times of transit and occultation of body 3 by the
c   primary
c
              call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @          zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @          Distprim,Distsec,reff1,reff3,separ,1,3,Nmaxeclipse,
     @          durprim1,dursec1,durprim2,dursec2)
c
              Ncycle(3)=Nprim
              Ncycle(4)=Nsec
              do ij=1,Nprim
                Ttimes(3,ij)=Eprim(ij)
                Tseps(3,ij)=Distprim(ij)
                Tdur1(3,ij)=durprim1(ij)
                Tdur2(3,ij)=durprim2(ij)
              enddo
              do ij=1,Nsec
                Ttimes(4,ij)=Esec(ij)
                Tseps(4,ij)=Distsec(ij)                
                Tdur1(4,ij)=dursec1(ij)
                Tdur2(4,ij)=dursec2(ij)
              enddo
c
c   find the times of transit and occultation of body 3 by the
c   secondary
c
              call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @          zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @          Distprim,Distsec,reff2,reff3,separ,2,3,Nmaxeclipse,
     @          durprim1,dursec1,durprim2,dursec2)
c
              Ncycle(5)=Nprim
              Ncycle(6)=Nsec
              do ij=1,Nprim
                Ttimes(5,ij)=Eprim(ij)
                Tseps(5,ij)=Distprim(ij)
                Tdur1(5,ij)=durprim1(ij)
                Tdur2(5,ij)=durprim2(ij)
              enddo
              do ij=1,Nsec
                Ttimes(6,ij)=Esec(ij)
                Tseps(6,ij)=Distsec(ij)                
                Tdur1(6,ij)=dursec1(ij)
                Tdur2(6,ij)=dursec2(ij)
              enddo
c
c   find the times of transit and occultation of body 4 by the
c   primary
c
              if(Nbody.ge.4)then
                call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @            zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @            Distprim,Distsec,reff1,reff4,separ,1,4,Nmaxeclipse,
     @            durprim1,dursec1,durprim2,dursec2)

c
                Ncycle(7)=Nprim
                Ncycle(8)=Nsec
                do ij=1,Nprim
                  Ttimes(7,ij)=Eprim(ij)
                  Tseps(7,ij)=Distprim(ij)
                  Tdur1(7,ij)=durprim1(ij)
                  Tdur2(7,ij)=durprim2(ij)
                enddo
                do ij=1,Nsec
                  Ttimes(8,ij)=Esec(ij)
                  Tseps(8,ij)=Distsec(ij)                
                  Tdur1(8,ij)=dursec1(ij)
                  Tdur2(8,ij)=dursec2(ij)
                enddo
c
c   find the times of transit and occultation of body 4 by the
c   secondary
c
                call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @            zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @            Distprim,Distsec,reff2,reff4,separ,2,4,Nmaxeclipse,
     @            durprim1,dursec1,durprim2,dursec2)

c
                Ncycle(9)=Nprim
                Ncycle(10)=Nsec
                do ij=1,Nprim
                  Ttimes(9,ij)=Eprim(ij)
                  Tseps(9,ij)=Distprim(ij)
                  Tdur1(9,ij)=durprim1(ij)
                  Tdur2(9,ij)=durprim2(ij)
                enddo
                do ij=1,Nsec
                  Ttimes(10,ij)=Esec(ij)
                  Tseps(10,ij)=Distsec(ij)                
                  Tdur1(10,ij)=dursec1(ij)
                  Tdur2(10,ij)=dursec2(ij)
                enddo
              endif
c
c   find the times of transit and occultation of body 5 by the
c   primary
c
              if(Nbody.ge.5)then
                call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @            zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @            Distprim,Distsec,reff1,reff5,separ,1,5,Nmaxeclipse,
     @            durprim1,dursec1,durprim2,dursec2)

c
                Ncycle(11)=Nprim
                Ncycle(12)=Nsec
                do ij=1,Nprim
                  Ttimes(11,ij)=Eprim(ij)
                  Tseps(11,ij)=Distprim(ij)
                  Tdur1(11,ij)=durprim1(ij)
                  Tdur2(11,ij)=durprim2(ij)
                enddo
                do ij=1,Nsec
                  Ttimes(12,ij)=Esec(ij)
                  Tseps(12,ij)=Distsec(ij)                
                  Tdur1(12,ij)=dursec1(ij)
                  Tdur2(12,ij)=dursec2(ij)
                enddo
c
c   find the times of transit and occultation of body 5 by the
c   secondary
c
                call findprimaryeclipse(Nbody,posarray,velarray,odetime,
     @            zzq,timeinterp,nstep,Nprim,Eprim,Nsec,Esec,Ndyn,
     @            Distprim,Distsec,reff2,reff5,separ,2,5,Nmaxeclipse,
     @            durprim1,dursec1,durprim2,dursec2)

c
                Ncycle(13)=Nprim
                Ncycle(14)=Nsec
                do ij=1,Nprim
                  Ttimes(13,ij)=Eprim(ij)
                  Tseps(13,ij)=Distprim(ij)
                  Tdur1(13,ij)=durprim1(ij)
                  Tdur2(13,ij)=durprim2(ij)
                enddo
                do ij=1,Nsec
                  Ttimes(14,ij)=Esec(ij)
                  Tseps(14,ij)=Distsec(ij)                
                  Tdur1(14,ij)=dursec1(ij)
                  Tdur2(14,ij)=dursec2(ij)
                enddo
              endif
c
            endif        !end if Nbody.ge.3
c
            if((isw28.gt.0).and.(isw7.gt.1))then
              call getT0star(finc,period,ecc,argper,T0,Tconj)
            endif

            call fastanalytic(Nphase,Nmaxphase,xmod,ymodU,ymodB,
     $       ymodV,ymodR,ymodI,ymodJ,ymodH,ymodK,ymods1,ymods2,ymods3,
     &       ymodd,RV1,RV2,drv1,drv2,NRVphase,xRVmod,
     &       fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     $       ratrad,period,T0,
     @       ecc,argper,omega1,
     $       finc,ilaw,dwavex,dwavey,bigI,bigbeta,sw29,sw30,isw21,ikeep,
     %       pshift,reff1,reff2,darkint1,darkint2,
     %       idark2,dphase,iRVfilt,vrot1,vrot2,Q,separ,gamma,isw27,
     &       icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,icnRV1,icnRV2,
     &       timearray,sw9,sw23,sw24,isw7,SA3,third,contam,pconj,
     @       beam1,beam2,Ngap,gaplow,gaphigh,tertperiod,tertt0,tertecos,
     @       tertesin,tertincl,tertOmega,tertQ,itconj,tertconj,isw30,
     @       darkint3,omegadot,odetime,zzq,Nstep,timeinterp,isw33,
     @       contamS0,contamS1,contamS2,contamS3,Iseason,Ndyn,
     @       P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
     @       P2ratrad,
     @       P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @       P3ratrad,
     @       P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,P4Omega,P4Q,
     @       P4ratrad,
     @       P5tconj,P5period,P5T0,P5ecos,P5esin,P5incl,P5Omega,P5Q,
     @       P5ratrad,   
     @       P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
     @       P6ratrad,
     @       P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
     @       P7ratrad,
     @       P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @       P8ratrad,RV3,NSC,xSC,ySC)
c
            rpole1=1.0d0
            rpole2=1.0d0
            bdist=1.0d0
c
            call parms(1,Teff2,Q,finc,separ,period,reff1,reff2,
     $        vrot1,vrot2,gscale1,gscale2,omega1,omega2,
     @        bdist,ecc)
c
            obsparm(19)=t3
            call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     $        gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,
     $        obsparm,bdist,ecc,argper,teff1)
c
            pot1=0.0d0
            pot2=0.0d0
            ave11=0.0d0
            ave12=0.0d0
            ave21=0.0d0
            ave22=0.0d0
            ave1=0.0d0
            ave2=0.0d0
c
            call getdepth(Nphase,ymodU,rdepth)
            call lineparms1(Teff2,Q,
     %        finc,separ,period,reff1,reff2,
     $        vrot1,vrot2,omega1,omega2,
     $        bdist,ecc,SA3,ave11,ave12,ave21,ave22,ave1,ave2,
     @        parmstring,pot1,pot2,rdepth,tertQ,argper)
c
            if(isw30.gt.0)call planetparms(planetparm,Tref,Q,finc,
     @        separ,period,
     @        reff1,reff2,ecc,SA3,tertperiod,tertt0,tertecos,tertesin,
     @        tertincl,tertOmega,tertQ,itconj,tertconj,isw30,P2tconj,
     @        P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,P2ratrad,
     @        P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @        P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,
     @        P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,P5esin,
     @        P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,P6ecos,
     @        P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,P7T0,
     @        P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,P8tconj,
     @        P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,P8ratrad,
     @        argper,T0,Tconj,isw28)

            icount=Nphase
            if(isw24.ge.1)call getanalfracs(Nmaxphase,icount,
     %      fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     &         compfracs,Nphase,
     %         xmod,eshift,pshift,sw26)
c
c            if(isw23.ge.1)then
c              call analdistorttime(Nmaxphase,Nphase,xmod,RV2,gamma,
c     %           pconj)
c            endif
c
            close(2)
            return
          endif    !end fast analytic block
c
c   UPDATE JULY 21, 2006
c
c   Add a "fast genetic" mode.  If ifastflag=1, then set 
c     Nalph1=40 
c     Nbet1=14
c     Nalph2=40
c     Nbet2=14
c     dphase=3
c 
c   We need to save the values to reset at the end of the subroutine
c
         iNa1save=Nalph1
         iNa2save=Nalph2
         iNb1save=Nbet1
         iNb2save=Nbet2
         savedphase=dphase
c
         if(ifastflag.ge.1)then
           Nalph1=40
           Nalph2=40
           Nbet1=14
           Nbet2=14
           dphase=10.0d0*savedphase
           if(dphase.gt.3.0d0)dphase=3.0d0
         endif
c
c   Save the value of the flag iecheck so we can reset it at the end of the
c   routine.
c
          iesave=iecheck
c
c  UPDATE May 8, 2006
c
c  Add new flags and variables, including ialign, bigI, bigbeta.
c
          ialign=isw21
          if(ialign.le.0)then
            bigbeta=0.0d0
            savethetamis=bigI
            savephimis=bigbeta
          endif
c
          ionephase=isw1
          onephase=sw1
          isquare=isw2
          iusepot=isw3
          usepot1=sw2
          usepot2=sw3
          bdist=1.0d0
c
          fluxU2=0.0d0
          fluxB2=0.0d0
          fluxV2=0.0d0
          fluxR2=0.0d0
          fluxI2=0.0d0
          fluxJ2=0.0d0
          fluxH2=0.0d0
          fluxK2=0.0d0
c
c   UPDATE May 10, 2006
c
c   If we are in analytic mode (isw12>0), then set iehceck=0 and ism1=0
c
c
          if(isw12.gt.0)then
            ism1=0
            iecheck=1
          endif
c
c   RVG BUG ALERT   May 8, 2001
c
c   Define the 'simpson switch' and the 'gravity exponent switch'
c
          tteff2=0.0d0
          if(sw5.gt.0.0d0)tteff2=teff2
c
c   UPDATE October 13, 2008
c
c   Redefine the isw5 switch.  It will now control how the spot
c   temperature profile is computed.
c
c   ispotprof=0    constant temperature factor
c   ispotprof=1    linear change in temperature profile
c   ispotprof=2    Gaussian change
c
          isimp=0
          ispotprof=isw5
          igrav=isw6
c
c   Count the number of spots on each star.
c
          ispot1=0
          ispot2=0
          ispotd=0
          do 4500 ii=1,2
            if(spot1parm(ii,1).gt.0.0d0)ispot1=ispot1+1          
            if(spot2parm(ii,1).gt.0.0d0)ispot2=ispot2+1          
            if(spotdparm(ii,1).gt.0.0d0)ispotd=ispotd+1          
 4500     continue
c
          if(igrav.eq.1)call gravexp(Teff1,Tgrav1,1)
          if((igrav.eq.2).and.(teff2.gt.0.0d0))then
            call gravexp(Teff2,Tgrav2,2)
          endif
          if(igrav.eq.3)then 
            call gravexp(Teff1,Tgrav1,1)           
            if(Teff2.gt.0.0d0)call gravexp(Teff2,Tgrav2,2)
          endif
c
          ivrt=0
          fillper1=fill1
          fillper2=fill2
          bdist=1.0d0-ecc
          pervol1=1.0d0
          pervol2=1.0d0
c
c   If isynch = 1, then set the omega values so that the rotation is
c   synchronous at periastron.
c
          if((ecc.gt.0.0d0).and.(isynch.ge.1))then 
c
c            sss=dsqrt((1.0d0+ecc)/(1.0d0-ecc**3))
c
c   UPDATE January 13, 2009
c
c   fix the error
c
            sss=dsqrt((1.0d0+ecc)/(1.0d0-ecc)**3)
            omega1=sss
            omega2=sss
          endif
c
          tstep=sw9
          tstart=sw23
          tstop=sw24
c
          if(isw7.eq.2)call filltime(ntime,timearray,tstart,tstop,tstep)
c
c   UPDATE JULY 4, 2004
c
c   Assign the variable MonteCarlo to isw8.  It will be used
c   in the Monte Carlo routine to compute fractionally eclipsed
c   pixels.
c
          MonteCarlo=isw8
c
c   Initialize the Sobel sequence here
c
          nnn=2          
          call sobseq(nnn,xsob)
          call sobseq(nnn,xsob)
          call sobseq(nnn,xsob)
          nnn=-1
          call sobseq(nnn,xsob)
c
c   UPDATE December 21, 2008
c
c   Here is a new subroutine call.  radfill sets the filling 
c   factor based on the 
c   effective radius, rather than the L_1 point distance
c
          radfill1=sw27
          radfill2=sw28
          bdist=1.0d0-ecc
          call setfill(1,Q,fill1,radfill1,omega1,bdist,tidephi,
     &        itide,ecc,thetamis,phimis)
          call setfill(2,Q,fill2,radfill2,omega2,bdist,tidephi,
     @        itide,ecc,thetamis,phimis)
c
c   UPDATE September 11, 2001
c
c   Add the iverb flag to the end of setupgeo.
c
c          omegatwo=omega2
          iverb=0
          call setupgeo(1,ialphmax1,ibetmax1,Nalph1,Nbet1,ibetlim1,
     $       fill1,omega1,Q,finc,
     $       x1,y1,z1,
     %       surf1,rad1,gradx1,grady1,gradz1,g1,xend1,separ,
     %       Tgrav1,Teff1,reff1,Rl1,Tpole1,Rpol1,Regg1,SA1,pot1,gpole1,
     %       phiar1,isquare,iusepot,usepot1,ivrt,pervol1,fillper1,bdist,
     @       pots1,iverb,mmdx1,primmass,primK,primrad,ratrad,frac1,frac2,
     &       ecc,period,size1,sw5,tteff2,density,
     $       tidephi,itide,phistart1,thetamis,phimis)
c
c   November 17, 2012
c
c   Load the third body geometry
c
          if((isw30.ge.1).and.(isw7.ge.2))then
            call setupgeo3(ialphmax3,ibetmax3,
     $        Nalph3,Nbet3,ibetlim3,x3,y3,z3,mmdx3,phiar3,
     %        surf3,rad3,gradx3,grady3,gradz3,gthird,temp3,
     $        reff1,SA3,reff3,t3,g3,grav3)
c
            fincr=finc*pie/180.0d0        ! radians
            ppp=period*24.0d0             ! period in hours
c            sifinc=dsin(fincr)
            total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
            tertmass=total_mass/tertQ
            gmsun=1.32712440018d20   !m^3/sec^2
            tt1=(total_mass+tertmass)*(tertperiod*86400.0d0)**2*gmsun
            smet=(tt1/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep=smet/6.9598d8   !6.959d8 
            axisscale=tertsep/separ
            tt1=(total_mass)*(period*86400.0d0)**2*gmsun
            smet=(tt1/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c 
            Nhoriz1=360
            Nhoriz2=360
            call fakehorizon(Nhoriz1,xhoriz1,yhoriz1,999.9d9,999.9d0,
     @              1.0d0)
            call fakehorizon(Nhoriz2,xhoriz2,yhoriz2,999.9d0,999.9d0,
     @              1.0d0)
            Neclipse3=0
            Nsky3=0
            if(isw30.gt.0)call getvisib3(3,ialphmax3,ibetmax3,Nalph3,
     @        ibetlim3,
     %        0.0d0,finc,Q,psi0,1.0d0,gradx3,grady3,gradz3,x3,y3,
     @        z3,visib3,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,
     @        xhoriz2,yhoriz2,Nsky3,xsky3,ysky3,
     @        projarray3,1,Neclipse3,phiar3,rad3,delphi3,
     @        mmdx3,0,phistart3,thetamis,phimis,
     @        1,iedgehor3,
     @        tertincl,1.0d0,90.0d0,tertQ,axisscale,isw30,isw7,
     @        tertOmega)
c
            if(iatm.le.0)then
              do jj=1,8
                www=wave(jj)
                flimbx=dwavex(jj,3)
                flimby=dwavey(jj,3)
c  
                call getBBflux(ialphmax3,ibetmax3,
     @             Nalph3,ibetlim3,www,visib3,projarray3,temp3,surf3,
     $             flimbx,flimby,ilaw,rinty3,flum3,flux3,delphi3,
     @             delphie3,iedgestar3,iedgehor3,rldint3,separ,mmdx3,
     @             MonteCarlo,isw13,ialfmin,ialfmax,fluxlat,1,phiar3,
     @             phihor3)
                flux3keep(jj)=flux3
             enddo
           else
             gscale3=1.0d0                          !!!!
             call getATMint(maxlines,maxmu,Nlines,
     &            atmT,atmg,atmmu,Nmu,
     &            atmint1,atmint2,atmint3,atmint4,atmint5,
     &            atmint6,atmint7,atmint8,
     &            gscale3,darkint3,t3,g3,
     %            dwavex,dwavey,ilaw,iatm,2)
c
             call getATMflux(ialphmax3,ibetmax3,Nalph3,
     @          ibetlim3,visib3,projarray3,temp3,surf3,grav3,rinty3,
     @          flum3,maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &          atmint1,atmint2,atmint3,atmint4,atmint5,
     $          atmint6,atmint7,atmint8,gscale3,
     &          fluxU3,fluxB3,fluxV3,fluxR3,fluxI3,fluxJ3,fluxH3,
     @          fluxK3,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     @          iRVfilt,delphi3,delphie3,iedgestar3,iedgehor3,
     @          separ,mmdx3,MonteCarlo,dwavex,dwavey,ilaw,
     @          iatm,3,darkint3)
c
             thirdkeep(1)=fluxU3
             thirdkeep(2)=fluxB3
             thirdkeep(3)=fluxV3
             thirdkeep(4)=fluxR3
             thirdkeep(5)=fluxI3
             thirdkeep(6)=fluxJ3
             thirdkeep(7)=fluxH3
             thirdkeep(8)=fluxK3
           endif
c
          endif
c
          if(teff2.gt.0.0d0)then
            call setupgeo(2,ialphmax2,ibetmax2,Nalph2,Nbet2,ibetlim2,
     $        fill2,omega2,Q,finc,x2,y2,z2,surf2,rad2,gradx2,grady2,
     @        gradz2,g2,xend2,separ,Tgrav2,Teff2,reff2,Rl2,Tpole2,Rpol2,
     @        Regg2,SA2,pot2,gpole2,phiar2,isquare,iusepot,usepot2,ivrt,
     @        pervol2,fillper2,bdist,pots2,iverb,mmdx2,primmass,primK,
     @        primrad,ratrad,frac1,frac2,ecc,period,size1,
     $        sw5,tteff2,density,tidephi,itide,phistart2,
     $        thetamis,phimis)
          else
c
c   UPDATE March 22, 2002
c
c   Add ibetlim2 to the argument list of dummyvalues
c
            call dummyvalues(ialphmax2,ibetmax2,Nalph2,Nbet2,x2,y2,z2,
     @        surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,temp2,
     @        ibetlim2,mmdx2)
            Regg2=rocheradius(Q)
            reff2=Regg2
            overQ=1.0d0/Q
            call findL1(overQ,omega2,x0,1,bdist,tidephi,ecc,
     &         thetamis,phimis)
            Rl2=x0
          endif
c
          if(iidint.ge.1)call disksetup(Nthetamax,Nrmax,Ntheta,Nradius,
     %       betarim,rinner,router,Regg2,Rl2,separ,
     $       tdisk,xi,dtemp,dx,dy,dz,drad,
     $       tedge,xedge,yedge,zedge,redge,stepr,stepz,bdist,
     @       ivrt,reper,rsper)
c
c
c  If the model atmosphere option is on, then compute the third light.
c
c  UPDATE April 3, 2002
c
c  Add separ to the argument list of thirdlight.
c
          if(isw30.le.0)call thirdlight(iatm,t3,g3,SA3,third,maxlines,
     @       maxmu,
     @       Nlines,atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,
     @       atmint5,atmint6,atmint7,atmint8,icnU,
     @       icnB,icnV,icnR,icnI,icnJ,icnH,icnK,separ,dwavex,dwavey,
     @       ilaw,3,reff1)
c
c   If the orbit is eccentric, then we have to loop over phases here.
c   Otherwise, we loop a bit further down.  
c
c   Use the symmetry of the orbit in the mean anomaly M to only compute
c   half the phases for an eccentric orbit.  Thus, do not disable the ism1
c   switch.   Also, define the variable pstep as below (equals dphase by
c   default)
c
          pstart=0.0d0
          pstop=360.0d0-dphase
          pconj=pie
          pconj2=0.0d0
          pstep=dphase
          idcheck=100
          if(ism1.ge.1)pstop=180.0d0
c
c   UPDATE October 18, 2002
c
c   Use the input flags sw7 and sw8 to define a phase range
c   to compute.  Require sw7 > 0 and sw8 > 0  AND  sw7 < sw 8
c
          if((sw7.gt.0.0d0).and.(sw8.gt.0.0d0).and.(sw7.lt.sw8))then
            if((sw8-sw7).lt.dphase)dphase=sw8-sw7
            pstart=sw7
            pstop=sw8-dphase
          endif
          pstartout=onephase
          pstopout=onephase
          if(ecc.gt.0.0d0)then
            pstartout=0.0d0
            pstopout=360.0d0-dphase
            if(ism1.ge.1)pstopout=180.0d0
          endif
c
c   RVG BUG ALERT  April 19, 2001.
c
c   If the ism1 flag is set, then modify the value of pstopout as above.
c
          open(unit=64,file='ELC.phases',status='unknown')
c
c   RVG BUG ALERT  May 3, 2001
c
c   Open a new output file for eccentric orbits.
c
          if(ecc.gt.0.0d0)open(unit=65,file='ELC.eccentric',
     @         status='unknown')
c
          itoggle=-1
          icount=0
          icounttime=0
          togglephase=360.0d0
c
          argrad=argper*pie/180.0d0
c
c  Here is some code adapted from Wilson-Devinney to keep track of
c  phases needed for eccentric orbits.
c
          trc=0.5d0*pie-argrad    
 1139     if(trc.lt.0.d0) trc=trc+2.0d0*pie
          if(trc.lt.0.d0) goto 1139                                           
 1140     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
          if(trc.ge.2.0d0*pie) goto 1140                            
          htrc=0.5d0*trc                                                     
          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 11101              
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 11101              
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))           
          goto 11103                                                          
11101     ecan=pie
11103     xmc=ecan-ecc*dsin(ecan)                                             
          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
          phper=1.d0-xmc/(2.0d0*pie)
          pconj=(xmc+argrad)/(2.0d0*pie)-0.25d0
c
c   UPDATE March 14, 2008
c
c   Make sure the conjunction phase is between 0 and 1
c
          if(pconj.gt.1.0d0)pconj=pconj-1.0d0     
c
c   UPDATE September 10, 2001
c
c   Make this new block to compute the conjunction phase for star 2.
c
          trc=0.5d0*pie-argrad+pie    
 3139     if(trc.lt.0.d0) trc=trc+2.0d0*pie
          if(trc.lt.0.d0) goto 3139                                           
 3140     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
          if(trc.ge.2.0d0*pie) goto 3140                            
          htrc=0.5d0*trc                                                     
          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 37101              
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 37101              
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))           
          goto 31103                                                          
37101     ecan=pie
31103     xmc=ecan-ecc*dsin(ecan)                                             
          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
          phper2=1.d0-xmc/(2.0d0*pie)
          pconj2=(xmc+argrad)/(2.0d0*pie)-0.25d0
c
c   UPDATE March 14, 2008
c
c   Make sure the conjunction phase is between 0 and 1
c
          if(pconj2.gt.1.0d0)pconj2=pconj2-1.0d0     
c
c   Make this new block to compute the conjunction phase for star 3.
c
c          trc=0.5d0*pie-tertargrad    
c 4131     if(trc.lt.0.d0) trc=trc+2.0d0*pie
c          if(trc.lt.0.d0) goto 4131                                           
c 4149     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
c          if(trc.ge.2.0d0*pie) goto 4149                            
c          htrc=0.5d0*trc                                                     
c          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 41109              
c          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41109              
c          ecan=2.d0*datan(dsqrt((1.d0-tertecc)
c     @        /(1.d0+tertecc))*dtan(htrc))           
c          goto 41108                                                          
c41109     ecan=pie
c41108     xmc=ecan-tertecc*dsin(ecan)                               
c          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
c          phper3=1.d0-xmc/(2.0d0*pie)
c          pconj3=(xmc+tertargrad)/(2.0d0*pie)-0.25d0
cc
cc   Make sure the conjunction phase is between 0 and 1
cc
c          if(pconj3.gt.1.0d0)pconj3=pconj3-1.0d0     
c          write(*,*)'pconj3 = ',pconj3*360.0d0,tertargrad,tertarg
cc
c          trc=0.5d0*pie-tertargrad+pie    
c 3839     if(trc.lt.0.d0) trc=trc+2.0d0*pie
c          if(trc.lt.0.d0) goto 3839                                           
c 3840     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
c          if(trc.ge.2.0d0*pie) goto 3840                            
c          htrc=0.5d0*trc                                                     
c          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 37801              
c          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 37801              
c          ecan=2.d0*datan(dsqrt((1.d0-tertecc)
c     @         /(1.d0+tertecc))*dtan(htrc))           
c          goto 31803                                                          
c37801     ecan=pie
c31803     xmc=ecan-tertecc*dsin(ecan)      
c          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
c          phper4=1.d0-xmc/(2.0d0*pie)
c          pconj4=(xmc+tertargrad)/(2.0d0*pie)-0.25d0
cc
cc   UPDATE March 14, 2008
cc
cc   Make sure the conjunction phase is between 0 and 1
cc
c          if(pconj4.gt.1.0d0)pconj4=pconj4-1.0d0     
c
c
c  UPDATE September 10, 2001
c
c  Add the if-then clauses to account for ikeep=1 for star 1 and
c  ikeep = 2 for star 2.
c
          if(ikeep.eq.1)eshift=phper+pconj-0.5
          if(ikeep.eq.2)eshift=phper2+pconj2
c
          if(ecc.eq.0.0d0)then
            eshift=0.0d0
            pconj=0.0d0
          endif
c    
c  UPDATE May 3, 2006
c
c  Add a "fast transit" mode.  If isw13 > 1, then find the range
c  of latitude rows on the star that are eclipsed.  These values
c  are returned as ialfmin,ialfmax
c
          ialfmin=999999
          ialfmax=-111111
          if(isw13.ge.1)then
            FINCR = (FINC/180.0d0)*pie    !orbital inclination in radians
            pup=360.0d0
            if(ism1.ge.1)pup=180.0d0+dphase
            sf2=dsin(fincr)**2
            thetatan=180.0d0*dacos(dsqrt((1.0d0-(reff1)**2)/sf2))/pie
c
            iloopp=0
            Nloopp=0
            Nloopp=idint(((pup-thetatan+dphase)-dphase)/dphase)
            pp=pup-thetatan+dphase+dphase
c
c            do 6666 pp=pup-thetatan+dphase,(0.0d0+dphase),-dphase
c
            do 6666 iloopp=Nloopp,1,-1
              pp=pp-dphase
              PHASER = (pp/180.0d0)*pie     !orbital phase in radians
c
              delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
              delta=bdist*dsqrt(delta)
              if(delta.gt.reff1+reff2)go to 6666
c
              tt1=dabs(phaser-2.0d0*pie*pconj)
              tt2=dabs(phaser-2.0d0*pie*(pconj+1.0d0))
              if(tt1.le.tt2)then
                diff1=tt1
              else
                diff1=tt2
              endif
              tt1=dabs(phaser-2.0d0*pie*pconj2)
              tt2=dabs(phaser-2.0d0*pie*(pconj2+1.0d0))
              if(tt1.le.tt2)then
                diff2=tt1
              else
                diff2=tt2
              endif              
              if(diff1.lt.diff2)go to 6666

              dummyphase=dmod(pp+180.0d0,360.0d0)
              call gethorizon(2,ialphmax2,ibetmax2,Nalph2,
     @          ibetlim2,dummyphase,finc,Q,pot2,omega2,x2,y2,z2,rad2,
     @          gradx2,grady2,gradz2,xend2,Nhoriz2,xhoriz2,yhoriz2,
     @          phiar2,iedgestar2,delphie2,bdist,mmdx2,xhmin2,xhmax2,
     @          yhmin2,yhmax2,tidephi,itide,phihor2,ecc,thetamis,phimis,
     @          tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @          tertOmega)
              call getalflim(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     %          pp,finc,Q,gradx1,grady1,gradz1,x1,y1,z1,
     $          Nhoriz2,xhoriz2,yhoriz2,bdist,mmdx1,ialfmin,
     @          ialfmax,tertincl,tertbdist,tertphase,tertQ,
     @          axisscale,isw30,isw7,tertOmega)
c
6666        continue
c
            pp=180.0d0
            dummyphase=dmod(pp+180.0d0,360.0d0)
            call gethorizon(2,ialphmax2,ibetmax2,Nalph2,
     @          ibetlim2,dummyphase,finc,Q,pot2,omega2,x2,y2,z2,rad2,
     @          gradx2,grady2,gradz2,xend2,Nhoriz2,xhoriz2,yhoriz2,
     @          phiar2,iedgestar2,delphie2,bdist,mmdx2,xhmin,xhmax,
     @          yhmin,yhmax,tidephi,itide,phihor2,ecc,thetamis,phimis,
     @          tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @          tertOmega)
            call getalflim(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     %          pp,finc,Q,gradx1,grady1,gradz1,x1,y1,z1,
     $          Nhoriz2,xhoriz2,yhoriz2,bdist,mmdx1,ialfmin,
     @          ialfmax,tertincl,tertbdist,tertphase,tertQ,
     @          axisscale,isw30,isw7,tertOmega)
c
            ialfmin=ialfmin-1
            ialfmax=ialfmax+1
c
c   Now we have to find the integrated brightness of the pixels on star
c   1 outside the range ialfmin,ialfmax
c
            if(idark1.le.0)call getrefvisib(ialphmax1,ibetmax1,Nalph1,
     @        ibetlim1,0.0d0,finc,gradx1,grady1,gradz1,visib1,
     @        projarray1,mmdx1)
c
            if(idark1.le.0)call setuptemp(1,ialphmax1,ibetmax1,Nalph1,
     @         ibetlim1,g1,Tpole1,Tgrav1,temp1,gpole1,mmdx1)
c
            if(iatm.eq.0)then
              do 1937 jj=1,8
c
                flux1=0.0d0
                if(idark1.le.0)then
                  rpole1=Rpol1(Nalph1/2)
c
                  www=wave(jj)
                  flimbx=dwavex(jj,1)
                  flimby=dwavey(jj,1)
                  flux1=0.0d0
                  call getBBlumcor(ialphmax1,ibetmax1,Nalph1,
     @              ibetlim1,www,visib1,projarray1,temp1,surf1,flimbx,
     @              flimby,ilaw,rinty1,flum1,flux1,mmdx1,
     @              ialfmin,ialfmax)
                endif
c
                rlatflux(jj)=flux1
 1937          continue
            endif
          endif  !if fast transit mode
c
c   UPDATE June 16, 2003
c
c   Add an EBOP mode.  If iecheck=9, then compute 'reference' fluxes
c   for star 1 and star 2.  Then at each phase, check the distance
c   between the two stellar centers.  If the distance is more than
c   the sum of the radii then skip the flux computation.
c
c   UPDATE April 24, 2006
c
c   If isw12=1, then compute analytic transits using Mandel and Agol.
c   Compute reference fluxes as in EBOP mode, then compute the ratio
c   of the transit given the separation between centers and the radius
c   ratio
c
          if((iecheck.eq.9).or.(isw12.ge.1))then
            if(idark1.le.0)call getrefvisib(ialphmax1,ibetmax1,Nalph1,
     @        ibetlim1,0.0d0,finc,gradx1,grady1,gradz1,visib1,
     @        projarray1,mmdx1)
c
            if(idark2.le.0)call getrefvisib(ialphmax2,ibetmax2,Nalph2,
     @        ibetlim2,180.0d0,finc,gradx2,grady2,gradz2,visib2,
     @        projarray2,mmdx2)
c
            if(idark1.le.0)call setuptemp(1,ialphmax1,ibetmax1,Nalph1,
     @         ibetlim1,g1,Tpole1,Tgrav1,temp1,gpole1,mmdx1)
            if((teff2.gt.0.0d0).and.(idark2.le.0))call setuptemp(2,
     @            ialphmax2,ibetmax2,Nalph2,ibetlim2,g2,Tpole2,Tgrav2,
     @            temp2,gpole2,mmdx2)
c
            if(iatm.eq.0)then
              do 937 jj=1,8
c
c   UPDATE MAY 28, 2010
c
c   Add corr1 and corr2 for analytic mode
c
                corr1(jj)=0.0d0
                corr2(jj)=0.0d0
                flux1=0.0d0
                if(idark1.le.0)then
                  rpole1=Rpol1(Nalph1/2)
c
                  if(jj.eq.1)then
                    call parms(1,
     &                Teff2,Q,finc,separ,period,reff1,reff2,
     $                vrot1,vrot2,gscale1,gscale2,omega1,
     &                omega2,bdist,ecc)
c
                    call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     $               gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,
     $               obsparm,bdist,ecc,argper,teff1)
c
                  endif
                  www=wave(jj)
                  flimbx=dwavex(jj,1)
                  flimby=dwavey(jj,1)
                  flux1=0.0d0
                  call getrefBBflux(ialphmax1,ibetmax1,Nalph1,
     @              ibetlim1,www,visib1,projarray1,temp1,surf1,flimbx,
     @              flimby,ilaw,rinty1,flum1,flux1,rldint1,separ,mmdx1)
                endif
c
                flux2=0.0d0
                if(idark2.le.0)then
c
                  rpole2=Rpol2(Nalph2/2)
c
                  if(jj.eq.1)then
                    call parms(1,Teff2,Q,finc,separ,period,reff1,reff2,
     %                vrot1,vrot2,
     @                gscale1,gscale2,omega1,omega2,bdist,ecc)
c
                    call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     %                gp1,gp2,vrot1,vrot2,
     @                gscale1,gscale2,omega1,omega2,obsparm,bdist,ecc,
     @                argper,teff1)
c 
                  endif
                  www=wave(jj)
                  flimbx=dwavex(jj,2)
                  flimby=dwavey(jj,2)
c
                  if(ilaw.gt.10)then
                    flimbx=dwavex(jj,1)
                    flimby=dwavey(jj,1)
                  endif

                  flux2=0.0d0
                  if(teff2.gt.0.0d0)call getrefBBflux(ialphmax2,
     &              ibetmax2,Nalph2,ibetlim2,www,visib2,
     @              projarray2,temp2,surf2,flimbx,flimby,ilaw,rinty2,
     @              flum2,flux2,rldint2,separ,mmdx2)
                endif
                refflux1(jj)=flux1
                refflux2(jj)=flux2
 937          continue
            endif
            if(iatm.ge.1)then
              fluxU1=0.0d0
              fluxU2=0.0d0
              fluxB1=0.0d0
              fluxB2=0.0d0
              fluxV1=0.0d0
              fluxV2=0.0d0
              fluxR1=0.0d0
              fluxR2=0.0d0
              fluxI1=0.0d0
              fluxI2=0.0d0
              fluxJ1=0.0d0
              fluxJ2=0.0d0
              fluxH1=0.0d0
              fluxH2=0.0d0
              fluxK1=0.0d0
              fluxK2=0.0d0
c
              if(idark1.le.0)then
                rpole1=Rpol1(Nalph1/2)
c
                call parms(1,Teff2,Q,finc,separ,period,reff1,reff2,
     @            vrot1,vrot2,
     @            gscale1,gscale2,omega1,omega2,bdist,ecc)
c
                call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     %             gp1,gp2,vrot1,vrot2,
     @             gscale1,gscale2,omega1,omega2,obsparm,bdist,ecc,
     @             argper,teff1)
c
                call getATMint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @            Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @            atmint7,atmint8,gscale1,darkint1,
     @            tpole1,gpole1,dwavex,dwavey,ilaw,iatm,1)
c
                call getrefATMflux(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @            visib1,projarray1,temp1,surf1,g1,rinty1,flum1,
     @            maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,atmint1,
     @            atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,
     @            atmint8,gscale1,fluxU1,fluxB1,fluxV1,fluxR1,fluxI1,
     @            fluxJ1,fluxH1,fluxK1,icnU,icnB,icnV,icnR,icnI,icnJ,
     @            icnH,icnK,iRVfilt,separ,mmdx1,dwavex,dwavey,ilaw,iatm,
     @            1)
c
c   UPDATE MAY 28, 2010
c
c   Add corr1 and corr2 for analytic mode
c
                corr1(1)=0.0d0
                corr2(1)=0.0d0
                corr1(2)=0.0d0
                corr2(2)=0.0d0
                corr1(3)=0.0d0
                corr2(3)=0.0d0
                corr1(4)=0.0d0
                corr2(4)=0.0d0
                corr1(5)=0.0d0
                corr2(5)=0.0d0
                corr1(6)=0.0d0
                corr2(6)=0.0d0
                corr1(7)=0.0d0
                corr2(7)=0.0d0
                corr1(8)=0.0d0
                corr2(8)=0.0d0
c
              endif
              if(idark2.le.0)then
                rpole2=Rpol2(Nalph2/2)
c
                call parms(1,Teff2,Q,finc,separ,period,reff1,reff2,
     @            vrot1,vrot2,gscale1,
     @            gscale2,omega1,omega2,bdist,ecc)
c
                call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     %            gp1,gp2,vrot1,vrot2,
     @            gscale1,gscale2,omega1,omega2,obsparm,bdist,ecc,
     @            argper,teff1)
c
                if(Teff2.gt.0.0d0)call getATMint(maxlines,maxmu,Nlines,
     &            atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,
     @            atmint5,atmint6,atmint7,atmint8,
     @            gscale2,darkint2,tpole2,gpole2,dwavex,dwavey,ilaw,
     @            iatm,2)
c
                if(teff2.gt.0.0d0)call getrefATMflux(ialphmax2,ibetmax2,
     &             Nalph2,ibetlim2,visib2,projarray2,temp2,surf2,g2,
     @             rinty2,flum2,maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @             Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @             atmint7,atmint8,gscale2,fluxU2,fluxB2,fluxV2,fluxR2,
     @             fluxI2,fluxJ2,fluxH2,fluxK2,icnU,icnB,icnV,icnR,icnI,
     @             icnJ,icnH,icnK,iRVfilt,separ,mmdx2,dwavex,dwavey,
     @             ilaw,iatm,2)
c
              endif
              refflux1(1)=fluxU1
              refflux2(1)=fluxU2
              refflux1(2)=fluxB1
              refflux2(2)=fluxB2
              refflux1(3)=fluxV1
              refflux2(3)=fluxV2
              refflux1(4)=fluxR1
              refflux2(4)=fluxR2
              refflux1(5)=fluxI1
              refflux2(5)=fluxI2
              refflux1(6)=fluxJ1
              refflux2(6)=fluxJ2
              refflux1(7)=fluxH1
              refflux2(7)=fluxH2
              refflux1(8)=fluxK1
              refflux2(8)=fluxK2
c
            endif
          endif
c
c
c   UPDATE OCTOBER 20, 2005
c
c   Add an "EBOP mode" where only the flux at even phases are computed.
c   Set the refflux=-99 and filter out the negative values later.
c
c
          if(iecheck.eq.5)then
            do 431 jjj=1,8
              refflux1(jjj)=-99.0d0
              refflux2(jjj)=-99.0d0
431         continue
          endif
c 
          ttiny=0.0d0
          if(ecc.le.0.0d0)ttiny=1.0d-6
c
c   UPDATE JULY 22, 2010
c
c   Add this block to get itime=2 working in eccentric mode.
c
          if((isw7.eq.2).and.(ecc.gt.0.0d0))then
            pstartout=360.0d0*(timearray(1)-T0)/period
            pstopout=360.0d0*(timearray(ntime)-T0)/period
            dphase=360.0d0*tstep/period
            ism1=0
          endif
c
          phaseout=0.0d0
          Nloopout=0
          Nloopout=idint((pstopout+ttiny-pstartout)/dphase)
          phaseout=pstartout-dphase
c
c          do 999 phaseout=pstartout,pstopout+ttiny,dphase          
c
          do 999 iloopout=1,Nloopout+1
            phaseout=phaseout+dphase

            if((icounttime.ge.1).and.(Ngap.ge.1))then
              do ijk=1,Ngap
                if((timearray(icounttime).gt.gaplow(ijk)).and.
     @              (timearray(icounttime).lt.gaphigh(ijk)))then
                  icounttime=icounttime+1
                  go to 999
                endif
              enddo
            endif

          if(ecc.gt.0.0d0)then
            ivrt=1
c
c   RVG BUG ALERT  April 19, 2001.
c
c   If the ism1 flag is set, then modify the start and stop phase
c   of the inner loop.  Also, define a variable called pstep.
c           
            if(ism1.eq.0)then
              em=phaseout*pie/180.0d0
c
              call getE(em,ecc,bigE)
c
c   Add these blocks to ensure that angles are within the set limits
c
11107         if(bigE.lt.0.0)then
                bigE=bigE+2.0d0*pie
                go to 11107
              endif
22207         if(bigE.gt.2.0d0*pie)then
                bigE=bigE-2.0d0*pie
                go to 22207
              endif
              rnu=2.0d0*datan(dsqrt((1.0d0+ecc)/(1.0d0-ecc))
     @          *dtan(bigE/2.0d0))
c
c   Add these blocks to ensure that angles are within the set limits
c
11105         if(rnu.lt.0.0)then
                rnu=rnu+2.0d0*pie
                go to 11105
              endif
11106         if(rnu.gt.2.0d0*pie)then
                rnu=rnu-2.0d0*pie
                go to 11106
              endif
              bdist=(1.0d0-ecc*dcos(bigE))
c
c   Use the dmod function for pstart and pstop.
c
              pstart=dmod(rnu*180.0d0/pie+argper+90.0d0,360.0d0)
              pstop=dmod(rnu*180.0d0/pie+argper+90.0d0,360.0d0)
              pstep=dphase
c
            endif !if isym = 0
c
            if(ism1.ge.1)then
              em=phaseout*pie/180.0d0
              call getE(em,ecc,bigE)
c
c   Add these blocks to ensure that angles are within the set limits
c
11108         if(bigE.lt.0.0)then
                bigE=bigE+2.0d0*pie
                go to 11108
              endif
22208         if(bigE.gt.2.0d0*pie)then
                bigE=bigE-2.0d0*pie
                go to 22208
              endif
              rnu=2.0d0*datan(dsqrt((1.0d0+ecc)/(1.0d0-ecc))
     @          *dtan(bigE/2.0d0))
c
c   Add these blocks to ensure that angles are within the set limits
c
11109         if(rnu.lt.0.0)then
                rnu=rnu+2.0d0*pie
                go to 11109
              endif
11110         if(rnu.gt.2.0d0*pie)then
                rnu=rnu-2.0d0*pie
                go to 11110
              endif
              bdist1=(1.0d0-ecc*dcos(bigE))
c
c   RVG BUG ALERT   April 19, 2001
c
c   Use the dmod function for pstart and pstop.
c
              pstart=dmod(rnu*180.0d0/pie+argper+90.0d0,360.0d0)
c
c   RVG BUG ALERT  April 19, 2001
c
c   Here is the other phase that gives the same binary separation
c
              emnew=-1.0d0*em
c
c   We need to do the periastron and apastron phases once.
c
              if(phaseout.eq.pstartout)emnew=em  
              if(phaseout.eq.pstopout)emnew=em  
              call getE(emnew,ecc,bigEnew)
c
c   RVG BUG ALERT   April 19, 2001
c
c   Add these blocks to ensure that angles are within the set limits
c
11111         if(bigEnew.lt.0.0)then
                bigEnew=bigEnew+2.0d0*pie
                go to 11111
              endif
22211         if(bigEnew.gt.2.0d0*pie)then
                bigEnew=bigEnew-2.0d0*pie
                go to 22211
              endif
              rnunew=2.0d0*datan(dsqrt((1.0d0+ecc)/(1.0d0-ecc))
     %           *dtan(bigEnew/2.0d0))
c
c   RVG BUG ALERT   April 19, 2001
c
c   Add these blocks to ensure that angles are within the set limits
c
11112         if(rnunew.lt.0.0)then
                rnunew=rnunew+2.0d0*pie
                go to 11112
              endif
11113         if(rnunew.gt.2.0d0*pie)then
                rnunew=rnunew-2.0d0*pie
                go to 11113
              endif
c
c   RVG BUG ALERT   April 19, 2001
c
c   Use the dmod function for pstart and pstop.
c
              pstop=dmod(rnunew*180.0d0/pie+argper+90.0d0,360.0d0)
              pstep=pstop-pstart
c
              if(pstep.eq.0.0d0)pstep=1.0d0
              bdist=bdist1
c
c   We need to do the periastron and apastron phases only once.
c
              if(phaseout.eq.pstartout)pstop=pstart
              if(phaseout.eq.pstopout)pstop=pstart
            endif ! if isym > 1
c
c   UPDATE September 11, 2001
c
c   Add the iverb flag to setupgeo
c
            iverb=0
c

            iskip1=0
            fincr=finc*pie/180.0d0
            phaser=pstart*pie/180.0d0
c
            thetamis=savethetamis
            phimis=savephimis-phase
c
            thetamis=thetamis*pie/180.0d0
            phimis=phimis*pie/180.0d0

            thetamis=0.0d0
            phimis=0.0d0

            delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
            delta=bdist*dsqrt(delta)
            if(delta.gt.(reff1*1.2d0+reff2*1.2d0))then
c
              iskip1=10
              if((isw30.ge.1).and.(isw7.ge.2))then
                if(iloopout.eq.1)then
                  if(itconj.eq.2)then
                    call getT0(tertincl,tertperiod,tertecc,tertarg,
     $                 tertT0,tertconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     $                 tertT0,tertconj)
                  endif
                endif
                tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
                tertphase=360.0d0*tertphase
                call tertnu(tertphase,tertecc,tertbdist,tertrnu)
                tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @              360.0d0)
                if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
                if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
                i3flag=0
                tertppp=dmod(tertphase,360.0d0)
                if(tertppp.lt.0.0d0)tertppp=tertppp+360.0d0
                if(tertppp.gt.360.0d0)tertppp=tertppp-360.0d0
                Nhoriz3=360
                call gethorizon3(Nhoriz3,xhoriz3,yhoriz3,reff3,
     @            axisscale,tertbdist,tertphase,tertincl,tertQ,
     @            tertOmega) 
                if((tertppp.ge.0.0d0).and.(tertppp.lt.
     @               90.0d0))i3flag=1
                if((tertppp.ge.270.0d0).and.(tertppp.le.
     @               360.0d0))i3flag=1

c
                xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                tOmrad=TertOmega*pie/180.0d0
                xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
                yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase,fincr,Q,1,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase,fincr,Q,1,bdist)+yyoff
                Nhoriz1=360
                call fakehorizon(Nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+yyoff
                Nhoriz2=360
                call fakehorizon(Nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
                ioverlap=-9999
                call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $              Nhoriz2,xhoriz2,yhoriz2,ioverlap)
                if((isw30.ge.1).and.(isw7.ge.2))then
                  call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  call overlaphoriz(Nhoriz2,xhoriz2,yhoriz2,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  if(ioverlap.lt.900)then
                    iskip1=10
                  else
                    iskip1=0
                  endif
                endif
              endif
            endif
c
            iskip2=0
            fincr=finc*pie/180.0d0
            phaser=pstop*pie/180.0d0
            delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
            delta=bdist*dsqrt(delta)
c
            if(delta.gt.(reff1*1.2d0+reff2*1.2d0))then
c
              iskip2=10
              if((isw30.ge.1).and.(isw7.ge.2))then
                if(itconj.eq.2)then
                  call getT0(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
                if(itconj.eq.1)then
                  call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
                tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
                tertphase=360.0d0*tertphase
                call tertnu(tertphase,tertecc,tertbdist,tertrnu)
                tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @              360.0d0)
                if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
                if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
                i3flag=0
                tertppp=dmod(tertphase,360.0d0)
                if(tertppp.lt.0.0d0)tertppp=tertppp+360.0d0
                if(tertppp.gt.360.0d0)tertppp=tertppp-360.0d0
                Nhoriz3=360
                call gethorizon3(Nhoriz3,xhoriz3,yhoriz3,reff3,
     @            axisscale,tertbdist,tertphase,tertincl,tertQ,
     @            tertOmega) 
                if((tertppp.ge.0.0d0).and.(tertppp.lt.
     @               90.0d0))i3flag=1
                if((tertppp.ge.270.0d0).and.(tertppp.le.
     @               360.0d0))i3flag=1
c
                xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                tOmrad=TertOmega*pie/180.0d0
                xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
                yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase,fincr,Q,1,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase,fincr,Q,1,bdist)+yyoff
                Nhoriz1=360
                call fakehorizon(Nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+yyoff
                Nhoriz2=360
                call fakehorizon(Nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
c
                ioverlap=-9999
                call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $              Nhoriz2,xhoriz2,yhoriz2,ioverlap)
                if((isw30.ge.1).and.(isw7.ge.2))then
                  call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  call overlaphoriz(Nhoriz2,xhoriz2,yhoriz2,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  if(ioverlap.lt.900)then
                    iskip2=10
                  else
                    iskip2=0
                  endif
                endif
              endif
            endif
c
c   Now, if idark1>0, then we can skip the phase where star 2 is in front
c   (e.g. phase 180).  Likewise, if idark2 > 0, then skip phases near 0.
c
            if(((phase.ge.0.0d0).and.(phase.le.90.0d0)).or.
     $           ((phase.gt.270.0d0).and.(phase.le.360.0d0)))then
              if(idark2.gt.0)iskip1=10
            endif
            if((phase.ge.90.0d0).and.(phase.le.270.0d0))then
              if(idark1.gt.0)iskip2=10
            endif
c            
c UPDATE OCTOBER 20, 2005
c
c Add iecheck=5.  In this case, compute only integer phases.
c
            fflag=-99.0d0
            ddum=phase
            if(ecc.gt.0.0d0)ddum=em*180.0d0/2.0d0/pie
            fdiff=(dabs(ddum*0.5d0-dble(dint(ddum*0.5d0))))
            if(fdiff.lt.0.5d0*dphase)fflag=99.0d0
c
            if((ecc.gt.0.0d0).and.(iecheck.ge.5).and.
     &            ((iskip1.eq.10).or.(iskip2.eq.10)))then    !was eq.9
              if(fflag.ge.90.0d0)then
                iskip1=0
                iskip2=0
                go to 621
              endif

              if((isw30.ge.1).and.(isw7.ge.2))then
                if(itconj.eq.2)then
                  call getT0(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
                if(itconj.eq.1)then
                  call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
                tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
                tertphase=360.0d0*tertphase
                call tertnu(tertphase,tertecc,tertbdist,tertrnu)
                tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @              360.0d0)
                if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
                if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
              endif
c
              icount=icount+1
              icounttime=icounttime+1
              phase=pstart
              dummyphase=phase+180.0d0
              if(iatm.eq.0)go to 938
              if(iatm.ge.1)go to 8938
            endif
c
c   UPDATE May 10, 2006
c
c   If we are in analytic mode, and the eccentricity is more than 0.0,
c   skip the setupgeo, etc. since it is not needed.
c
            if((isw12.gt.0).and.(ecc.gt.0.0d0))go to 33321
c
621         call setupgeo(1,ialphmax1,ibetmax1,Nalph1,Nbet1,ibetlim1,
     $       fill1,omega1,Q,finc,
     $       x1,y1,z1,
     %       surf1,rad1,gradx1,grady1,gradz1,g1,xend1,separ,
     %       Tgrav1,Teff1,reff1,Rl1,Tpole1,Rpol1,Regg1,SA1,pot1,gpole1,
     %       phiar1,isquare,iusepot,usepot1,ivrt,pervol1,fillper1,bdist,
     @       pots1,iverb,mmdx1,primmass,primK,primrad,ratrad,frac1,frac2,
     &       ecc,period,size1,sw5,tteff2,density,
     $       tidephi,itide,phistart1,thetamis,phimis)
            if(teff2.gt.0.0d0)then
              call setupgeo(2,ialphmax2,ibetmax2,Nalph2,Nbet2,ibetlim2,
     $          fill2,omega2,Q,finc,x2,y2,z2,surf2,rad2,gradx2,grady2,
     @          gradz2,g2,xend2,separ,Tgrav2,Teff2,reff2,Rl2,Tpole2,
     @          Rpol2,Regg2,SA2,pot2,gpole2,phiar2,isquare,iusepot,
     @          usepot2,ivrt,pervol2,fillper2,bdist,pots2,iverb,mmdx2,
     @          primmass,primK,primrad,ratrad,frac1,frac2,ecc,period,
     @          size1,sw5,tteff2,density,tidephi,itide,phistart2,
     @          thetamis,phimis)
            else
c
c   UPDATE June 14, 2002
c
c   Add ibetlim2 to the argument list of dummyvalues
c
              call dummyvalues(ialphmax2,ibetmax2,Nalph2,Nbet2,
     $          x2,y2,z2,surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,
     $          temp2,ibetlim2,mmdx2)
              Regg2=rocheradius(Q)
              reff2=Regg2
              overQ=1.0d0/Q
              call findL1(overQ,omega2,x0,1,bdist,tidephi,
     &          ecc,thetamis,phimis)
              Rl2=x0
            endif
          endif   !end if ecc.gt.0
c
          if(iidint.ge.1)call disksetup(Nthetamax,Nrmax,Ntheta,Nradius,
     %       betarim,rinner,router,Regg2,Rl2,separ,
     $       tdisk,xi,dtemp,dx,dy,dz,drad,
     $       tedge,xedge,yedge,zedge,redge,stepr,stepz,bdist,
     @       ivrt,reper,rsper)
c
c   Find the temperatures in the absence of reflection (heating).  The
c   modified temperatures do not depend on phase.
c  
c
          call setuptemp(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,g1,Tpole1,
     @       Tgrav1,temp1,gpole1,mmdx1)

          if(teff2.gt.0.0d0)call setuptemp(2,ialphmax2,ibetmax2,Nalph2,
     @       ibetlim2,g2,Tpole2,Tgrav2,temp2,gpole2,mmdx2)
c
c   May 3, 2001 
c
c   Initialize the ratios and copy the temperatures only if Nref>0
c
          if(Nref.ge.-1)then
            call copytemp(ialphmax1,ibetmax1,Nalph1,temp1,
     @          tempold1,mmdx1,ibetlim1)
            call copytemp(ialphmax2,ibetmax2,Nalph2,temp2,
     @          tempold2,mmdx2,ibetlim2)
c
c   Compute the reflection effect and find the modified temperatures. First
c   initialize the ratios...
c
            call initratio(ialphmax1,ibetmax1,
     %           Nalph1,Nbet1,Nalph2,Nbet2,ratio1,ratio2,
     *           coprat1,coprat2,ialphmax2,ibetmax2)
          endif
c
c   UPDATE March 25, 2002
c
c   I have added another routine called simplerefl, which is a much
c   more efficient routine when the stars are nearly point sources.
c   If Nref=0, call this routine and skip to statement 888.  If
c   Nref < 0, skip both.
c
c   If Teff2 < 0, then star 2 is a point source.  Hence we need only 1
c   iteration of the reflection effect.
c
c   Also, if there is no star 2, call simplerefl.
c
          if((Teff2.le.0.0d0).and.(Nref.gt.0))Nref=0
c
          if(Nref.lt.0)go to 888
          if(Nref.eq.0)then
            call simplerefl(ialphmax1,ibetmax1,Nalph1,ibetlim1,Nalph2,
     @        ibetlim2,x1,y1,z1,gradx1,grady1,gradz1,g1,x2,y2,z2,gradx2,
     @        grady2,gradz2,g2,temp1,temp2,dbolx,dboly,ilaw,alb1,alb2,
     @        teff1,teff2,Tgrav1,Tgrav2,rLx,iidint,redge,betarim,gpole1,
     @        gpole2,Tpole1,Tpole2,bdist,SA1,SA2,rad1,rad2,separ,mmdx1,
     &        mmdx2,ialphmax2,ibetmax2,isw25)
            call copytemp(ialphmax1,ibetmax1,Nalph1,temp1,
     @          toldspot1,mmdx1,ibetlim1)
            call copytemp(ialphmax2,ibetmax2,Nalph2,temp2,
     @          toldspot2,mmdx2,ibetlim2)
            go to 888
          endif
c
          do 8 jj=1,Nref
c
            call detailrefl(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @       Nalph2,ibetlim2,ratio1,ratio2,x1,y1,z1,gradx1,grady1,
     @       gradz1,g1,surf1,x2,y2,z2,gradx2,grady2,gradz2,g2,surf2,
     $       temp1,temp2,tempold1,tempold2,dbolx,dboly,ilaw,alb1,alb2,
     @       teff2,Tgrav1,Tgrav2,rLx,iidint,redge,betarim,gpole1,
     @       gpole2,Tpole1,Tpole2,coprat1,coprat2,bdist,mmdx1,mmdx2,
     @       ialphmax2,ibetmax2)
c
c   UPDATE DECEMBER 17, 2001
c
c   Add if(tdisk.gt.0.0)
c
c
c   UPDATE June 14, 2002
c
c   Comment out this subroutine call for now.
c
c            if(tdisk.gt.0.0d0)then
c              if((iidint.ge.1).and.(jj.eq.1))call diskrefl(ialphmax1,ibetmax1,
c     $         Nalph1,Nbet1,ibetlim1,Nalph2,Nbet2,ibetlim2,ratio1,ratio2,
c     $         x1,y1,z1,gradx1,grady1,gradz1,g1,surf1,
c     $         x2,y2,z2,gradx2,grady2,gradz2,g2,surf2,
c     $         temp1,temp2,tempold1,tempold2,dbolx,dboly,ilaw,alb1,alb2,teff1,
c     $         teff2,Tgrav1,Tgrav2,rLx,iidint,gpole1,gpole2,
c     %         Tpole1,Tpole2,coprat1,coprat2,Nthetamax,Nrmax,Ntheta,Nradius,
c     %         betarim,rinner,router,reff2,Rl2,separ,
c     $         tdisk,xi,dtemp,dx,dy,dz,drad,
c     $         tedge,xedge,yedge,zedge,redge,stepr,stepz,dratio,
c     %         reper,rsper,ialphmax2,ibetmax2)
c            endif
c
            call copytemp(ialphmax1,ibetmax1,Nalph1,temp1,
     @          toldspot1,mmdx1,ibetlim1)
            call copytemp(ialphmax2,ibetmax2,Nalph2,temp2,
     @          toldspot2,mmdx2,ibetlim2)
 8        continue
c
c   RVG BUG ALERT  May 8, 2001   
c
c   Add spots here, if any.
c
c   UPDATE March 25, 2002
c
c   Add a statement label 888 below.
c   
c   UPDATE March 26, 2002
c
c   Get rid of Nbet from the argument list of addstarspot.  Its value
c   is contained within ibetlim.
c
c   UPDATE December 9, 2008
c
c   Set the averages to zero first.
c
888      continue
          ave11=0.0d0
          ave12=0.0d0
          ave21=0.0d0
          ave22=0.0d0
          if(ispot1.gt.0)call addstarspot(1,ialphmax1,ibetmax1,
     $       Nalph1,ibetlim1,temp1,spot1parm,ave11,ave12,
     %       phiar1,mmdx1,ispotprof)
          if((ispot2.gt.0).and.(teff2.gt.0.0d0))call 
     %       addstarspot(2,ialphmax2,ibetmax2,
     $       Nalph2,ibetlim2,temp2,spot2parm,ave21,ave22,
     %       phiar2,mmdx2,ispotprof)
c
c   UPDATE DECEMBER 17, 2001
c
c   Add if(tdisk.gt.0.0)
c
c
c   UPDATE March 26, 2002
c
c   Remove betarim, separ, tdisk, xi, dx, dy, dz, drad, 
c   xedge, yedge, zedge, stepr, stepz, bdist, omega, phase
c   from the argument list of adddiskspot.
c
          ave1=0.0d0
          ave2=0.0d0
          if((ispotd.gt.0).and.(iidint.gt.0).and.(tdisk.gt.0.0d0))call
     %       adddiskspot(Nthetamax,Nrmax,Ntheta,Nradius,rinner,router,
     @       reff2,Rl2,dtemp,tedge,redge,ivrt,reper,rsper,spotdparm,
     @       ave1,ave2)
c
c
c   We can now compute interesting system parameters based in the input
c   numbers.
c
          rpole1=Rpol1(Nalph1/2)
          rpole2=Rpol2(Nalph2/2)
c
          call parms(1,Teff2,Q,finc,separ,period,reff1,reff2,
     @       vrot1,vrot2,gscale1,gscale2,
     @       omega1,omega2,bdist,ecc)
c
          call parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     @       gp1,gp2,vrot1,vrot2,gscale1,gscale2,
     @       omega1,omega2, obsparm,bdist,ecc,argper,teff1)
c
c   NEW BUG ALERT  July 13, 2001
c
c   Here is a new subroutine call.  The new subroutine is at the end.
c
c   UPDATE January 16, 2001
c
c   add pot1,pot2 to the end of the list
c
c   UPDATE March 26, 2002
c
c   Remove rpole1,rpole2,fill1,fill2 from the argument list.
c
c
c   UPDATE MAy 10, 2006
c
c   Here is the point to skip to if the orbit is eccentric and we
c   are in analytic mode.
c
33321       continue
c
          call lineparms1(Teff2,Q,finc,separ,period,reff1,reff2,vrot1,
     @       vrot2,omega1,omega2,bdist,ecc,SA3,ave11,ave12,ave21,ave22,
     @       ave1,ave2,parmstring,pot1,pot2,rdepth,tertQ,argper)
c
          if(isw30.gt.0)call planetparms(planetparm,Tref,Q,finc,
     @        separ,period,
     @        reff1,reff2,ecc,SA3,tertperiod,tertt0,tertecos,tertesin,
     @        tertincl,tertOmega,tertQ,itconj,tertconj,isw30,P2tconj,
     @        P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,P2ratrad,
     @        P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @        P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,
     @        P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,P5esin,
     @        P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,P6ecos,
     @        P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,P7T0,
     @        P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,P8tconj,
     @        P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,P8ratrad,
     @        argper,T0,Tconj,isw28)

c
c
c   Output the necessary information to make contour plots of the temperature
c   and gravity.
c
c
c   RVG BUC ALERT  June 12 2001
c
c   Add the ".and.idraw.ge.1" condition to the if-then block
c
c   UPDATE June 7, 2002
c
c   Add the x, y, and z coordinate arrays to the argument of writetempgrav
c
c   UPDATE March 4, 2010
c
c   Add the separ to the argument list
c
          if((ecc.eq.0.0d0).and.(idraw.ge.1))then
            call writetempgrav(ialphmax1,ibetmax1,Nalph1,Nbet1,ibetlim1,
     %           temp1,g1,gscale1,1,x1,y1,z1,mmdx1,phistart1,separ)
            if(teff2.gt.0.0d0)then
              call writetempgrav(ialphmax2,ibetmax2,Nalph2,Nbet2,
     @           ibetlim2,temp2,g2,gscale2,2,x2,y2,z2,mmdx2,phistart2,
     $           separ)
            endif
          endif
c
c   We have to make sure we have the correct light curve so we can compute
c   the radial velocity curve if necessary.  If icnRV1.ne.430
c   or if icnRV2.ne.430, then we need to set icn? temporarily to 1.
c
          if(iRVfilt.eq.1)iVsave=icnU
          if(iRVfilt.eq.2)iVsave=icnB
          if(iRVfilt.eq.3)iVsave=icnV
          if(iRVfilt.eq.4)iVsave=icnR
          if(iRVfilt.eq.5)iVsave=icnI
          if(iRVfilt.eq.6)iVsave=icnJ
          if(iRVfilt.eq.7)iVsave=icnH
          if(iRVfilt.eq.8)iVsave=icnK
c
c   UPDATE October 22, 2008
c
c   Always compute at the filter corresponding to iRVfilt
c

c          if((icnRV1.ne.430).or.(icnRV2.ne.430))then
            if(iRVfilt.eq.1)icnU=1
            if(iRVfilt.eq.2)icnB=1
            if(iRVfilt.eq.3)icnV=1
            if(iRVfilt.eq.4)icnR=1
            if(iRVfilt.eq.5)icnI=1
            if(iRVfilt.eq.6)icnJ=1
            if(iRVfilt.eq.7)icnH=1
            if(iRVfilt.eq.8)icnK=1
c          endif
c
c   Initialize the disk correction matrix
c
c   UPDATE September 25, 2008
c
c   Add the if statement to the correction statement.
c
c
          do 88 kk=1,8
            if(idcheck.gt.0)zdcorr(kk)=0.0d0
            darkint1(kk)=1.0d0
            darkint2(kk)=1.0d0
 88       continue
c
c   If we are using the atmosphere table, compute the DINT factors.
c
          if(iatm.ge.1)then
c
c
c
            call getATMint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     @        atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,
     @        atmint8,gscale1,darkint1,tpole1,
     @        gpole1,dwavex,dwavey,ilaw,iatm,1)
c
c
c   UPDATE JULY 15, 2011
c
c   Modify the third light so that the scaling comes out correct.
c
c
            do 889 kk=1,8
              if(ididscale3.eq.0)then
c                third(kk)=third(kk)*darkint1(kk)/pie
                ididscale3=999          
              endif
889         continue
            if(Teff2.gt.0.0d0)call getATMint(maxlines,maxmu,Nlines,
     &        atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,
     @        atmint5,atmint6,atmint7,atmint8,
     &        gscale2,darkint2,tpole2,gpole2,
     &        dwavex,dwavey,ilaw,iatm,2)
           endif
c
c   Loop over phases and turn the binary in space.
c
c   If ism1=1, then do only phases 0.0 to 180.0 and reflect the light curve
c   at the end.
c
          if(ionephase.ge.1)then
            pstart=onephase
            pstop=onephase
          endif
c         
          ipstep=0
          if((isw7.eq.2).and.(ecc.eq.0.0d0))then
            pstart=360.0d0*(timearray(1)-T0)/period
            pstop=360.0d0*(timearray(ntime)-T0)/period
            pstep=360.0d0*tstep/period
            ism1=0
          endif
c        
          Nloopin=0
          iloopin=0
          phasein=0.0d0  
          Nloopin=idint((pstop+ttiny-pstart)/pstep)
c
c          do 10 phasein=pstart,pstop+ttiny,pstep
c
          phasein=pstart-pstep
          do 10 iloopin=1,Nloopin+1
            phasein=phasein+pstep
c
            if((icount.ge.1).and.(Ngap.ge.1))then
              do ijk=1,Ngap
                if((timearray(icounttime).gt.gaplow(ijk)).and.
     @               (timearray(icounttime).lt.gaphigh(ijk)))then
                  icounttime=icounttime+1
                  goto 10
                endif
              enddo
            endif
c
            if(ecc.eq.0.0d0)iskip2=10
c
c
c   RVG BUG ALERT  April 19, 2001
c
c   Put in a flag for the case when ecc>0 and ism1>0 to let the program
c   know which phase is being done
c
            ipstep=ipstep+1
c
c   END BUG
c
            phase=dmod(phasein,360.0d0)
            if(phase.lt.0.0d0)phase=phase+360.0d0

            icount=icount+1
            icounttime=icounttime+1
c
            if((isw30.ge.1).and.(isw7.ge.2))then
              if(iloopin.eq.1)then
                if(itconj.eq.2)then
                  call getT0(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
                if(itconj.eq.1)then
                  call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @               tertT0,tertconj)
                endif
              endif
              tertphase=(timearray(icounttime)-tertt0)/tertperiod
              tertphase=360.0d0*tertphase
c
              call tertnu(tertphase,tertecc,tertbdist,tertrnu)
              tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @            360.0d0)
              if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
              if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
c
            endif
c
            if((ispot1.ge.1).and.(isw7.ge.2))then
              call copytemp(ialphmax1,ibetmax1,Nalph1,toldspot1,
     @           temp1,mmdx1,ibetlim1)
              call addmovespot(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @           temp1,spot1parm,ave11,ave12,omega1,phiar1,mmdx1,period,
     @           t0,timearray(icounttime))
            endif
          
            if((ispot2.ge.1).and.(isw7.ge.2).and.(teff2.gt.0.0d0))then
              call copytemp(ialphmax2,ibetmax2,Nalph2,toldspot2,
     @            temp2,mmdx2,ibetlim2)
              call addmovespot(ialphmax2,ibetmax2,Nalph2,ibetlim2,
     @            temp2,spot2parm,ave21,ave22,omega2,phiar2,mmdx2,
     @            period,t0,timearray(icounttime))
            endif
c
c   RVG BUG ALERT  April 19, 2001
c
c   Put as the argument to getextension  dmod(extphase,360.0d0), and modify
c   the phase according to the phase shifts.
c
            extphase=phase
            if((ecc.gt.0.0d0).or.(pshift.ne.0.0d0))then
              if((ecc.gt.0.0d0).and.(ism1.eq.0))emphase=180.0d0*em/pie
              if((ecc.gt.0.0d0).and.(ism1.gt.0))then
                if(ipstep.eq.1)emphase=180.0d0*em/pie
                if(ipstep.eq.2)emphase=180.0d0*emnew/pie
              endif
              tshift=pshift+eshift
              extphase=emphase+360.0d0*tshift
c
c   UPDATE September 10, 2001
c
c   Add the if-then clauses
c
              if(ikeep.eq.1)extphase=emphase+360.0d0*(tshift-pconj)
              if(ikeep.eq.2)extphase=emphase+360.0d0*(tshift-pconj2)
            endif
            call getextension(dmod(extphase,360.0d0),extension,isw7,
     @         icounttime)
            dummyphase=dmod(phase+180.0d0,360.0d0)  ! this is for star 2
c
c   Check the various toggle switches which tell the code whether to check
c   for eclipses.  For example, if points were eclipsed up until phase
c   15.0, then the code will not check again until phase=180-15.  It
c   will keep checking until phase=180+15 and not check again until
c   phase=360-15.
c
            pdiff1=dabs(phase-(360.0d0-togglephase))
            if(pdiff1.lt.0.00001d0)then
              if(iecheck.ge.1)idcheck=100
c              itoggle=-1
            endif
c
            iskip1=0
            iskip2=0             
            fincr=finc*pie/180.0d0
            phaser=phase*pie/180.0d0
            delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
            delta=bdist*dsqrt(delta)
            if(delta.gt.(reff1*1.2d0+reff2*1.2d0))then
c
              iskip1=10
              iskip2=10
              if((isw30.ge.1).and.(isw7.ge.2))then
                if(iloopin.eq.1)then
                  if(itconj.eq.2)then
                    call getT0(tertincl,tertperiod,tertecc,tertarg,
     @                 tertT0,tertconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @                 tertT0,tertconj)
                  endif
                endif
                tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
                tertphase=360.0d0*tertphase
                call tertnu(tertphase,tertecc,tertbdist,tertrnu)
c
                tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @              360.0d0)
                if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
                if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
                i3flag=0
                tertppp=dmod(tertphase,360.0d0)
                if(tertppp.lt.0.0d0)tertppp=tertppp+360.0d0
                if(tertppp.gt.360.0d0)tertppp=tertppp-360.0d0
                Nhoriz3=360
                call gethorizon3(Nhoriz3,xhoriz3,yhoriz3,reff3,
     @            axisscale,tertbdist,tertphase,tertincl,tertQ,
     @            tertOmega) 
c
                if((tertppp.ge.0.0d0).and.(tertppp.lt.
     @               90.0d0))i3flag=1
                if((tertppp.ge.270.0d0).and.(tertppp.le.
     @               360.0d0))i3flag=1
c
                xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                tOmrad=TertOmega*pie/180.0d0
                xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
                yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase,fincr,Q,1,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase,fincr,Q,1,bdist)+yyoff
                Nhoriz1=360
                call fakehorizon(Nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+xxoff    
                yp=ytran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+yyoff
                Nhoriz2=360
                call fakehorizon(Nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
c
                ioverlap=-9999
                call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $              Nhoriz2,xhoriz2,yhoriz2,ioverlap)
                if((isw30.ge.1).and.(isw7.ge.2))then
                  call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  call overlaphoriz(Nhoriz2,xhoriz2,yhoriz2,
     $               Nhoriz3,xhoriz3,yhoriz3,ioverlap)
                  if(ioverlap.lt.900)then
                    iskip1=10
                    iskip2=10
                  else 
                    iskip1=0
                    iskip2=0
                  endif
                endif
              endif
            endif
c
c            if(delta.gt.(reff1*1.2d0+reff2*1.2d0))then    ! was 1.02
c              iskip1=10
c              iskip2=10
c             endif
c
c   Now, if idark1>0, then we can skip the phase where star 2 is in front
c   (e.g. phase 180).  Likewise, if idark2 > 0, then skip phases near 0.
c
            if(((phase.ge.0.0d0).and.(phase.lt.90.0d0)).or.
     $          ((phase.gt.270.0d0).and.(phase.le.360.0d0)))then
              if(idark2.gt.0)iskip1=10
            endif
c
            if((phase.ge.90.0d0).and.(phase.le.270.0d0))then
              if(idark1.gt.0)iskip2=10
            endif
c
c    Check for analytic mode
c
            if(isw12.ge.1)then    !was eq.9
              phaser=phase*pie/180.0d0
              delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
              delta=bdist*dsqrt(delta)
              call analyticg(isw12,ilaw,dwavex,dwavey,delta,reff1,
     @              ratrad,refflux1,refflux2,phaser,pconj,pconj2,
     @              gimvel,fincr,vrot1,omega1,period,separ,Q,ecc,
     @              bigI,bigbeta,Neclipse1,1,corr1,corr2,mandel,0,
     @              0)
c
              if(iatm.eq.0)go to 938
              if(iatm.ge.1)go to 8938
            endif
c
c   UPDATE OCTOBER 20, 2005
c
c   change to ge.5 (if iecheck=5, then compute the integer phases)
c
            fflag=-99.0d0
            ddum=phase
            if(ecc.gt.0.0d0)ddum=em*180.0d0/2.0d0/pie
            fdiff=(dabs(ddum*0.5d0-dble(dint(ddum*0.5d0))))
            if(fdiff.lt.0.5d0*dphase)fflag=99.0d0
            if((iecheck.ge.5).and.(iskip1.eq.10))then
              if(fflag.ge.90.0d0)then
                iskip1=0
                iskip2=0
                go to 821
              endif
              if(iatm.eq.0)go to 938
              if(iatm.ge.1)go to 8938
            endif
821         call gethorizon(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     %        phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,gradx1,grady1,
     @        gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,phiar1,iedgestar1,
     @        delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,yhmax1,tidephi,
     @        itide,phihor1,ecc,thetamis,phimis,tertincl,tertbdist,
     @        tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
c   
c
            if((isw30.ge.1).and.(isw7.ge.2))then
              i3flag=0
              tertppp=dmod(tertphase,360.0d0)
              if(tertppp.lt.0.0d0)tertppp=tertppp+360.0d0
              if(tertppp.gt.360.0d0)tertppp=tertppp-360.0d0
              Nhoriz3=360
              call gethorizon3(Nhoriz3,xhoriz3,yhoriz3,reff3,axisscale,
     @             tertbdist,tertphase,tertincl,tertQ,tertOmega) 
                if((tertppp.ge.0.0d0).and.(tertppp.lt.
     @             90.0d0))i3flag=1
                if((tertppp.ge.270.0d0).and.(tertppp.le.
     @             360.0d0))i3flag=1
            endif
c
            if(teff2.gt.0.0d0)then
              call gethorizon(2,ialphmax2,ibetmax2,Nalph2,
     @            ibetlim2,dummyphase,finc,Q,pot2,omega2,x2,y2,z2,rad2,
     @            gradx2,grady2,gradz2,xend2,Nhoriz2,xhoriz2,yhoriz2,
     @            phiar2,iedgestar2,delphie2,bdist,mmdx2,xhmin2,xhmax2,
     @            yhmin2,yhmax2,tidephi,itide,phihor2,ecc,thetamis,
     @            phimis,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
              if(iidint.ge.1)call gettophorizon(2,
     %            ialphmax2,ibetmax2,Nalph2,ibetlim2,dummyphase,
     @            finc,Q,x2,y2,z2,gradx2,grady2,gradz2,
     @            Ntop2,xtop2horiz,ytop2horiz,
     @            bdist,mmdx2,tertincl,tertbdist,tertphase,
     @            tertQ,axisscale,isw30,isw7,tertOmega)
            else
              call dummyhoriz(ibetmax2,Nbet2,Nhoriz2,xhoriz2,yhoriz2,
     &            Ntop2,xtop2horiz,ytop2horiz)
            endif
c
c    UPDATE May 26, 2004
c
c    If iecheck=9, check to see if the horizon of star 1 overlaps
c    with the horizon of star 2.  If so, then jump to the escape point.
c    ioverlap=999 means there is overlap
c
            ioverlap=-999
            ioverlap1=-999
            ioverlap2=-999
            call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $            Nhoriz2,xhoriz2,yhoriz2,ioverlap)
            if((isw30.ge.1).and.(isw7.ge.2))then
              call overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $             Nhoriz3,xhoriz3,yhoriz3,ioverlap1)
              call overlaphoriz(Nhoriz2,xhoriz2,yhoriz2,
     $             Nhoriz3,xhoriz3,yhoriz3,ioverlap2)
            endif
            if(iecheck.eq.9)then
              if(ioverlap.lt.900)then
                iskip1=10
                iskip2=10
                if(iatm.eq.0)go to 938
                if(iatm.ge.1)go to 8938
              endif
              if(ioverlap1.lt.900)then
                iskip1=10
                iskip2=10
                if(iatm.eq.0)go to 938
                if(iatm.ge.1)go to 8938
              endif
              if(ioverlap2.lt.900)then
                iskip1=10
                iskip2=10
                if(iatm.eq.0)go to 938
                if(iatm.ge.1)go to 8938
              endif
            endif
c
c   UPDATE September 10, 2001
c
c   If Teff < 0 check to see if the center of star 2 is eclipsed.
c
            if(Teff2.le.0.0d0)then
              pppp=dmod(phase,360.0d0)
              if(((pppp.gt.-90.0d0).and.(pppp.lt.90.0d0)).or.
     %           ((pppp.gt.270.0d0).and.(pppp.le.450.0d0)))then
                call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @            phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
              else
                ixecl=-100
              endif
              xecx(icount)=phase !dmod(phase+360.0d0*(pconj2),360.0d0)
              xecy(icount)=dble(ixecl)
            endif
c
            Ndhoriz=0
            Ndtop=0
            
            if(iidint.ge.1)call getdiskhoriz(Nthetamax,Ntheta,
     @        Q,phase,finc,xedge,yedge,zedge,Ndhoriz,dxhoriz,
     @        dyhoriz,Ndtop,dtopx,dtopy,bdist,tertincl,tertbdist,
     @        tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
c   Check the visibilities of grid elements.  Note that horizon 2 goes
c   in the argument list for star 1, and vice-versa.
c           
c   UPDATE JULY 2, 2004
c
c   Add the variable jdum to the argument list of get visib.
c
c           
c   UPDATE JULY 4, 2004
c
c   Add the variable MonteCarlo to the argument list of get visib.
c
            call getvisib(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     &        phase,finc,Q,pot1,omega1,gradx1,grady1,gradz1,x1,y1,z1,
     %        xend1,visib1,Nhoriz2,xhoriz2,yhoriz2,iidint,Ndhoriz,
     @        dxhoriz,dyhoriz,Ndtop,dtopx,dtopy,Nsky1,xsky1,ysky1,
     @        projarray1,iecheck,Neclipse1,phiar1,rad1,delphi1,
     @        iedgehor1,bdist,mmdx1,MonteCarlo,isw13,ialfmin,
     @        ialfmax,xhmin2,xhmax2,yhmin2,yhmax2,tidephi,itide,
     @        phistart1,ecc,thetamis,phimis,Nhoriz3,
     @        xhoriz3,yhoriz3,i3flag,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale,isw30,isw7,tertOmega)
c
c
            Neclipse2=0
            if(teff2.gt.0.0d0)call getvisib(2,ialphmax2,ibetmax2,Nalph2,
     @        ibetlim2,dummyphase,finc,Q,pot2,omega2,gradx2,
     @        grady2,gradz2,x2,y2,z2,xend2,visib2,Nhoriz1,xhoriz1,
     @        yhoriz1,iidint,Ndhoriz,dxhoriz,dyhoriz,Ndtop,dtopx,dtopy,
     $        Nsky2,xsky2,ysky2,projarray2,iecheck,Neclipse2,phiar2,
     @        rad2,delphi2,iedgehor2,bdist,mmdx2,MonteCarlo,
     @        isw13,ialfmin,ialfmax,xhmin1,xhmax1,yhmin1,yhmax1,tidephi,
     @        itide,phistart2,ecc,thetamis,phimis,
     @        Nhoriz3,xhoriz3,yhoriz3,i3flag,tertincl,tertbdist,
     @        tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
c 
c
            Nsky3=0
            Neclipse3=0
            if((ioverlap1.gt.10).or.(ioverlap2.gt.10))then
              if(isw30.gt.0)call getvisib3(3,ialphmax3,ibetmax3,Nalph3,
     @          ibetlim3,
     %          phase,finc,Q,psi0,1.0d0,gradx3,grady3,gradz3,x3,y3,
     @          z3,visib3,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,
     @          xhoriz2,yhoriz2,Nsky3,xsky3,ysky3,
     @          projarray3,iecheck,Neclipse3,phiar3,rad3,delphi3,
     @          mmdx3,0,phistart3,thetamis,phimis,
     @          i3flag,iedgehor3,
     @          tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @          tertOmega)
            endif
c
            if(iidint.ge.1)call diskvisib(Nrmax,Nthetamax,Nradius,Ntheta,
     @        phase,finc,Q,betarim,dx,dy,dz,xedge,yedge,zedge,diskproj,
     @        edgeproj,dvisib,evisib,Nskydisk,xskydisk,yskydisk,
     @        zskydisk,Nskyedge,xskyedge,yskyedge,Ntop2,xtop2horiz,
     @        ytop2horiz,Nhoriz1,xhoriz1,yhoriz1,Ndtop,dtopx,dtopy,
     @        iecheck,Neclipsed,bdist,tertincl,tertbdist,tertphase,
     @        tertQ,axisscale,isw30,isw7,tertOmega)
c
c   If we are in blackbody mode, we need to
c   loop over filters and find the fluxes.   Otherwise, we can call
c   the atmosphere routines a single time and get the fluxes for the
c   8 filters all at once.
c
            if(iatm.le.0)then
              do 9 jj=1,8
                www=wave(jj)
                flimbx=dwavex(jj,1)
                flimby=dwavey(jj,1)
                flux1=0.0d0
                if(idark1.le.0)then
                  if(isimp.eq.0)then
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
c   UPDATE JULY 4, 2004
c
c   Add MonteCarlo to the argument list
c
                    fluxlat=rlatflux(jj)
                    call getBBflux(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     $               www,visib1,projarray1,temp1,surf1,flimbx,flimby,ilaw,
     %               rinty1,flum1,flux1,delphi1,delphie1,
     @               iedgestar1,iedgehor1,rldint1,separ,mmdx1,MonteCarlo,
     $               isw13,ialfmin,ialfmax,fluxlat,1,phiar1,phihor1)
c
                    flux3=flux3keep(jj)
                    if((Neclipse3.gt.0).and.(isw30.gt.0))call 
     @                getBBflux(ialphmax3,ibetmax3,
     @                Nalph3,ibetlim3,www,visib3,projarray3,temp3,surf3,
     $                flimbx,flimby,ilaw,rinty3,flum3,flux3,delphi3,
     @                delphie3,iedgestar3,iedgehor3,rldint3,separ,mmdx3,
     @                MonteCarlo,isw13,ialfmin,ialfmax,fluxlat,1,phiar3,
     @                phihor3)
c
c
c            if(isw30.gt.0)call getvisib3(3,ialphmax3,ibetmax3,Nalph3,ibetlim3,
c     %      phase,finc,Q,psi0,1.0d0,gradx3,grady3,gradz3,x3,y3,
c     @      z3,visib3,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,
c     @      xhoriz2,yhoriz2,Nsky3,xsky3,ysky3,
c     @      projarray3,iecheck,Neclipse3,phiar3,rad3,delphi3,
c     @      mmdx3,0,phistart3,thetamis,phimis,
c     @      i3flag,iedgehor3,
c     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
c     @      tertOmega)
c


c                    write(*,*)flum1,flux1
c                  else
c
c  UPDATE March 26, 2002
c
c  Get rid of the variables phiar, jj, istar from the argument list
c  of getBBsimp.
c
c                    call getBBsimp(ialphmax1,ibetmax1,Nalph1,Nbet1,ibetlim1,
c     $                www,visib1,projarray1,temp1,surf1,flimbx,flimby,
c     &                ilaw,rinty1,flum1,flux1,delphi1,delphie1,
c     &                iedgestar1,iedgehor1,rldint1,isimp,separ,mmdx1)
                  endif
                endif
c
c   UPDATE May 24, 2002
c
c   Here is a new subroutine call.
c
c
                if(idraw.eq.1)then
                  if(jj.eq.iRVfilt)call rotkern(ialphmax1,ibetmax1,
     $              Nalph1,ibetlim1,
     &              1,omega1,phase,finc,
     %              Q,flum1,x1,y1,flux1,separ,period,gamma,
     $              ecc,argrad,visib1,extension,mmdx1)
                endif
c
                call getvel(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     $              1,omega1,phase,finc,
     %              Q,flum1,x1,y1,flux1,separ,period,gamma,vel1,delvel1,
     $              rldint1,ecc,argrad,mmdx1,isw13,ialfmin,ialfmax,
     %              bigI,bigbeta,z1)
c
                if(ilaw.gt.10)then
                  flimbx=dwavex(jj,1)
                  flimby=dwavey(jj,1)
                endif
                flux2=0.0d0
                if(idark2.le.0)then
                  if(teff2.gt.0.0d0)then
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
c   UPDATE JULY 4, 2004
c
c   Add MonteCarlo to the argument list.
c
                    if(isimp.eq.0)then
                      fluxlat=0.0d0
                      call getBBflux(ialphmax2,ibetmax2,Nalph2,
     $                ibetlim2,www,visib2,projarray2,temp2,
     &                surf2,flimbx,flimby,ilaw,
     &                rinty2,flum2,flux2,delphi2,delphie2,
     @                iedgestar2,iedgehor2,rldint2,separ,mmdx2,MonteCarlo,
     &                isw13,ialfmin,ialfmax,fluxlat,2,phiar2,phihor2)
c                    else
c
c  UPDATE March 26, 2002
c
c  Get rid of the variables phiar, jj, istar from the argument list
c  of getBBsimp.
c
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
c                      call getBBsimp(ialphmax2,ibetmax2,Nalph2,Nbet2,
c     $                  ibetlim2,
c     $                  www,visib2,projarray2,temp2,surf2,flimbx,flimby,
c     &                  ilaw,rinty2,flum2,flux2,delphi2,delphie2,
c     &                  iedgestar2,iedgehor2,rldint2,isimp,separ,mmdx2)
                    endif
                  endif
                endif
c
c  UPDATE August 16, 2001
c
c  Remove the if clause.  If there is no star 2 (as in an X-ray
c  binary, then the sine curve will still be computed.
c
c                if(teff2.gt.0.0d0)
c
                call getvel(ialphmax2,ibetmax2,Nalph2,
     &              ibetlim2,2,omega2,dummyphase,
     %              finc,Q,flum2,x2,y2,flux2,separ,period,gamma,vel2,
     @              delvel2,
     %              rldint2,ecc,argrad+pie,mmdx2,
     @              isw13,ialfmin,ialfmax,bigI,bigbeta,z2)
c
c
c   UPDATE May 24, 2002
c
c   Here is a new subroutine call.
c
c
                if(idraw.eq.1)then
                  if(jj.eq.iRVfilt)call rotkern(ialphmax2,ibetmax2,
     $              Nalph2,ibetlim2,
     &              2,omega2,phase,finc,
     %              Q,flum2,x2,y2,flux2,separ,period,gamma,
     $              ecc,argrad,visib2,extension,mmdx2)
                endif
c
                dflux=0.0d0
c
c   UPDATE December 17, 2001
c
c   If tdisk is less than 0, and iidint is more than 1, then
c   compute the disk geometry and eclipses, but ignore its flux.
c
                if(tdisk.gt.0.0d0)then
                  if(idcheck.ge.1)then
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
                    if(iidint.ge.1)call getdiskBBflux(Nrmax,Nthetamax,
     @               Nradius,Ntheta,diskproj,edgeproj,dvisib,evisib,
     $               dtemp,tedge,drad,
     $               dinty,einty,stepr,stepz,www,jj,ilaw,dflux,separ)
c
                    zdcorr(jj)=dflux
                  else
                     dflux=zdcorr(jj)
                  endif
                else
                  dflux=0.0d0
                endif
c
c   UPDATE OCTOBER 20, 2005
c
c   Change to .ge.5
c
c
 938            if((iecheck.ge.5).or.(isw12.ge.1))then
                  if((
     &               ((ecc.eq.0.0d0).and.(iskip1.eq.10).
     @               and.(iskip2.eq.10)).or.
     &               ((ecc.gt.0.0d0).and.((iskip1.eq.10).or.
     @               (iskip2.eq.10)))) .or.(isw12.ge.1))then 
                     do 9938 ll=1,8
c
c   Add Doppler boosting
c
                       call getrefvel(1,phase,finc,
     %                    Q,separ,period,gamma,vel1,ecc,argrad,isw12,
     @                     gimvel,iRVfilt)
                       call getrefvel(2,dummyphase,finc,
     %                    Q,separ,period,gamma,vel2,ecc,argrad+pie,
     @                    isw12,gimvel,iRVfilt)
c
                        dop1=(vel1-gamma)/2.99792458d5
                        dop2=(vel2-gamma)/2.99792458d5
                        
                        if(ll.eq.iRVfilt)then
                          refflux1(ll)=refflux1(ll)*(1.0d0-beam1*dop1)
                          refflux2(ll)=refflux2(ll)*(1.0d0-beam2*dop2)
                        endif

                       if(ll.eq.1)ymodU(icount)=refflux1(1)+refflux2(1)
     @                   +corr1(1)+corr2(1)!+dflux
                       if(ll.eq.2)ymodB(icount)=refflux1(2)+refflux2(2)
     @                   +corr1(2)+corr2(2)!+dflux
                       if(ll.eq.3)ymodV(icount)=refflux1(3)+refflux2(3)
     @                   +corr1(3)+corr2(3)!+dflux
                       if(ll.eq.4)ymodR(icount)=refflux1(4)+refflux2(4)
     @                   +corr1(4)+corr2(4)!+dflux
                       if(ll.eq.5)ymodI(icount)=refflux1(5)+refflux2(5)
     @                   +corr1(5)+corr2(5)!+dflux
                       if(ll.eq.6)ymodJ(icount)=refflux1(6)+refflux2(6)
     @                   +corr1(6)+corr2(6)!+dflux
                       if(ll.eq.7)ymodH(icount)=refflux1(7)+refflux2(7)
     @                   +corr1(7)+corr2(7)!+dflux
                       if(ll.eq.8)ymodK(icount)=refflux1(8)+refflux2(8)
     @                   +corr1(8)+corr2(8)!+dflux
                       yeclipse(icount)=dble(Neclipse1)
                       RV1(icount)=vel1
                       RV2(icount)=vel2
                       if(ll.eq.iRVfilt)then
                         ymods1(icount)=refflux1(ll)
                         ymods2(icount)=refflux2(ll)
                         drV1(icount)=gimvel(ll)
                       endif
c
c   UPDATE January 12, 2009
c
c   make fracs fracs1, fracs2, fracs3, ... fracs8
c
                       if(ll.eq.1)then
                         fracs1(icount,1)=refflux1(ll)
                         fracs1(icount,2)=refflux2(ll)
                         fracs1(icount,3)=dflux
                         fracs1(icount,4)=corr1(1)+corr2(1)
                       endif
                       if(ll.eq.2)then
                         fracs2(icount,1)=refflux1(ll)
                         fracs2(icount,2)=refflux2(ll)
                         fracs2(icount,3)=dflux
                         fracs2(icount,4)=corr1(2)+corr2(2)
                       endif
                       if(ll.eq.3)then
                         fracs3(icount,1)=refflux1(ll)
                         fracs3(icount,2)=refflux2(ll)
                         fracs3(icount,3)=dflux
                         fracs3(icount,4)=corr1(3)+corr2(3)
                       endif
                       if(ll.eq.4)then
                         fracs4(icount,1)=refflux1(ll)
                         fracs4(icount,2)=refflux2(ll)
                         fracs4(icount,3)=dflux
                         fracs4(icount,4)=corr1(4)+corr2(4)
                       endif
                       if(ll.eq.5)then
                         fracs5(icount,1)=refflux1(ll)
                         fracs5(icount,2)=refflux2(ll)
                         fracs5(icount,3)=dflux
                         fracs5(icount,4)=corr1(5)+corr2(5)
                       endif
                       if(ll.eq.6)then
                         fracs6(icount,1)=refflux1(ll)
                         fracs6(icount,2)=refflux2(ll)
                         fracs6(icount,3)=dflux
                         fracs6(icount,4)=corr1(6)+corr2(6)
                       endif
                       if(ll.eq.7)then
                         fracs7(icount,1)=refflux1(ll)
                         fracs7(icount,2)=refflux2(ll)
                         fracs7(icount,3)=dflux
                         fracs7(icount,4)=corr1(7)+corr2(7)
                       endif
                       if(ll.eq.8)then
                         fracs8(icount,1)=refflux1(ll)
                         fracs8(icount,2)=refflux2(ll)
                         fracs8(icount,3)=dflux
                         fracs8(icount,4)=corr1(8)+corr2(8)
                       endif
c

 9938                continue
                     if(ecc.eq.0.0d0)go to 9939
                     if(ecc.gt.0.0d0)go to 9939
                  endif
                endif
                dop1=(vel1-gamma)/2.99792458d5
                dop2=(vel2-gamma)/2.99792458d5
                if(jj.eq.iRVfilt)then
c                  write(*,*)flux1,1.0d0-beam1*dop1
                  flux1=flux1*(1.0d0-beam1*dop1)
                  flux2=flux2*(1.0d0-beam2*dop2)
                endif

                if(jj.eq.1)ymodU(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.2)ymodB(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.3)ymodV(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.4)ymodR(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.5)ymodI(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.6)ymodJ(icount)=flux1+flux2+dflux+flux3           
                if(jj.eq.7)ymodH(icount)=flux1+flux2+dflux+flux3
                if(jj.eq.8)ymodK(icount)=flux1+flux2+dflux+flux3
                yeclipse(icount)=dble(Neclipse1)
c
                if(jj.eq.1)then
                  fracs1(icount,1)=flux1
                  fracs1(icount,2)=flux2
                  fracs1(icount,3)=dflux
                  fracs1(icount,4)=flux3
                endif
                if(jj.eq.2)then
                  fracs2(icount,1)=flux1
                  fracs2(icount,2)=flux2
                  fracs2(icount,3)=dflux
                  fracs2(icount,4)=flux3
                endif
                if(jj.eq.3)then
                  fracs3(icount,1)=flux1
                  fracs3(icount,2)=flux2
                  fracs3(icount,3)=dflux
                  fracs3(icount,4)=flux3
                endif
                if(jj.eq.4)then
                  fracs4(icount,1)=flux1
                  fracs4(icount,2)=flux2
                  fracs4(icount,3)=dflux
                  fracs4(icount,4)=flux3
                endif
                if(jj.eq.5)then
                  fracs5(icount,1)=flux1
                  fracs5(icount,2)=flux2
                  fracs5(icount,3)=dflux
                  fracs5(icount,4)=flux3
                endif
                if(jj.eq.6)then
                  fracs6(icount,1)=flux1
                  fracs6(icount,2)=flux2
                  fracs6(icount,3)=dflux
                  fracs6(icount,4)=flux3
                endif
                if(jj.eq.7)then
                  fracs7(icount,1)=flux1
                  fracs7(icount,2)=flux2
                  fracs7(icount,3)=dflux
                  fracs7(icount,4)=flux3
                endif
                if(jj.eq.8)then
                  fracs8(icount,1)=flux1
                  fracs8(icount,2)=flux2
                  fracs8(icount,3)=dflux
                  fracs8(icount,4)=flux3
                endif

                if(jj.eq.iRVfilt)then
c                  write(*,*)rldint1
                  ymods1(icount)=flux1
                  ymods2(icount)=flux2
                  ymodd(icount)=dflux
                  RV1(icount)=vel1
                  RV2(icount)=vel2
                  dRV1(icount)=delvel1
                  dRV2(icount)=delvel2
                  fluxV1=flux1
                  fluxV2=flux2
                  call copyinty(ialphmax1,ibetmax1,Nalph1,
     $              Nalph2,rinty1,saveinty1,rinty2,saveinty2,mmdx1,
     &              mmdx2,ibetlim1,ibetlim2,ialphmax2,ibetmax2)
                  if(isw30.gt.0)call copyinty3(ialphmax3,ibetmax3,
     @              Nalph3,ibetlim3,mmdx3,rinty3,saveinty3)
                  if(iidint.ge.1)call copydiskinty(Nrmax,Nthetamax,Nradius,
     %              Ntheta,dinty,savedinty,einty,saveeinty)
c
                endif
 9            continue
            endif
c
c   Do the same block for iatm > 0
c
            if(iatm.ge.1)then
c
c   UPDATE November 7, 2008
c
c   zero out the disk fluxes
c
              dfluxU=0.0d0
              dfluxB=0.0d0
              dfluxV=0.0d0
              dfluxR=0.0d0
              dfluxI=0.0d0
              dfluxJ=0.0d0
              dfluxH=0.0d0
              dfluxK=0.0d0

              jj=1
              www=wave(jj)
              flimbx=dwavex(jj,1)
              flimby=dwavey(jj,1)
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
c   UPDATE JULY 4, 2004
c
c   Add MonteCarlo to the argument list.
c
              if(idark1.le.0)then
                call getATMflux(ialphmax1,ibetmax1,Nalph1,
     @             ibetlim1,visib1,projarray1,temp1,surf1,g1,rinty1,
     @             flum1,maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &             atmint1,atmint2,atmint3,atmint4,atmint5,
     $             atmint6,atmint7,atmint8,gscale1,
     &             fluxU1,fluxB1,fluxV1,fluxR1,fluxI1,fluxJ1,fluxH1,
     @             fluxK1,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     @             iRVfilt,delphi1,delphie1,iedgestar1,iedgehor1,
     @             separ,mmdx1,MonteCarlo,dwavex,dwavey,ilaw,
     @             iatm,1,darkint1)
c
                if(iRVfilt.eq.1)flux1=fluxU1
                if(iRVfilt.eq.2)flux1=fluxB1
c
c                fluxB1=fluxB1/darkint1(2)
                if(iRVfilt.eq.3)flux1=fluxV1
c                fluxV1=fluxV1/darkint1(3)
                if(iRVfilt.eq.4)flux1=fluxR1
                if(iRVfilt.eq.5)flux1=fluxI1
                if(iRVfilt.eq.6)flux1=fluxJ1
                if(iRVfilt.eq.7)flux1=fluxH1
                if(iRVfilt.eq.8)flux1=fluxK1
                call getvel(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     $              1,omega1,phase,finc,
     %              Q,flum1,x1,y1,flux1,separ,period,gamma,vel1,delvel1,
     %              darkint1(iRVfilt),ecc,argrad,mmdx1,
     @              isw13,ialfmin,ialfmax,bigI,bigbeta,z1)
c
              endif
c 
c   
c
              do jk=1,8
                third(jk)=thirdkeep(jk)
              enddo
              if((Neclipse3.gt.0).and.(isw30.gt.0))then
                gscale3=1.0d0
                call getATMflux(ialphmax3,ibetmax3,Nalph3,
     @             ibetlim3,visib3,projarray3,temp3,surf3,grav3,rinty3,
     @             flum3,maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &             atmint1,atmint2,atmint3,atmint4,atmint5,
     $             atmint6,atmint7,atmint8,gscale3,
     &             fluxU3,fluxB3,fluxV3,fluxR3,fluxI3,fluxJ3,fluxH3,
     @             fluxK3,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     @             iRVfilt,delphi3,delphie3,iedgestar3,iedgehor3,
     @             separ,mmdx3,MonteCarlo,dwavex,dwavey,ilaw,
     @             iatm,3,darkint3)
c
                if(iRVfilt.eq.1)flux3=fluxU3
                if(iRVfilt.eq.2)flux3=fluxB3
                if(iRVfilt.eq.3)flux3=fluxV3
                if(iRVfilt.eq.4)flux3=fluxR3
                if(iRVfilt.eq.5)flux3=fluxI3
                if(iRVfilt.eq.6)flux3=fluxJ3
                if(iRVfilt.eq.7)flux3=fluxH3
                if(iRVfilt.eq.8)flux3=fluxK3
                third(1)=fluxU3
                third(2)=fluxB3
                third(3)=fluxV3
                third(4)=fluxR3
                third(5)=fluxI3
                third(6)=fluxJ3
                third(7)=fluxH3
                third(8)=fluxK3
              endif
              if(idraw.eq.1)then
                call rotkern(ialphmax1,ibetmax1,
     $              Nalph1,ibetlim1,
     &              1,omega1,phase,finc,
     %              Q,flum1,x1,y1,flux1,separ,period,gamma,
     $              ecc,argrad,visib1,extension,mmdx1)
              endif
c
c   UPDATE JULY 4, 2004
c
c   Add MonteCarlo to the argument list.
c
              flux2=0.0d0
              if(idark2.le.0)then
                if(teff2.gt.0.0d0)call getATMflux(ialphmax2,ibetmax2,
     &             Nalph2,ibetlim2,visib2,projarray2,temp2,surf2,
     @             g2,rinty2,flum2,maxlines,maxmu,Nlines,atmT,atmg,
     @             atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @             atmint6,atmint7,atmint8,gscale2,
     &             fluxU2,fluxB2,fluxV2,fluxR2,fluxI2,fluxJ2,fluxH2,
     @             fluxK2,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     @             iRVfilt,delphi2,delphie2,iedgestar2,iedgehor2,
     @             separ,mmdx2,MonteCarlo,dwavex,dwavey,ilaw,
     @             iatm,2,darkint2)
c
                if(iRVfilt.eq.1)flux2=fluxU2
                if(iRVfilt.eq.2)flux2=fluxB2
                if(iRVfilt.eq.3)flux2=fluxV2
                if(iRVfilt.eq.4)flux2=fluxR2
                if(iRVfilt.eq.5)flux2=fluxI2
                if(iRVfilt.eq.6)flux2=fluxJ2
                if(iRVfilt.eq.7)flux2=fluxH2
                if(iRVfilt.eq.8)flux2=fluxK2
              endif
c
c  UPDATE August 16, 2001
c
c  Remove the if clause.  If there is no star 2 (as in an X-ray
c  binary, then the sine curve will still be computed.
c
c              if(teff2.gt.0.0d0)
c
              call getvel(ialphmax2,ibetmax2,Nalph2,
     &            ibetlim2,2,omega2,dummyphase,
     %            finc,Q,flum2,x2,y2,flux2,separ,period,gamma,vel2,
     @            delvel2,darkint2(iRVfilt),ecc,argrad+pie,mmdx2,
     @            isw13,ialfmin,ialfmax,bigI,bigbeta,z2)
c
c
c   UPDATE May 24, 2002
c
c   Here is a new subroutine call.
c
c
              if(idraw.eq.1)then
                call rotkern(ialphmax2,ibetmax2,
     $              Nalph2,ibetlim2,
     &              2,omega2,phase,finc,
     %              Q,flum2,x2,y2,flux2,separ,period,gamma,
     $              ecc,argrad,visib2,extension,mmdx2)
              endif
c
              dflux=0.0d0
c
c   UPDATE DECEMBER 17, 2001
c
c   If tdisk is less than 0, and if iidint is more than 0, then
c   the disk is there for geometrical purposes only (ignore its flux).
c
              if(tdisk.gt.0.0d0)then
c                  write(*,*)'iecheck  idcheck  ',iecheck,idcheck,ecc
                if(idcheck.ge.1)then
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.
c
                  if(iidint.ge.1)call getdiskATMflux(Nrmax,Nthetamax,
     @              Nradius,Ntheta,diskproj,edgeproj,dvisib,evisib,
     @              dtemp,tedge,drad,dinty,einty,stepr,stepz,maxlines,
     @              maxmu,Nlines,atmT,atmg,atmmu,Nmu,atmint1,atmint2,
     @              atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,
     @              icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,
     %              dfluxU,dfluxB,dfluxV,dfluxR,dfluxI,dfluxJ,dfluxH,
     @              dfluxK,iRVfilt,separ,dwavex,dwavey,ilaw,iatm,Tmin)
c
                  zdcorr(1)=dfluxU
                  zdcorr(2)=dfluxB
                  zdcorr(3)=dfluxV
                  zdcorr(4)=dfluxR
                  zdcorr(5)=dfluxI
                  zdcorr(6)=dfluxJ
                  zdcorr(7)=dfluxH
                  zdcorr(8)=dfluxK
                else
                  dfluxU=zdcorr(1)
                  dfluxB=zdcorr(2)
                  dfluxV=zdcorr(3)
                  dfluxR=zdcorr(4)
                  dfluxI=zdcorr(5)
                  dfluxJ=zdcorr(6)
                  dfluxH=zdcorr(7)
                  dfluxK=zdcorr(8)
                endif
              else
                dfluxU=0.0d0
                dfluxB=0.0d0
                dfluxV=0.0d0
                dfluxR=0.0d0
                dfluxI=0.0d0
                dfluxJ=0.0d0
                dfluxH=0.0d0
                dfluxK=0.0d0
              endif
              if(iRVfilt.eq.1)dflux=dfluxU
              if(iRVfilt.eq.2)dflux=dfluxB
              if(iRVfilt.eq.3)dflux=dfluxV
              if(iRVfilt.eq.4)dflux=dfluxR
              if(iRVfilt.eq.5)dflux=dfluxI
              if(iRVfilt.eq.6)dflux=dfluxJ
              if(iRVfilt.eq.7)dflux=dfluxH
              if(iRVfilt.eq.8)dflux=dfluxK
c
c
c   UPDATE OCTOBER 20, 2005
c
c   Change to .ge.5
c
 8938         if((iecheck.ge.5))then
                if(((ecc.eq.0.0d0).and.(iskip1.eq.10).and.
     @            (iskip2.eq.10)).or.((ecc.gt.0.0d0).and.((iskip1.eq.10)
     @            .or.(iskip2.eq.10))))then 
                  do 5432 ll=1,8
c                       icount=icount+1
                    if(ll.eq.1)ymodU(icount)=refflux1(1)+refflux2(1)
     @                +third(1)+corr1(1)+corr2(1)
                    if(ll.eq.2)ymodB(icount)=refflux1(2)+refflux2(2)
     @                +third(2)+corr1(2)+corr2(2)
                    if(ll.eq.3)ymodV(icount)=refflux1(3)+refflux2(3)
     @                +third(3)+corr1(3)+corr2(3)
                    if(ll.eq.4)ymodR(icount)=refflux1(4)+refflux2(4)
     @                +third(4)+corr1(4)+corr2(4)
                    if(ll.eq.5)ymodI(icount)=refflux1(5)+refflux2(5)
     @                +third(5)+corr1(5)+corr2(5)
                    if(ll.eq.6)ymodJ(icount)=refflux1(6)+refflux2(6)
     @                +third(6)+corr1(6)+corr2(6)
                    if(ll.eq.7)ymodH(icount)=refflux1(7)+refflux2(7)
     @                +third(7)+corr1(7)+corr2(7)
                    if(ll.eq.8)ymodK(icount)=refflux1(8)+refflux2(8)
     @                +third(8)+corr1(8)+corr2(8)
                    yeclipse(icount)=dble(Neclipse1)
                    call getrefvel(1,phase,finc,
     %                  Q,separ,period,gamma,vel1,ecc,argrad,isw12,
     @                  gimvel,iRVfilt)
                    call getrefvel(2,dummyphase,finc,
     %                  Q,separ,period,gamma,vel2,ecc,argrad+pie,isw12,
     @                     gimvel,iRVfilt)
                    RV1(icount)=vel1
                    RV2(icount)=vel2
                    if(ll.eq.iRVfilt)then
                      ymods1(icount)=refflux1(ll)
                      ymods2(icount)=refflux2(ll)
                    endif
c
c   UPDATE January 12, 2009
c
c   change fracs to fracs1, fracs2, ...  fracs8
c
                    if(ll.eq.1)then
                      fracs1(icount,1)=refflux1(ll)
                      fracs1(icount,2)=refflux2(ll)
                      fracs1(icount,3)=dflux
                      fracs1(icount,4)=third(1)
                    endif
                    if(ll.eq.2)then
                      fracs2(icount,1)=refflux1(ll)
                      fracs2(icount,2)=refflux2(ll)
                      fracs2(icount,3)=dflux
                      fracs2(icount,4)=third(2)
                    endif
                    if(ll.eq.3)then
                      fracs3(icount,1)=refflux1(ll)
                      fracs3(icount,2)=refflux2(ll)
                      fracs3(icount,3)=dflux
                      fracs3(icount,4)=third(3)
                    endif
                    if(ll.eq.4)then
                      fracs4(icount,1)=refflux1(ll)
                      fracs4(icount,2)=refflux2(ll)
                      fracs4(icount,3)=dflux
                      fracs4(icount,4)=third(4)
                    endif
                    if(ll.eq.5)then
                      fracs5(icount,1)=refflux1(ll)
                      fracs5(icount,2)=refflux2(ll)
                      fracs5(icount,3)=dflux
                      fracs5(icount,4)=third(5)
                    endif
                    if(ll.eq.6)then
                      fracs6(icount,1)=refflux1(ll)
                      fracs6(icount,2)=refflux2(ll)
                      fracs6(icount,3)=dflux
                      fracs6(icount,4)=third(6)
                    endif
                    if(ll.eq.7)then
                      fracs7(icount,1)=refflux1(ll)
                      fracs7(icount,2)=refflux2(ll)
                      fracs7(icount,3)=dflux
                      fracs7(icount,4)=third(7)
                    endif
                    if(ll.eq.8)then
                      fracs8(icount,1)=refflux1(ll)
                      fracs8(icount,2)=refflux2(ll)
                      fracs8(icount,3)=dflux
                      fracs8(icount,4)=third(8)
                    endif


 5432            continue
                  if(ecc.eq.0.0d0)go to 9939
                  if(ecc.gt.0.0d0)go to 9939
                endif
              endif
c
c    Doppler boosting
c
              dop1=(vel1-gamma)/2.99792458d5
              dop2=(vel2-gamma)/2.99792458d5
              if(iRVfilt.eq.1)fluxU1=fluxU1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.2)fluxB1=fluxB1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.3)fluxV1=fluxV1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.4)fluxR1=fluxR1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.5)fluxI1=fluxI1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.6)fluxJ1=fluxJ1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.7)fluxH1=fluxH1*(1.0d0-beam1*dop1)
              if(iRVfilt.eq.8)fluxK1=fluxK1*(1.0d0-beam1*dop1)

              if(iRVfilt.eq.1)fluxU2=fluxU2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.2)fluxB2=fluxB2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.3)fluxV2=fluxV2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.4)fluxR2=fluxR2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.5)fluxI2=fluxI2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.6)fluxJ2=fluxJ2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.7)fluxH2=fluxH2*(1.0d0-beam2*dop2)
              if(iRVfilt.eq.8)fluxK2=fluxK2*(1.0d0-beam2*dop2)

              ymodU(icount)=fluxU1+fluxU2+dfluxU+third(1)
              ymodB(icount)=fluxB1+fluxB2+dfluxB+third(2)
              ymodV(icount)=fluxV1+fluxV2+dfluxV+third(3)
              ymodR(icount)=fluxR1+fluxR2+dfluxR+third(4)
              ymodI(icount)=fluxI1+fluxI2+dfluxI+third(5)
              ymodJ(icount)=fluxJ1+fluxJ2+dfluxJ+third(6)
              ymodH(icount)=fluxH1+fluxH2+dfluxH+third(7)
              ymodK(icount)=fluxK1+fluxK2+dfluxK+third(8)
              yeclipse(icount)=dble(Neclipse1)
c
              fracs1(icount,1)=fluxU1
              fracs2(icount,1)=fluxB1
              fracs3(icount,1)=fluxV1
              fracs4(icount,1)=fluxR1
              fracs5(icount,1)=fluxI1
              fracs6(icount,1)=fluxJ1
              fracs7(icount,1)=fluxH1
              fracs8(icount,1)=fluxK1

              fracs1(icount,2)=fluxU2
              fracs2(icount,2)=fluxB2
              fracs3(icount,2)=fluxV2
              fracs4(icount,2)=fluxR2
              fracs5(icount,2)=fluxI2
              fracs6(icount,2)=fluxJ2
              fracs7(icount,2)=fluxH2
              fracs8(icount,2)=fluxK2

              fracs1(icount,3)=dfluxU
              fracs2(icount,3)=dfluxB
              fracs3(icount,3)=dfluxV
              fracs4(icount,3)=dfluxR
              fracs5(icount,3)=dfluxI
              fracs6(icount,3)=dfluxJ
              fracs7(icount,3)=dfluxH
              fracs8(icount,3)=dfluxK
c
              fracs1(icount,4)=third(1)
              fracs2(icount,4)=third(2)
              fracs3(icount,4)=third(3)
              fracs4(icount,4)=third(4)
              fracs5(icount,4)=third(5)
              fracs6(icount,4)=third(6)
              fracs7(icount,4)=third(7)
              fracs8(icount,4)=third(8)

              ymods1(icount)=flux1
              ymods2(icount)=flux2
              ymods3(icount)=third(iRVfilt)
              ymodd(icount)=dflux
              RV1(icount)=vel1
              dRV1(icount)=delvel1
              RV2(icount)=vel2
              dRV2(icount)=delvel2
c
              call copyinty(ialphmax1,ibetmax1,Nalph1,
     $              Nalph2,rinty1,saveinty1,rinty2,saveinty2,
     %              mmdx1,mmdx2,ibetlim1,ibetlim2,ialphmax2,ibetmax2)
              if(isw30.gt.0)call copyinty3(ialphmax3,ibetmax3,Nalph3,
     @              ibetlim3,mmdx3,rinty3,saveinty3)
              if(iidint.ge.1)call copydiskinty(Nrmax,Nthetamax,Nradius,
     %              Ntheta,dinty,savedinty,einty,saveeinty)

            endif  ! end if iatm.ge.1
C
            if(idraw.eq.1)then

c              write(*,*)'iidint = ',iidint

              ppp=phase
              dppp=dummyphase
              if((ecc.gt.0.0d0).and.(ism1.eq.0))then  
                 ppp=dmod(em*180.0d0/pie-phase,360.0d0)
                 ppp=pstart
              endif
              if((ecc.gt.0.0d0).and.(ism1.gt.0))then
                if(ipstep.eq.1)ppp=dmod(em*180.0d0/(pie)-phase,360.0d0)
                if(ipstep.eq.2)ppp=dmod(emnew*180.0d0/(pie)-phase,360.0d0)
                ppp=pstart
              endif
              if(ecc.gt.0.0d0)dppp=ppp+180.0d0
c
              if(iidint.ge.1)then
                call hidgrid(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @           ppp,finc,Q,x1,y1,z1,xend1,projarray1,g1,gscale1,
     @           surf1,Ndhoriz,dxhoriz,dyhoriz,saveinty1,extension,
     @           separ,fluxV1,reff1,iecheck,temp1,Nhoriz1,xhoriz1,
     @           yhoriz1,bdist,mmdx1,tertincl,tertbdist,tertphase,tertQ,
     @           axisscale,isw30,isw7,tertOmega,icounttime,Nhoriz3,
     @           xhoriz3,yhoriz3,i3flag)
              endif
c
              if(iidint.le.0)then
                call hidgrid(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @           ppp,finc,Q,x1,y1,z1,xend1,projarray1,g1,gscale1,
     @           surf1,Nhoriz2,xhoriz2,yhoriz2,saveinty1,extension,
     @           separ,fluxV1,reff1,iecheck,temp1,Nhoriz1,xhoriz1,
     @           yhoriz1,bdist,mmdx1,tertincl,tertbdist,tertphase,tertQ,
     @           axisscale,isw30,isw7,tertOmega,icounttime,
     @           Nhoriz3,xhoriz3,yhoriz3,i3flag)
              endif
c
              if(teff2.gt.0.0d0)call hidgrid(2,ialphmax2,ibetmax2,
     @           Nalph2,ibetlim2,dppp,finc,Q,x2,y2,z2,xend2,
     @           projarray2,g2,gscale2,surf2,Nhoriz1,xhoriz1,
     @           yhoriz1,saveinty2,extension,separ,fluxV2,reff2,iecheck,
     @           temp2,Nhoriz2,xhoriz2,yhoriz2,bdist,mmdx2,tertincl,
     @           tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @           tertOmega,icounttime,Nhoriz3,xhoriz3,yhoriz3,i3flag)
c
              if(isw30.gt.0)call hidgrid3(ialphmax3,ibetmax3,Nalph3,ibetlim3,
     @      phase,finc,Q,x3,y3,z3,projarray3,
     @      gthird,g3,surf3,Nhoriz1,xhoriz1,yhoriz1,rinty3,extension,
     $      separ,fluxV3,reff3,iecheck,temp3,bdist,mmdx3,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega,icounttime,Nhoriz2,xhoriz2,yhoriz2,i3flag)
              if(iidint.gt.0)call hiddiskgrid(Nrmax,Nthetamax,Nradius,
     %            Ntheta,diskproj,edgeproj,dtemp,tedge,
     @            dx,dy,dz,xedge,yedge,zedge,savedinty,saveeinty,
     @            ppp,finc,Q,Nhoriz1,xhoriz1,yhoriz1,
     @            extension,separ,dflux,bdist,tertincl,tertbdist,
     @            tertphase,tertQ,axisscale,isw30,isw7,tertOmega,
     @            icounttime)
c
              call getcoords(1,ialphmax1,ibetmax1,Nalph1,ibetlim1,
     &           ppp,finc,Q,x1,y1,z1,gradx1,grady1,gradz1,temp1,
     %           Ndumsky1,dumxsky1,dumysky1,xend1,extension,separ,bdist,
     @           mmdx1,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @           isw30,isw7,tertOmega,icounttime)
c
              if(teff2.gt.0.0d0)call getcoords(2,ialphmax2,ibetmax2,
     &           Nalph2,ibetlim2,dppp,finc,Q,x2,y2,z2,gradx2,
     @           grady2,gradz2,temp2,Ndumsky2,dumxsky2,dumysky2,xend2,
     $           extension,separ,bdist,mmdx2,tertincl,tertbdist,
     @           tertphase,tertQ,axisscale,isw30,isw7,tertOmega,
     @           icounttime)
c
              call writepoints(ialphmax1,ibetmax1,Nthetamax,
     $           Nsky1,xsky1,ysky1,Nsky2,xsky2,
     &           ysky2,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,xhoriz2,yhoriz2,
     &           Nskydisk,xskydisk,yskydisk,zskydisk,
     %           Ntop2,xtop2horiz,ytop2horiz,
     &           Ndtop,dtopx,dtopy,Ndhoriz,dxhoriz,dyhoriz,
     %           Nskyedge,xskyedge,yskyedge,extension,separ,teff2,iidint,
     &           ialphmax2,ibetmax2,icounttime,Nsky3,xsky3,ysky3,
     @           Nhoriz3,xhoriz3,yhoriz3,isw30)
            endif
c
c   Next, set various toggle switches based on whether any points were
c   eclipsed.  If iecheck = 1, then the code will not check for eclipses
c   for phases between togglephase and (180-togglephase) and between
c   (180+togglephase) and (360-(togglephase-180)) where togglephase
c   is the phase where the number of eclipsed points is zero for the first
c   time.
c
c   Also, if iecheck was set to 1, the disk integration will be skipped
c   at phases where there is no eclipse.
c
            Ntotal=Neclipse1+Neclipse2+Neclipsed
c            write(*,*)Neclipsed,phase,itoggle,Neclipse1,Neclipse2
            if((itoggle.eq.-1).and.(Ntotal.eq.0))then
              itoggle=1
              if(icount.gt.1)then
                if(phase.lt.180.0d0)togglephase=phase        
              else
                if(phase.lt.180.0d0)togglephase=dphase
              endif
              if(iecheck.ge.1)idcheck=-100
            endif
 9939       if(isw7.ge.2)xmod(icount)=timearray(icounttime)
            if(isw7.le.1)xmod(icount)=phase/360.0d0

c            if(ymodV(icount).le.1.d10)write(*,*)phase,ymodV(icount)
c
c   RVG BUG ALERT
c
c   Change the assignment of the value of xmod for eccentric orbits as
c   below.
c
            if((ecc.gt.0.0d0).and.(ism1.eq.0))xmod(icount)=em/(2.0d0*pie)
            if((ecc.gt.0.0d0).and.(ism1.gt.0))then
              if(ipstep.eq.1)xmod(icount)=em/(2.0d0*pie)
              if(ipstep.eq.2)xmod(icount)=emnew/(2.0d0*pie)
            endif
c
            if((isw7.ge.2).and.(ecc.gt.0.0d0))xmod(icount)=
     @          timearray(icounttime)
            write(64,101)phase,Ntotal,iecheck,idcheck,itoggle,
     @           togglephase
            tshift=pshift+eshift
c
c   UPDATE September 10, 2001
c
c   Add the if-then clauses.
c
            if(ikeep.eq.1)tshift=pshift+eshift-pconj
            if(ikeep.eq.2)tshift=pshift+eshift-pconj2
            qqq=dmod(xmod(icount)+tshift,1.0d0)
            overQ=1.0d0/Q
            rrr=pot2/overQ+0.5d0*(overQ-1.0d0)/overQ
c
c   RVG BUG ALERT   May 16, 2001
c
c   Record parameters for eccentric orbits in unit 65.
c
            if(ecc.gt.0.0d0)write(65,1011)qqq,bdist,tpole1,
     @        tpole2,fill1,fill2,rpole1,rpole2,pot1,rrr,SA1,SA2,pots1,pots2,
     @        gscale1,gscale2
c
c   UPDATE OCTOBER 20, 2005
c
c   change to .ge.5
c
            if((iecheck.ge.5).and.(ecc.gt.0.0d0).and.((iskip1.eq.10).
     &          or.(iskip2.eq.10)))go to 999
            if((iecheck.ge.5).and.(ecc.eq.0.0d0).and.((iskip1.eq.10).
     &          and.(iskip2.eq.10)))go to 10
 10       continue
c
 999      continue    ! continue the big loop if eccentric
c
 1011     format(f15.6,1x,f7.5,1x,2(f10.5,1x),1x,2(f7.5,1x),1x,2(f7.5,1x),
     %        2(f9.5,1x),1x,2(f9.6,1x),4(f9.6,1x))

          Nphase=icount
          icountx=icount
c
          if(Nphase.le.1)write(*,*)finc,Q,separ,pstart,pstop

c
c
c   If ism1=1, then we have to reflect the light curves to get phases 180
c   to 360-dphase.
c
c   RVG BUG ALERT   April 19, 2001
c
c   If the eccentricity is greater than 0, do not 'finish' the light curve
c   since it is already complete.
c
c   UPDATE October 18, 2002
c
c   Use the input flags sw7 and sw8 to define a phase range
c   to compute.  Require sw7 > 0 and sw8 > 0  AND  sw7 < sw 8
c   If this is true, then don't complete the light curves.   
c
c
          if(isw7.ge.2)go to 1233
          if((sw7.gt.0.0d0).and.(sw8.gt.0.0d0).and.(sw7.lt.sw8))go to 654
c
          if((ionephase.eq.0).and.(ism1.ge.1).and.(ecc.eq.0.0d0))then
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodU,1)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodB,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodV,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodR,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodI,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodJ,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodH,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodK,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymods1,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymods2,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymods3,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,ymodd,0)
            call finishlc(Nmaxphase,icount,dphase,Nphase,xmod,yeclipse,
     @             0)
            call finishRV(1,Nmaxphase,icount,dphase,Nphase,xmod,RV1,
     @          gamma,dRV1)
            call finishRV(2,Nmaxphase,icount,dphase,Nphase,xmod,RV2,
     @          gamma,dRV2)
          endif            
c
          if(isw24.ge.1)call getfracs(Nmaxphase,icount,
     %         fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     &         compfracs,dphase,eshift,pshift,ionephase,ism1,ecc,sw26)
c
c   UPDATE October 18, 2002
c
c   Add the statement label 654 below.
c
 654      continue 
c
c
c   Close the file with the eccentric parameters.
c
          if(ecc.gt.0.0d0)close(65)
c
c   Reset the value of iecheck.
c
          iecheck=iesave
          if(iRVfilt.eq.1)icnU=iVsave
          if(iRVfilt.eq.2)icnB=iVsave
          if(iRVfilt.eq.3)icnV=iVsave
          if(iRVfilt.eq.4)icnR=iVsave
          if(iRVfilt.eq.5)icnI=iVsave
          if(iRVfilt.eq.6)icnJ=iVsave
          if(iRVfilt.eq.7)icnH=iVsave
          if(iRVfilt.eq.8)icnK=iVsave
c
c   Apply the phase shift, if any.
c
c   RVG BUG ALERT   May 4, 2001
c
c   add ionephase.eq.0 to the if() statement
c
c


 1233     continue
          if((isw7.ge.2))then
            if(isw24.ge.1)call getfracstime(Nmaxphase,icount,
     %         fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     &         compfracs,sw26)
            go to 12345
          endif
          if(ionephase.eq.0)then
            if((ecc.gt.0.0d0).or.(pshift.ne.0.0d0))then
              tshift=pshift+eshift
c
c   UPDATE September 10, 2001
c
c   Add the if-then clauses.
c
              if(ikeep.eq.1)tshift=pshift+eshift-pconj
              if(ikeep.eq.2)tshift=pshift+eshift-pconj2
c
c  UPDATE March 26, 2002
c
c  Remove the variables icount and dphase from the argument list of
c  shiftlc (they are not used).
c
              call shiftlc(Nmaxphase,Nphase,xmod,ymodU,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodB,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodV,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodR,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodI,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodJ,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodH,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodK,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods1,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods2,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods3,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodd,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,RV1,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,dRV1,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,RV2,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,yeclipse,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,dRV2,tshift,1)
            endif
          endif
c
c   UPDATE September 10, 2001
c
c   If Teff < 0, then compute the duration of the X-ray eclipse if any.
c   The length of the X-ray eclipse in DEGREES will be stored in the variable
c   obsparm(9).
c
c   UPDATE December 11, 2001
c
c   If ionephase > 0, only one phase was requested (presumably for
c   drawing purposes).  If ionephase > 0, skip to the end (go to 12345)
c

c          if(isw23.ge.1)then
c            call distorttime(Nmaxphase,Nphase,xmod,yeclipse,RV2,gamma,
c     %         pconj)
c          endif

          if(ionephase.ge.1)go to 12345
c
c          xecl=0.0d0
          phin=0.0d0
          phout=0.0d0
          if(Teff2.le.0.0d0)then
c
            if(ecc.eq.0.0d0)then   ! case for circular orbits
              if(icountx.gt.1)call sort2(icountx,xecx,xecy)
c
c   Check at phase 0.0 to see if there is an eclipse.
c
              bdist=1.0d0
              phase=0.0d0
c
              call gethorizon(1,ialphmax1,ibetmax1,Nalph1,
     @          ibetlim1,phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,gradx1,
     @          grady1,gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,phiar1,
     @          iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,
     @          yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,
     @          tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @          tertOmega)
c
              call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @          phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @          isw30,isw7,tertOmega)
c
              if(ixecl.le.0)then
                obsparm(9)=0.0d0
                write(2,321)obsparm(9)
                go to 12345  ! no eclipse here
              endif
c
c   Now we have to locate the phase where the X-ray source is not
c   eclipsed and iterate.
c
              phin=0.0d0
              do 12000 ii=2,icountx
                if(xecy(ii).gt.10.0d0)then
                  phin=xecx(ii)
                  go to 12000
                else
                  phout=xecx(ii)
                  go to 12001
                endif
12000         continue
c
12001         do 12002 ii=1,30
                phase=0.5d0*(phout+phin)
                bdist=1.0d0
c
                call gethorizon(1,ialphmax1,ibetmax1,Nalph1,
     @            ibetlim1,phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,
     @            gradx1,grady1,gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,
     @            phiar1,iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,
     @            yhmin1,yhmax1,tidephi,itide,phihor1,ecc,thetamis,
     @            phimis,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
c
                call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @            phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
c
                if(ixecl.gt.10)phin=phase
                if(ixecl.lt.-10)phout=phase
12002         continue
c
              obsparm(9)=2.0d0*phin
              write(2,321)obsparm(9)
c
            endif       ! endif ecc = 0
c
            if(ecc.gt.0.0d0)then   ! case for eccentric
              if(icountx.gt.1)call sort2(icountx,xecx,xecy)
c
c   Check at the conjunction phase to see if there is an eclipse.
c
              rnu=-argper-90.0d0
              rnu=rnu*pie/180.0d0
              phase=0.0d0
              bdist=(1.0d0-ecc*ecc)/(1.0d0+ecc*dcos(rnu))
c
              call setupgeo(1,ialphmax1,ibetmax1,Nalph1,Nbet1,ibetlim1,
     $         fill1,omega1,Q,finc,
     $         x1,y1,z1,
     %         surf1,rad1,gradx1,grady1,gradz1,g1,xend1,separ,
     %         Tgrav1,Teff1,reff1,Rl1,Tpole1,Rpol1,Regg1,SA1,pot1,gpole1,
     %         phiar1,isquare,iusepot,usepot1,ivrt,pervol1,
     &         fillper1,bdist,pots1,1,mmdx1,primmass,primK,
     &         primrad,ratrad,frac1,frac2,ecc,period,size1,
     &         sw5,tteff2,density,tidephi,itide,phistart1,
     &         thetamis,phimis)
c 
              call gethorizon(1,ialphmax1,ibetmax1,Nalph1,
     @          ibetlim1,phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,gradx1,
     @          grady1,gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,phiar1,
     @          iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,
     @          yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,
     @          tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @          tertOmega)
c
              call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @          phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @          isw30,isw7,tertOmega)
c
              if(ixecl.le.0)then
                obsparm(9)=0.0d0
                write(2,321)obsparm(9)
                go to 12345  ! no eclipse here
              endif
c
c   Now we have to locate the phase where the X-ray source is not
c   eclipsed and iterate.
c
              phin=0.0
c
              do 22000 ii=1,icountx
                if(xecy(ii).gt.10.0d0)then
                  phin=xecx(ii)
                  go to 22000
                else
                  phout=xecx(ii)
                  go to 22001
                endif
22000         continue
c
22001         do 22002 ii=1,20
                phase=0.5d0*(phout+phin)
                rnu=pie/180.0d0*dmod((phase-90.0d0-argper),360.0d0)
                if(rnu.lt.0.0d0)rnu=rnu+2.0*pie
                bdist=(1.0d0-ecc*ecc)/(1.0d0+ecc*dcos(rnu))
c
                call setupgeo(1,ialphmax1,ibetmax1,Nalph1,Nbet1,
     @            ibetlim1,fill1,omega1,Q,finc,x1,y1,z1,surf1,rad1,
     @            gradx1,grady1,gradz1,g1,xend1,separ,Tgrav1,Teff1,
     @            reff1,Rl1,Tpole1,Rpol1,Regg1,SA1,pot1,gpole1,phiar1,
     @            isquare,iusepot,usepot1,ivrt,pervol1,fillper1,bdist,
     @            pots1,1,mmdx1,primmass,primK,primrad,ratrad,frac1,
     @            frac2,ecc,period,size1,sw5,tteff2,
     @            density,tidephi,itide,phistart1,thetamis,phimis)
c 
                call gethorizon(1,ialphmax1,ibetmax1,Nalph1,
     @            ibetlim1,phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,
     @            gradx1,grady1,gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,
     @            phiar1,iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,
     @            yhmin1,yhmax1,tidephi,itide,phihor1,ecc,thetamis,
     @            phimis,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
c
                call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @           phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     $           isw30,isw7,tertOmega)
c
                if(ixecl.gt.10)phin=phase
                if(ixecl.lt.-10)phout=phase
22002         continue
c
c   Now figure out the observed phase of the angle corresponding to rnu.
c
              if(rnu.lt.0.0d0)rnu=rnu+2.0d0*pie
              ECAN=2.0d0*datan(dtan(rnu*0.5d0)*
     @           dsqrt((1.0d0-ecc)/(1.0d0+ecc)))
              ECAN=dmod(ECAN,2.0d0*pie)
              if(ECAN.lt.0.0d0)ECAN=ECAN+2.0d0*pie
              obsph1=ECAN-ecc*dsin(ECAN)            ! in radians!
c
c   Now look at the other ingress phase.
c
              do 42000 ii=icountx,1,-1
                if(xecy(ii).gt.10.0d0)then
                  phin=xecx(ii)
                  go to 42000
                else
                  phout=xecx(ii)
                  if(ii.eq.icountx)phin=359.99d0
                  go to 42001
                endif
42000         continue
c
42001         do 42002 ii=1,20
                phase=0.5d0*(phout+phin)
                rnu=pie/180.0d0*dmod((phase-90.0d0-argper),360.0d0)
                if(rnu.lt.0.0d0)rnu=rnu+2.0*pie
                bdist=(1.0d0-ecc*ecc)/(1.0d0+ecc*dcos(rnu))
c
                call setupgeo(1,ialphmax1,ibetmax1,Nalph1,Nbet1,
     @            ibetlim1,fill1,omega1,Q,finc,x1,y1,z1,surf1,rad1,
     @            gradx1,grady1,gradz1,g1,xend1,separ,Tgrav1,Teff1,
     @            reff1,Rl1,Tpole1,Rpol1,Regg1,SA1,pot1,gpole1,phiar1,
     @            isquare,iusepot,usepot1,ivrt,pervol1,fillper1,bdist,
     @            pots1,1,mmdx1,primmass,primK,primrad,ratrad,frac1,
     @            frac2,ecc,period,size1,sw5,tteff2,
     @            density,tidephi,itide,phistart1,thetamis,phimis)
c 
                call gethorizon(1,ialphmax1,ibetmax1,Nalph1,
     @            ibetlim1,phase,finc,Q,pot1,omega1,x1,y1,z1,rad1,
     @            gradx1,grady1,gradz1,xend1,Nhoriz1,xhoriz1,yhoriz1,
     @            phiar1,iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,
     @            yhmin1,yhmax1,tidephi,itide,phihor1,ecc,thetamis,
     @            phimis,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
c
                call getXecl(Nhoriz1,xhoriz1,yhoriz1,ixecl,Q,finc,bdist,
     @            phase,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @            isw30,isw7,tertOmega)
c
                if(ixecl.gt.10)phin=phase
                if(ixecl.lt.-10)phout=phase
42002         continue
c
c   Figure out the observed phase of the angle rnu.
c
              if(rnu.lt.0.0d0)rnu=rnu+2.0d0*pie
              ECAN=2.0d0*datan(dtan(rnu*0.5d0)*
     @           dsqrt((1.0d0-ecc)/(1.0d0+ecc)))
              ECAN=dmod(ECAN,2.0d0*pie)
              if(ECAN.lt.0.0d0)ECAN=ECAN+2.0d0*pie
              obsph2=ECAN-ecc*dsin(ECAN)    ! in radians
c
              ddd2=dabs(obsph2-obsph1)
              if(ddd2.gt.pie)then
                ddd2=(obsph1+2.0d0*pie)-obsph2
              endif
              obsparm(9)=ddd2*180.0d0/pie
              write(2,321)obsparm(9)
c
            endif       ! endif ecc = 0
c
          endif     ! endif Teff < 0

 101      format(f15.8,10x,i8,2x,i4,1x,i4,2x,i2,1x,f13.8)
c
c   UPDATE September 11, 2001
c
c   Add this format statement.
c
 321      format('X-ray eclipse duration = ',f11.6,' degrees')
c
c          call getnorm(Nphase,xmod,ymodV,Vnorm)
c          call lcnorm(Nphase,ymodV,Vnorm)
c          call lcnorm(Nphase,ymods1,Vnorm)
c          call lcnorm(Nphase,ymods2,Vnorm)
c
c
c   Close the unit 2 file here (ELC.out) instead of in the main program.
c
12345     close(2)
          close(64)
c
c   Close the file with the eccentric parameters.
c
          if(ecc.gt.0.0d0)close(65)
c
c
c
c   UPDATE June 7, 2002
c
c   Add the X-ray eclipse duration to the end of parmstring.
c
c   UPDATE October 28, 2002
c
c   Make the length of parmstring character*249, hence add 12 to the 227 below.
c
c   UPDATE October 22, 2008
c
c   Make the length of parmstring character*259.
c
c
          ljk=lnblnk(parmstring)
          scr1string=parmstring(1:ljk)
          write(scr2string,54321)obsparm(9)
          parmstring=scr1string(1:ljk)//scr2string
c
54321     format(1x,f11.7)
c
c   UPDATE OCTOBER 24, 2005
c
c   If the iecheck=5 option was used, remove the skipped phases.  These
c   will have negative values in the light curves.
c
c  UPDATE NOVEMBER 22, 2006
c
c  Don't clip the RV curves.  Add the variable NRVphase and xRVmod
c
          NRVphase=Nphase
          do 12346 ii=1,Nphase
            xRVmod(ii)=xmod(ii)
12346     continue
c
          if(iecheck.eq.5)then
            icount=Nphase
            call cliplc(Nmaxphase,icount,Nphase,xmod,ymodU,ymodB,ymodV,
     @         ymodR,ymodI,ymodJ,ymodH,ymodK,ymods1,ymods2,ymods3,ymodd)
          endif            
c
c
c   UPDATE JULY 21, 2006
c
c   Add a "fast genetic" mode.  If ifastflag=1, then set 
c     Nalph1=40 
c     Nbet1=14
c     Nalph2=40
c     Nbet2=14
c     dphase=3
c 
c   We need to restore the reset values above.
c
          if(ifastflag.ge.1)then
            Nalph1=iNa1save
            Nalph2=iNa2save
            Nbet1=iNb1save
            Nbet2=iNb2save
            dphase=savedphase
          endif
c
c  UPDATE JULY 5, 2011
c
c  If the Kepler contamination is not zero, then dilute the
c  light curve (modelU)
c
          if((contam.gt.0.0d0).and.(contam.lt.1.0d0))then
c            write(*,*)Nphase,' call contaminate'
            if(Nphase.gt.1)call contaminate(Nmaxphase,Nphase,xmod,ymodU,
     @         contam)
          endif
c

c   UPDATE JULY 13, 2009
c
c   If requested, bin the light and velocity curves.  sw29 will be
c   the binsize for the photometry, in minutes, and sw30 will be the bin
c   size for the RV curves, in minutes
c 
          if((sw29.gt.0.0d0).and.(icnU.ne.430))then
            if(isw7.le.1)then
              call  binlc(Nmaxphase,Nphase,xmod,ymodU,period,
     @          sw29)
              else
                call binlctime(Nmaxphase,Nphase,xmod,ymodU,period,
     @          sw29,NSC,xSC,ySC)
             endif
          endif
c          if((sw29.gt.0.0d0).and.(icnB.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodB,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodB,period,
c     @          sw29)
c               endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnV.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodV,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodV,period,
c     @          sw29)
c              endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnR.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodR,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodR,period,
c     @          sw29)
c              endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnI.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodI,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodI,period,
c     @          sw29)
c              endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnJ.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodJ,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodJ,period,
c     @          sw29)
c              endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnH.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodH,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodH,period,
c     @          sw29)
c              endif
c          endif
c          if((sw29.gt.0.0d0).and.(icnK.ne.430))then
c            if(isw7.le.1)then
c              call binlc(Nmaxphase,Nphase,xmod,ymodK,period,
c     @          sw29)
c              else
c                call binlctime(Nmaxphase,Nphase,xmod,ymodK,period,
c     @          sw29)
c              endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods1,period,
c     @         sw29)
c             else
c               call binlc(Nmaxphase,Nphase,xmod,ymods1,period,
c     @         sw29)
c             endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods2,period,
c     @         sw29)
c             else
c               call binlctime(Nmaxphase,Nphase,xmod,ymods2,period,
c     @         sw29)
c             endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods3,period,
c     @         sw29)
c             else
c               call binlctime(Nmaxphase,Nphase,xmod,ymods3,period,
c     @         sw29)
c             endif
c          endif
          if(sw30.gt.0.0d0)then
            if(isw7.le.1)then
              if(icnRV1.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,RV1,
     @         period,sw30)
            else
              if(icnRV1.ne.430)call binlctime(Nmaxphase,NRVphase,
     %          xRVmod,RV1,period,
     @          sw30,NSC,xSC,ySC)
             endif
          endif
          if(sw30.gt.0.0d0)then
            if(isw7.le.1)then
              if(icnRV2.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,RV2,
     @         period,sw30)
            else
              if(icnRV1.ne.430)call binlctime(Nmaxphase,NRVphase,
     %          xRVmod,RV2,period,
     @          sw30,NSC,xSC,ySC)
             endif
          endif
c
          if(sw30.gt.0.0d0)then
            if(isw7.le.1)then
              if(icnRV1.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,
     @          dRV1,period,sw30)
            else
              if(icnRV1.ne.430)call binlctime(Nmaxphase,NRVphase,
     %          xRVmod,dRV1,period,
     @          sw30,NSC,xSC,ySC)
            endif
          endif
          if(sw30.gt.0.0d0)then
            if(isw7.le.1)then
              if(icnRV2.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,
     @           dRV2,period,sw30)
            else
              if(icnRV2.ne.430)call binlctime(Nmaxphase,NRVphase,
     &          xRVmod,dRV2,period,
     @          sw30,NSC,xSC,ySC)
            endif
          endif
c
          if((sw29.gt.0.0d0).and.(iidint.gt.0))
     &       call binlc(Nmaxphase,Nphase,xmod,ymodd,period,
     @       sw29)

          call getdepth(Nphase,ymodU,rdepth)

          ljk=lnblnk(parmstring)
          scr1string=parmstring(1:ljk)
          write(scr2string,54321)rdepth
          parmstring=scr1string(1:ljk)//scr2string
c
          return
          end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getdepth(N,ymod,rdepth)
c
          implicit double precision(a-h,o-z)
          dimension ymod(N)
c
          rmax=-1.0d99
          rmin=1.0d99
c
          do 10 i=1,N
            if(ymod(i).gt.rmax)rmax=ymod(i)
            if(ymod(i).lt.rmin)rmin=ymod(i)
10        continue
          rdepth=(rmax-rmin)/rmax
          return
          end

c
c
           subroutine binlc(Nmaxphase,Nphase,xmod,ymod,period,sw29)
c
c   This subroutine will bin a light curve in phase, using a binsize given
c   by sw29, where the units are minutes.
c
           implicit double precision (a-h,o-z)
c
           parameter(isize=4500000)
           dimension xmod(Nmaxphase),ymod(Nmaxphase)
           dimension yinter(isize),y2(isize)
           dimension xpad(isize),ypad(isize)
c
           if(isize.lt.3*Nmaxphase)then
             write(*,*)'Dimension error in subroutine binlc.'
             write(*,*)'Change isize to be > 3*Nmaxphase.'
             stop
           endif
           call addpad(Nphase,xmod,ymod,xpad,ypad)
           Mphase=Nphase*3
c
c   We will interpolate the model, and given each value in xmod, figure
c   out the range of phase needed, and average the interpolated y-values
c
           call spline(xpad,ypad,Mphase,0.0d0,0.0d0,y2)
c
           pstep=sw29/1440.0d0/period
           pwidth=0.5d0*pstep
c
           NN=7
           do 10 i=1,Mphase
             if(xpad(i).gt.1.0d0)go to 10
             if(xpad(i).lt.0.0d0)go to 10
             kcount=0
             summ=0.0d0        
             jlo=i
c 
             a=xpad(i)-pwidth
             b=xpad(i)+pwidth

             do 9 j=1,NN
               if(j.eq.1)then
                 xxx=a
                 call hunt(xpad,Mphase,xxx,jlo)
                 if((jlo.eq.Mphase).or.(jlo.eq.0))then
                   call splint(xpad,ypad,y2,Mphase,xxx,qqqa)
                 else
                   call fastsplint(xpad,ypad,y2,Mphase,xxx,qqqa,jlo,
     @              jlo+1)
                 endif
                 xxx=b
                 call hunt(xpad,Mphase,xxx,jlo)
                 if((jlo.eq.Mphase).or.(jlo.eq.0))then
                   call splint(xpad,ypad,y2,Mphase,xxx,qqqb)
                 else
                   call fastsplint(xpad,ypad,y2,Mphase,xxx,qqqb,jlo,
     @                 jlo+1)
                 endif
                 summ=0.5d0*(b-a)*(qqqa+qqqb)
               else
                 it=2**(j-2)
                 tnm=dble(it)
                 del=(b-a)/tnm
                 x=a+0.5d0*del
                 xxx=x
                 s=0.0d0
                 do 11 kk=1,it
                   kcount=kcount+1 
                   call hunt(xpad,Mphase,xxx,jlo)
                   if((jlo.eq.Mphase).or.(jlo.eq.0))then
                     call splint(xpad,ypad,y2,Mphase,xxx,qqq)
                   else
                     call fastsplint(xpad,ypad,y2,Mphase,xxx,qqq,jlo,
     @                 jlo+1)
                   endif
                   s=s+qqq
                   x=x+del
                   xxx=x
11               continue
                 summ=0.5d0*(summ+(b-a)*s/tnm)
               endif
c
9           continue

           yinter(i)=summ/pstep

10         continue
c
           do 20 i=1,Mphase
             ypad(i)=yinter(i)
20         continue
c
           call removepad(Nphase,ymod,ypad)

           return
           end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getnorm(N,xx,yy,ynorm)
c
c
c         
          implicit double precision(a-h,o-z)

          dimension yy(N),xx(N)
c
          ymax=1.0d0
          diffmin=12345.d0
          do 10 i=1,N
            diff=dabs(xx(i)-0.2500d0)
            if(diff.lt.diffmin)then
              ymax=yy(i)
              diffmin=diff
            endif
 10       continue
          ynorm=ymax
c
          return
          end
c
c   *******************************************
c
          subroutine lcnorm(N,yy,ynorm)
c
c
c
          implicit double precision(a-h,o-z)
c
          dimension yy(N)
c
          do 10 i=1,N
            yy(i)=yy(i)/ynorm
 10       continue
c
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine finishlc(Nmaxphase,icount,dphase,Nphase,xxx,yyy,
     @        iwrite)
c
c   December 3, 1999
c
c   This routine will use the symmetry of the light curve and fill out
c   the phases 180 to 360-dphase.
c   
          implicit double precision(a-h,o-z)
c
          dimension xxx(Nmaxphase),yyy(Nmaxphase)
c
          Nloop=0
          iloop=0
          i=icount-1
          Nphase=icount
          Nloop=idint(((360.0d0-dphase)-(180.0d0+dphase))/dphase)
          phase=180.0d0
c
c          do 10 phase=180.0d0+dphase,360.0d0-dphase,dphase
c
          do 10 iloop=1,Nloop+1
            phase=phase+dphase
            if(iwrite.eq.1)write(64,101)phase
            Nphase=Nphase+1
            xxx(Nphase)=phase/360.0d0
            yyy(Nphase)=yyy(i)
            i=i-1
 10       continue
c
 101      format(f6.2)
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine finishRV(istar,Nmaxphase,icount,dphase,
     &      Nphase,xxx,yyy,gamma,dRV)
c
c   December 3, 1999
c
c   This routine will use the symmetry of the velocity curve and fill out
c   the phases 180 to 360-dphase.
c   
          implicit double precision(a-h,o-z)

          parameter(pie=3.14159265358979323d0)
          dimension xxx(Nmaxphase),yyy(Nmaxphase),dRV(Nmaxphase)
c
          i=icount-1
          Nphase=icount
          Nloop=0
          iloop=0
          i=icount-1
          Nphase=icount
          Nloop=idint(((360.0d0-dphase)-(180.0d0+dphase))/dphase)
          phase=180.0d0
c
c          do 10 phase=180.0d0+dphase,360.0d0-dphase,dphase
c
          do 10 iloop=1,Nloop+1
            phase=phase+dphase
            Nphase=Nphase+1
            xxx(Nphase)=phase/360.0d0
            if(istar.eq.1)then
              dRV(Nphase)=-dRV(i)
            else
              dRV(Nphase)=-dRV(i)       
            endif
            yyy(Nphase)=-(yyy(i)-gamma)+gamma     
c
            i=i-1
 10       continue
c
          return
          end
c
c  ********************************
c
c  RVG BUG ALERT  May 9, 2001
c
c  Add the spot parameters to the argument list.
c
c
c  UPDATE August 10, 2004
c
c  Add 8 real variables and 4 integer variables to the argument list.
c
c  UPDATE May 8, 2006
c
c  add isw21-isw24, sw21-sw24, powercoeff to the list
c
c  UPDATE November 6, 2008
c
c  Add sw25-sw34 and isw25-isw34 below
c
          subroutine getinput(Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,
     @       omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,
     $       betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,
     &       Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,
     @       sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,
     @       icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,
     @       dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,
     @       sw8,sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,
     @       spot2parm,spotdparm,primmass,primK,primrad,ratrad,frac1,
     @       frac2,ecosw,temprat,idark1,idark2,isw12,isw13,isw21,isw22,
     @       isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,
     @       sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,isw25,isw26,
     @       isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,ocose,
     @       osine,omegadot,contamS0,contamS1,contamS2,contamS3,
     @       sw47,sw48,sw49)
c
          implicit double precision(a-h,o-z)
c
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @      dwavey(8,3)
c
c   RVG BUG ALERT  May 9, 2001
c
c   Dimension the spot arrays.
c
          dimension spot1parm(2,4),spot2parm(2,4),spotdparm(2,4)
          dimension powercoeff(8,9)
c
c   UPDATE June 22, 2002
c
c   Declare the variable bell to be character*1
c
          character*1 bell
c
          ios=0
          open(unit=1,file='ELC.inp',status='old',err=100,iostat=ios)
c
          read(1,*)Nalph1
          read(1,*)Nbet1
          read(1,*)Nalph2
          read(1,*)Nbet2
          read(1,*)fill1
          read(1,*)fill2
          read(1,*)omega1
          read(1,*)omega2
          read(1,*)dphase
          read(1,*)Q
          read(1,*)finc
          read(1,*)Teff1
          read(1,*)Teff2
          read(1,*)Tgrav1
          read(1,*)Tgrav2
          read(1,*)betarim
          read(1,*)rinner
          read(1,*)router
          read(1,*)tdisk
          read(1,*)xi
          read(1,*)Ntheta
          read(1,*)Nradius
          read(1,*)alb1
          read(1,*)alb2
          read(1,*)Nref
          read(1,*)rLx
          read(1,*)Period
          read(1,*)fm
          read(1,*)separ
          read(1,*)gamma
          read(1,*)t3
          read(1,*)g3
          read(1,*)SA3
          read(1,*)density
          read(1,*)sw1
          read(1,*)sw2
          read(1,*)sw3
          read(1,*)T0
          read(1,*)idraw
          read(1,*)iecheck
          read(1,*)iidint
          read(1,*)iatm
          read(1,*)ism1
          read(1,*)icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK
          read(1,*)iRVfilt
          read(1,*)isw1
          read(1,*)isw2
          read(1,*)isw3
          read(1,*)isw4
          read(1,*)ilaw
c
c  Load the limb darkening parameters. 
c         
          do 10 i=1,8
            read(1,*)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),dboly(i,2),
     %         dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
            dwavex(i,3)=dwavex(i,1)
            dwavey(i,3)=dwavey(i,1)
 10       continue
c
c  Look for additional parameters related to the eccentricity.  Use
c  the end=...  option to allow for older input files.
c
          read(1,*,end=99)ecc
          read(1,*)argper
          read(1,*)pshift
          read(1,*)sw5
          read(1,*)sw6
          read(1,*)sw7
          read(1,*)sw8
c
c   UPDATE April 8, 2002
c
c   Correct bug:  change sw5 to sw9 below
c
          read(1,*)sw9
          read(1,*)ikeep
          read(1,*)isynch
          read(1,*)isw5
          read(1,*)isw6
          read(1,*)isw7
          read(1,*)isw8
          read(1,*)isw9
c
c   May 8, 2001
c
c   Now load up parameters describing star (or disk)
c   spots.  The parameters are as follows:
c
c   spot1parm(1,1):  temperature factor for spot 1 on star 1
c   spot1parm(1,2):  latitude of spot 1 on star 1 in DEGREES
c   spot1parm(1,3):  longitude of spot 1 on star 1 in DEGREES
c   spot1parm(1,4):  angular radius of spot 1 on star 1 in DEGREES
c
c   spot1parm(2,1):  temperature factor for spot 2 on star 1
c   spot1parm(2,2):  latitude of spot 2 on star 1 in DEGREES
c   spot1parm(2,3):  longitude of spot 2 on star 1 in DEGREES
c   spot1parm(2,4):  angular radius of spot 2 on star 1 in DEGREES
c
c
c   spot2parm(1,1):  temperature factor for spot 1 on star 2
c   spot2parm(1,2):  latitude of spot 1 on star 2 in DEGREES
c   spot2parm(1,3):  longitude of spot 1 on star 2 in DEGREES
c   spot2parm(1,4):  angular radius of spot 1 on star 2 in DEGREES
c
c   spot2parm(2,1):  temperature factor for spot 2 on star 2
c   spot2parm(2,2):  latitude of spot 2 on star 2 in DEGREES
c   spot2parm(2,3):  longitude of spot 2 on star 2 in DEGREES
c   spot2parm(2,4):  angular radius of spot 2 on star 2 in DEGREES
c
c
c   spotdparm(1,1):  temperature factor for spot 1 on disk  
c   spotdparm(1,2):  azimuth of spot 1 on disk in DEGREES
c   spotdparm(1,3):  radial cutoff for spot 1 on disk (between 0 and 1)
c   spotdparm(1,4):  angular size of spot 1 on disk in DEGREES
c
c   spotdparm(2,1):  temperature factor for spot 2 on disk  
c   spotdparm(2,2):  azimuth of spot 2 on disk in DEGREES
c   spotdparm(2,3):  radial cutoff for spot 2 on disk (between 0 and 1)
c   spotdparm(2,4):  angular size of spot 2 on disk in DEGREES
c
c   If there is an error, abort, setting ispot=0
c
          ios=0
          read(1,*,end=101,err=101)spot1parm(1,1)
          read(1,*,end=101,err=101)spot1parm(1,2)
          read(1,*,end=101,err=101)spot1parm(1,3)
          read(1,*,end=101,err=101)spot1parm(1,4)
c              
          read(1,*,end=101,err=101)spot1parm(2,1)
          read(1,*,end=101,err=101)spot1parm(2,2)
          read(1,*,end=101,err=101)spot1parm(2,3)
          read(1,*,end=101,err=101)spot1parm(2,4)
c              
c              
          read(1,*,end=101,err=101)spot2parm(1,1)
          read(1,*,end=101,err=101)spot2parm(1,2)
          read(1,*,end=101,err=101)spot2parm(1,3)
          read(1,*,end=101,err=101)spot2parm(1,4)
               
          read(1,*,end=101,err=101)spot2parm(2,1)
          read(1,*,end=101,err=101)spot2parm(2,2)
          read(1,*,end=101,err=101)spot2parm(2,3)
          read(1,*,end=101,err=101)spot2parm(2,4)
c              
c              
          read(1,*,end=101,err=101)spotdparm(1,1)
          read(1,*,end=101,err=101)spotdparm(1,2)
          read(1,*,end=101,err=101)spotdparm(1,3)
          read(1,*,end=101,err=101)spotdparm(1,4)
               
          read(1,*,end=101,err=101)spotdparm(2,1)
          read(1,*,end=101,err=101)spotdparm(2,2)
          read(1,*,end=101,err=101)spotdparm(2,3)
          read(1,*,end=101,err=101)spotdparm(2,4)
c
c   UPDATE August 10, 2004
c
c   Add the new variables here.  Abort if there is an error
c
          read(1,*,end=101,err=101)primmass
          read(1,*,end=101,err=101)primK
          read(1,*,end=101,err=101)primrad
          read(1,*,end=101,err=101)ratrad
          read(1,*,end=101,err=101)frac1
          read(1,*,end=101,err=101)frac2
          read(1,*,end=101,err=101)ecosw
          read(1,*,end=101,err=101)temprat
          read(1,*,end=101,err=101)idark1
          read(1,*,end=101,err=101)idark2
          read(1,*,end=101,err=101)isw12
          read(1,*,end=101,err=101)isw13
c
c   UPDATE May 8, 2006
c
c   Add new variables here.  Abort if there is an error.
c
          read(1,*,end=101,err=101)isw21
          read(1,*,end=101,err=101)isw22
          read(1,*,end=101,err=101)isw23
          read(1,*,end=101,err=101)isw24
c
c   Power-series limb darkening coefficients for star 1
c
          read(1,*,end=101,err=101)(powercoeff(1,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(2,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(3,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(4,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(5,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(6,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(7,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(8,k),k=1,9)
c
          read(1,*,end=101,err=101)bigI
          read(1,*,end=101,err=101)bigbeta
          read(1,*,end=101,err=101)sw23
          read(1,*,end=101,err=101)sw24
c
c   UPDATE November 6, 2008
c
c   Add sw25-sw34 and isw25-isw34 below
c
          read(1,*,end=101,err=101)sw25
          read(1,*,end=101,err=101)sw26
          read(1,*,end=101,err=101)sw27
          read(1,*,end=101,err=101)sw28
          read(1,*,end=101,err=101)sw29
          read(1,*,end=101,err=101)sw30
          read(1,*,end=101,err=101)contam
          read(1,*,end=101,err=101)Tconj
          read(1,*,end=101,err=101)beam1
          read(1,*,end=101,err=101)beam2

          read(1,*,end=101,err=101)isw25
          read(1,*,end=101,err=101)isw26
          read(1,*,end=101,err=101)isw27
          read(1,*,end=101,err=101)isw28
          read(1,*,end=101,err=101)isw29
          read(1,*,end=101,err=101)isw30
          read(1,*,end=101,err=101)isw31
          read(1,*,end=101,err=101)isw32
          read(1,*,end=101,err=101)isw33
          read(1,*,end=101,err=101)isw34
          read(1,*,end=101,err=101)ocose
          read(1,*,end=101,err=101)osine
          read(1,*,end=101,err=101)omegadot
          read(1,*,end=101,err=101)contamS0
          read(1,*,end=101,err=101)contamS1
          read(1,*,end=101,err=101)contamS2
          read(1,*,end=101,err=101)contamS3
          read(1,*,end=101,err=101)sw47
          read(1,*,end=101,err=101)sw48
          read(1,*,end=101,err=101)sw49

 99       close(1)
c
c   Come here if the input file ELC.inp does not exist.  The subroutine
c   writeinput will make the correct file and set default values.
c
c   RVG BUG ALERT  May 9, 2001
c
c   Update the writeinput routine to include the spot parameters
c
c
c   UPDATE August 10, 2004
c
c   Add 8 real variables and 4 integer variables to the argumemt list
c
 100      if(ios.gt.0)call writeinput(Nalph1,Nbet1,Nalph2,Nbet2,
     $       fill1,fill2,omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,
     @       Tgrav2,betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,
     @       alb2,Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,
     @       sw2,sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,
     @       icnR,icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,
     @       wave,dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,
     @       sw7,sw8,sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,
     @       spot1parm,spot2parm,spotdparm,primmass,primK,primrad,
     @       ratrad,frac1,frac2,ecosw,temprat,idark1,idark2,isw12,isw13,
     &       isw21,isw22,isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,
     %       sw25,sw26,sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,
     @       isw25,isw26,isw27,isw28,isw29,isw30,isw31,isw32,isw33,
     @       isw34,ocose,osine,omegadot,contamS0,contamS1,contamS2,
     @       contamS3,sw47,sw48,sw49)
c
c   Put this if-then block for successful completion.
c
          if(ios.eq.0)then 
            close(1)
            return
          endif

 101      bell=char(7)   !file ended too soon
          write(*,1002)bell
          close(1)
c
 1002     format(a1,'Error:  Bad entry in ELC.inp')
c
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&
c
c
c   RVG BUG ALERT  May 9, 2001
c
c   Update the writeinput routine to include the spot parameters
c
c   UPDATE August 10, 2004
c
c   Add the 8 real variables and 4 integers to the argument list.
c    
c   UPDATE May 8, 2006
c
c   Add isw21-isw24, sw21-sw24, powercoeff to argument list
c
c   UPDATE November 6, 2008
c
c   Add sw25-sw34 and isw25-isw34 to the list
c
          subroutine writeinput(Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,
     @      omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,
     @      betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,
     @      Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,
     @      sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,
     @      icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,
     @      dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,
     @      sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,
     @      spot2parm,spotdparm,primmass,primK,primrad,ratrad,frac1,
     @      frac2,ecosw,temprat,idark1,idark2,isw12,isw13,isw21,isw22,
     @      isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,
     @      sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,isw25,isw26,
     @      isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,ocose,osine,
     @      omegadot,contamS0,contamS1,contamS2,contamS3,sw47,sw48,sw49)
c
c
c    will write the correctly formatted file ELC.inp and return
c    default parameters
c
          implicit double precision(a-h,o-z)
c
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @       dwavey(8,3),www(8)
          dimension powercoeff(8,9)
          character*1 bell
c
c   RVG BUG ALERT  May 9, 2001
c
c   Dimension the spot arrays.
c
          dimension spot1parm(2,4),spot2parm(2,4),spotdparm(2,4)
c
          data www/3600.0,4500.0,5550.0,6700.0,8700.0,12000.0,16200.0,
     @       22000.0/
c
          bell=char(7)
          write(*,100)bell
c
          Nalph1=40
          Nbet1=14
          Nalph2=40
          Nbet2=14
          fill1=1.00d0
          fill2=0.005d0
          omega1=1.0d0
          omega2=1.0d0
          dphase=3.0d0
          Q=2.0d0
          finc=80.0d0
          Teff1=6500.0d0
          Teff2=6500.0d0
          Tgrav1=0.25d0
          Tgrav2=0.25d0
          betarim=2.0d0
          rinner=0.005d0
          router=0.75d0
          tdisk=30000.0d0
          xi=-0.75d0
          Ntheta=90
          Nradius=60
          alb1=1.0d0
          alb2=1.0d0
          Nref=1
          rLx=0.001d0
          Period=2.62d0
          fm=3.0d0
          separ=5.0d0
          gamma=50.0d0
          idraw=0
          iecheck=1
          iidint=1
          iatm=0
          ism1=1
          isw2=0
          ilaw=1
          icnU=1
          icnB=1
          icnV=1
          icnR=1
          icnI=1
          icnJ=1
          icnH=1
          icnK=1
          t3=-5000.0d0
          g3=-5.0d0
          SA3=-0.1d0
          density=0.0d0
          sw1=0.0d0
          sw2=0.0d0
          sw3=0.0d0
          T0=0.0d0
          iRVfilt=3
          isw1=0
          isw2=0
          isw3=0
          isw4=0
          isw5=0
          isw6=0
          isw7=0
          isw8=0
          isw9=0
          ikeep=0
          isynch=0
          ecc=0.0d0
          argper=90.0d0
          pshift=0.0d0
          sw5=0.0d0
          sw6=0.0d0
          sw7=0.0d0
          sw8=0.0d0
          sw9=0.0d0
c
          do 5 i=1,8
            wave(i)=www(i)
            dbolx(i,1)=0.635d0
            dbolx(i,2)=0.635d0
            dboly(i,1)=0.242d0
            dboly(i,2)=0.242d0
 5        continue
c
          do 6 i=1,4
            do 7 j=1,2
              spot1parm(j,i)=-1.0d0
              spot2parm(j,i)=-1.0d0
              spotdparm(j,i)=-1.0d0
 7          continue
 6        continue
c
c   UPDATE August 10, 2004
c 
c   Initialize the new variables to zero.
c
          primmass=0.0d0
          primK=0.0d0
          primrad=0.0d0
          ratrad=0.0d0
c
          frac1=0.0d0
          frac2=0.0d0
          ecosw=0.0d0
          temprat=0.0d0
c
          idark1=0
          idark2=0
          isw12=0
          isw13=0
c
c  UPDATE May 8, 2006
c
c  Add defaults for new variables here.
c
          isw21=0
          isw22=0
          isw23=0
          isw24=0
          bigI=0.0d0
          bigbeta=0.0d0
          sw23=0.0d0
          sw24=0.0d0
c
c    UPDATE November 6, 2008
c
c    Add values for sw25-sw34 and isw25-isw34 below
c
          sw25=0.0d0
          sw26=0.0d0
          sw27=0.0d0
          sw28=0.0d0
          sw29=0.0d0
          sw30=0.0d0
          contam=0.0d0
          Tconj=0.0d0
          beam1=0.0d0
          beam2=0.0d0

          isw25=0
          isw26=0
          isw27=0
          isw28=0
          isw29=0
          isw30=0
          isw31=0
          isw32=0
          isw33=0
          isw34=0
c
          ocose=0.0d0
          osine=0.0d0
          omegadot=0.0d0
          contamS0=0.0d0
          contamS1=0.0d0
          contamS2=0.0d0
          contamS3=0.0d0
          sw47=0.0d0
          sw48=0.0d0
          sw49=0.0d0

c
          open(unit=1,file='ELC.inp',status='unknown')
c
          write(1,1000)Nalph1
          write(1,1001)Nbet1
          write(1,1002)Nalph2
          write(1,1003)Nbet2
          write(1,1004)fill1
          write(1,1005)fill2
          write(1,1006)omega1
          write(1,1007)omega2
          write(1,1008)dphase
          write(1,1009)Q
          write(1,1010)finc
          write(1,1011)Teff1
          write(1,1012)Teff2
          write(1,1013)Tgrav1
          write(1,1014)Tgrav2
          write(1,1015)betarim
          write(1,1016)rinner
          write(1,1017)router
          write(1,1018)tdisk
          write(1,2018)xi
          write(1,1019)Ntheta
          write(1,1020)Nradius
          write(1,1042)alb1
          write(1,1043)alb2
          write(1,2043)Nref
          write(1,1021)rLx
          write(1,1023)Period
          write(1,1024)fm
          write(1,1025)separ
          write(1,4025)gamma
          write(1,5000)t3
          write(1,5001)g3
          write(1,5002)SA3
          write(1,5003)density
          write(1,5004)sw1
          write(1,5005)sw2
          write(1,5006)sw3
          write(1,5007)T0
          write(1,1026)idraw
          write(1,1027)iecheck
          write(1,1028)iidint
          write(1,4000)iatm
          write(1,4001)ism1
          write(1,4002)icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK
          write(1,5008)iRVfilt
          write(1,5009)isw1
          write(1,5010)isw2
          write(1,5011)isw3
          write(1,5012)isw4
          write(1,3028)ilaw
c
          do 10 i=1,8
            write(1,2000)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),
     @        dboly(i,2),dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
 10       continue
c
          write(1,6000)ecc
          write(1,6001)argper
          write(1,6002)pshift
          write(1,6003)sw5
          write(1,6004)sw6
          write(1,6005)sw7
          write(1,6006)sw8
          write(1,6007)sw9
          write(1,6008)ikeep
          write(1,6009)isynch
          write(1,6010)isw5
          write(1,6011)isw6
          write(1,6012)isw7
          write(1,6013)isw8
          write(1,6014)isw9
c
          write(1,2001)spot1parm(1,1)
          write(1,2002)spot1parm(1,2)
          write(1,2003)spot1parm(1,3)
          write(1,2004)spot1parm(1,4)
c                     
          write(1,2005)spot1parm(2,1)
          write(1,2006)spot1parm(2,2)
          write(1,2007)spot1parm(2,3)
          write(1,2008)spot1parm(2,4)
c                     
c                     
          write(1,2009)spot2parm(1,1)
          write(1,2010)spot2parm(1,2)
          write(1,2011)spot2parm(1,3)
          write(1,2012)spot2parm(1,4)
                      
          write(1,2013)spot2parm(2,1)
          write(1,2014)spot2parm(2,2)
          write(1,2015)spot2parm(2,3)
          write(1,2016)spot2parm(2,4)
c                     
c                     
          write(1,2017)spotdparm(1,1)
          write(1,22018)spotdparm(1,2)
          write(1,2019)spotdparm(1,3)
          write(1,2020)spotdparm(1,4)
                      
          write(1,2021)spotdparm(2,1)
          write(1,2022)spotdparm(2,2)
          write(1,2023)spotdparm(2,3)
          write(1,2024)spotdparm(2,4)
c
c   UPDATE August 10, 2004
c
c   Write out the 8 real and 4 new integer variables here.
c
          write(1,2025)primmass
          write(1,2026)primK
          write(1,2027)primrad
          write(1,2028)ratrad
c
          write(1,2030)frac1
          write(1,2031)frac2
          write(1,2032)ecosw
          write(1,2033)temprat
c
          write(1,2040)idark1
          write(1,2041)idark2
          write(1,2042)isw12
          write(1,3043)isw13
c
          write(1,8001)isw21
          write(1,8002)isw22
          write(1,8003)isw23
          write(1,8004)isw24
c
8001      format(i1,19x,'ialign (0 for rotation aligned with orbit)')
8002      format(i1,19x,'ifastgen (1 for fast genetic mode)')
8003      format(i1,19x,'iwriteeclipse (1 to fit for eclipse times)')         
8004      format(i1,19x,
     @           'frac switch (>1 to enable ELCratio.???? files)')    
c
          do 85000 kk=1,8
            write(1,85001)(powercoeff(kk,jj),jj=1,9)
85000     continue
c
85001      format(9(f8.5,1x))
c
          write(1,8011)bigI
          write(1,8012)bigbeta
          write(1,8013)sw23
          write(1,8014)sw24
c
8011      format(f11.7,9x,'axis_I (inclination of rotation axis if ialign=1)')
8012      format(f11.7,9x,'axis_beta (angle of rotation axis wrt to orbit if',
     @      ' ialign=1)')          
8013      format(f15.7,5x,'t_start')
8014      format(f15.7,5x,'t_end')         
c
          write(1,8025)sw25
          write(1,8026)sw26
          write(1,8027)sw27
          write(1,8028)sw28
          write(1,8029)sw29
          write(1,8030)sw30
          write(1,8031)contam
          write(1,8032)Tconj
          write(1,8033)beam1
          write(1,8034)beam2

          write(1,9025)isw25
          write(1,9026)isw26
          write(1,9027)isw27
          write(1,9028)isw28
          write(1,9029)isw29
          write(1,9030)isw30
          write(1,9031)isw31
          write(1,9032)isw32
          write(1,9033)isw33
          write(1,9034)isw34
c
          write(1,8040)ocose
          write(1,8041)osine
          write(1,8042)omegadot
          write(1,8043)contamS0
          write(1,8044)contamS1
          write(1,8045)contamS2
          write(1,8046)contamS3
          write(1,8047)sw47
          write(1,8048)sw48
          write(1,8049)sw49

8025      format(f10.7,9x,'asini error')         
8026      format(f10.8,10x,'reference phase for disk fraction')
8027      format(f10.8,10x,
     $        'radfill1 (set to use fill1 in terms of R_eff')
8028      format(f10.8,10x,
     $         'radfill2 (set to use fill2 in terms of R_eff')
8029      format(f10.4,10x,'bin size for light curves (minutes)')
8030      format(f10.4,10x,'bin size for RV curves (minutes)')
8031      format(f9.7,11x,'Kepler contamination')
8032      format(f15.8,5x,'Tconj')
8033      format(f4.2,16x,'beam1 (Doppler boost factor, star 1')
8034      format(f4.2,16x,'beam2 (Doppler boost factor, star 2)')

9025      format(i1,19x,'X-ray foreshortening switch',
     @       ' (1 for point source)')
9026      format(i1,19x,'iGR (1 for GR, 2 for tidal, 3 for both)')
9027      format(i6,14x,'Nterms for fast analytic')
9028      format(i1,19x,'set to 1 to fit for Tconj')
9029      format(i1,19x,'set to 1 to fit for e*sin(omega), e*cos(omega)')
9030      format(i1,19x,'body 3 switch')
9031      format(i1,19x,'Ngap')
9032      format(i16,4x,'jdum (seed for markovELC, geneticELC, ',
     @          'randomELC)')
9033      format(i1,19x,'mandel  (0 for Gimenez, 1 for Mandel & Agol)')
9034      format(i1,19x,'Iseason (1 for seasonal Kepler contamination)')

 8040     format(f12.8,8x,'e*cos(omega)')
 8041     format(f12.8,8x,'e*sin(omega)')
 8042     format(f12.8,8x,'omega_dot (degrees per year)')
 8043     format(f12.8,8x,'contamS0 (season 0 contamination, tag s0)')
 8044     format(f12.8,8x,'contamS1 (season 1 contamination, tag s1)')
 8045     format(f12.8,8x,'contamS2 (season 2 contamination, tag s2)')
 8046     format(f12.8,8x,'contamS3 (season 3 contamination, tag s3)')
 8047     format(f16.8,4x,'Tref for dynamical integrator')
 8048     format(f12.8,8x,'threshold to write chi^2')
 8049     format(f12.8,8x,'sw49 (currently inactive)')
c
 2025     format(f13.9,7x,'primmass (star 1 mass in solar masses)')
 2026     format(f14.9,6x,'primK (K-velocity of star 1 in km/sec)')
 2027     format(f14.9,6x,'primrad (star 1 radius in solar radii)')
 2028     format(f16.9,4x,
     &          'ratrad (ratio of star 1 radius and star 2 radius)')
c
 2030     format(f4.2,16x,'frac1 (fractional radius star 1: R_1/a)')
 2031     format(f4.2,16x,'frac2 (fractional radius star 2: R_2/a)')
 2032     format(f12.9,8x,'ecosw (phase difference between eclipses)')
 2033     format(f10.7,10x,'temprat (T_1/T_2)')
c
 2040     format(i1,19x,'idark1')
 2041     format(i1,19x,'idark2')
 2042     format(i6,14x,'Npoly (0 for numerical)')
 3043     format(i1,19x,'ifasttrans (>0 for fast transit mode)')

          close(1)
c
 100      format(a1,'I can''t find the file ''ELC.inp''!  I''m making',
     $     ' one up and setting default values')
c
 1000     format(i2,18x,'Nalph1')
 1001     format(i2,18x,'Nbet1')
 1002     format(i2,18x,'Nalph2')
 1003     format(i2,18x,'Nbet2')
 1004     format(f6.4,14x,'fill1')
 1005     format(f6.4,14x,'fill2')
 1006     format(f7.2,13x,'omega1')
 1007     format(f7.2,13x,'omega2')
 1008     format(f4.2,16x,'dphase')
 1009     format(f4.2,16x,'Q')
 1010     format(f5.2,15x,'finc')
 1011     format(f6.1,14x,'Teff1')
 1012     format(f6.1,14x,'Teff2')
 1013     format(f4.2,16x,'Tgrav1')
 1014     format(f4.2,16x,'Tgrav2')
 1015     format(f4.2,16x,'betarim')
 1016     format(f5.3,15x,'rinner')
 1017     format(f4.2,16x,'router')
 1018     format(f7.1,13x,'tdisk')
 2018     format(f7.4,13x,'xi')
 1019     format(i3,17x,'Ntheta')
 1020     format(i3,17x,'Nradius')
c
c   UPDATE March 26, 2002
c
c   The variable rLx now means the log10 of the X-ray luminosity.
c
c 1021     format(f10.5,10x,'Lx/Lopt')
 1021     format(f10.5,10x,'log10(Lx)')
 1023     format(f8.6,12x,'Period')
 1024     format(f5.3,15x,'fm')
 1025     format(f5.3,15x,'separ')
 1026     format(i1,19x,'idraw')
 1027     format(i1,19x,'iecheck')
 1028     format(i1,19x,'iidint')
 1042     format(f6.4,14x,'alb1')
 1043     format(f6.4,14x,'alb2')
 2043     format(i1,19x,'Nref')
 2000     format(f7.1,3x,8(f7.4,1x))
 3028     format(i2,18x,'ilaw  (1=linear law, 2=logarithmic law,',
     %           ' 3=square root law, 4=quad law, >10 for power series)')
 4025     format(f7.2,13x,'gamma velocity (km/sec)')
 4000     format(i1,19x,'iatm  (0 for BB, 1 for model atmospheres)')
 4001     format(i1,19x,'ism1  (0 for all phases, 1 for 0-180)')
 4002     format(8(i1,1x),4x,'icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK')
 5000     format(f10.2,10x,'t3')
 5001     format(f5.2,15x,'g3')
 5002     format(f12.6,8x,'SA3')
 5003     format(f12.6,8x,'density in g/cc')
 5004     format(f12.6,8x,'onephase')
 5005     format(f12.6,8x,'usepot1')
 5006     format(f12.6,8x,'usepot2')
 5007     format(f12.6,8x,'T0')
 5008     format(i1,19x,'iRVfilt')
 5009     format(i1,19x,'ionephase')
 5010     format(i1,19x,'isquare')
 5011     format(i1,19x,'iusepot')
 5012     format(i1,19x,'ifixgamma')
 6000     format(f10.8,10x,'eccentricity')
 6001     format(f13.8,7x,'argument of peristron in degrees')
 6002     format(f11.8,9x,'pshift')
c
c   UPDATE April 8, 2002
c
c   Change the format statement below
c
 6003     format(f12.6,8x,'asini (projected semimajor axis in seconds)')
c
c   UPDATE May 27, 2002
c
c   Change this format statement.
c
 6004     format(f12.6,8x,'median fit (geneticELC only)')
 6005     format(f12.6,8x,'sw7 (phase range when sw8>sw7>0)')
 6006     format(f12.6,8x,'sw8 (phase range when sw8>sw7>0)')
 6007     format(f12.6,8x,'time step when itime=2')
 6008     format(i1,19x,'ikeep (1 to put eclipse at phase 0.0)')
 6009     format(i1,19x,'isynch (1 to keep rotation synchronous',
     $         ' at periastron)')
c
c   RVG BUG ALERT  May 8, 2001
c
c   Change these two format statements.
c
 6010     format(i1,19x,'ispotprof')
 6011     format(i1,19x,'igrav')
c
c   END BUG
c
 6012     format(i1,19x,'itime')
c
c  UPDATE JULY 4, 2004
c
c  The variable isw8 will be assigned to MonteCarlo, which
c  will be used to determine the number of Monte Carlo
c  integrations done on the pixels.
c
 6013     format(i6,14x,'MonteCarlo (0 for interpolation, >10 ',
     $        'for Monte Carlo)')
 6014     format(i6,14x,'ielite')
c
c  RVG BUG ALERT  May 9, 2001
c
c  Add these format statements.
c
 2001     format(f10.7,10x,'Temperature factor spot 1, star 1')
 2002     format(f11.7, 9x,'Latitude of spot 1, star 1 (degrees)') 
 2003     format(f11.7, 9x,'Longitude of spot 1, star 1 (degrees)') 
 2004     format(f11.7, 9x,'Angular radius of spot 1, star 1 (degrees)') 

 2005     format(f10.7,10x,'Temperature factor spot 2, star 1')
 2006     format(f11.7, 9x,'Latitude of spot 2, star 1 (degrees)') 
 2007     format(f11.7, 9x,'Longitude of spot 2, star 1 (degrees)') 
 2008     format(f11.7, 9x,'Angular radius of spot 2, star 1 (degrees)') 

 2009     format(f10.7,10x,'Temperature factor spot 1, star 2')
 2010     format(f11.7, 9x,'Latitude of spot 1, star 2 (degrees)') 
 2011     format(f11.7, 9x,'Longitude of spot 1, star 2 (degrees)') 
 2012     format(f11.7, 9x,'Angular radius of spot 1, star 2 (degrees)') 

 2013     format(f10.7,10x,'Temperature factor spot 2, star 2')
 2014     format(f11.7, 9x,'Latitude of spot 2, star 2 (degrees)') 
 2015     format(f11.7, 9x,'Longitude of spot 2, star 2 (degrees)') 
 2016     format(f11.7, 9x,'Angular radius of spot 2, star 2 (degrees)') 

 2017     format(f10.7,10x,'Temperature factor spot 1, disk')
22018     format(f11.7, 9x,'Azimuth of spot 1, disk (degrees)') 
 2019     format(f11.7, 9x,
     $        'Radial cutoff of spot 1, disk (0 <= r_cut <=1)') 
 2020     format(f11.7, 9x,'Angular size of spot 1, disk (degrees)') 

 2021     format(f10.7,10x,'Temperature factor spot 2, disk')
 2022     format(f11.7, 9x,'Azimuth of spot 2, disk (degrees)') 
 2023     format(f11.7, 9x,
     $           'Radial cutoff of spot 2, disk (0 <= r_cut <=1)') 
 2024     format(f11.7, 9x,'Angular size of spot 2, disk (degrees)') 
c

          return
          end
c
c   &&&&&&&&&&
c
          SUBROUTINE POTEN(Q,omega,x,y,z,psi,psix,psixx,psiy,psiz,istar,
     @       bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
c
c   October 6, 1999
c
c   Here is the subroutine from the original Avni code.  It computes
c   the potential (given Q and x,y,z) and various gradients.
c
c   February 15, 2000
c
c   The iflag is added because the potential computation needs to be
c   modified in some cases, specifically when star 2 is not synchronous.
c
c   UPDATE November 13, 2009
c
c   Add an option to use the potential computed from the equilibrium
c   tide approximation.   The flag itide will be the order of the polynomial
c   expansion.
c
c   UPDATE January 24, 2011
c
c   Add in the Hut factor to Omega
c
c   UPDATE February 16, 2011
c
c   Modify for misaligned spin axis
c
          implicit double precision(a-h,o-z)
c
          dimension pn(0:100),pd(0:100)
          parameter(pie=3.141592653589793d0)

          hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))

          omegah=omega*hutfac 
          if(itide.lt.2)then
            RST = DSQRT(X**2 + Y**2 + Z**2)     !dist. from center of 2ndary
            RX = DSQRT((X-bdist)**2 + Y**2 + Z**2)!dist. from center of primary
            A = ((1.0d0+Q)/2.0d0) * OMEGAH**2
            RST3 = RST*RST*RST
            RX3 = RX*RX*RX
c
            if((thetamis.eq.0.0d0).and.(phimis.eq.0.0d0))then
              term1=X*X
              term2=Y*Y
              term3=0.0d0
              term4=0.0d0
              term5=0.0d0
              term6=0.0d0              
              cpm=1.0d0
              spm=0.0d0
              stm=0.0d0
              s2pm=0.0d0
              s2tm=0.0d0
            else
              cpm=dcos(phimis)
              spm=dsin(phimis)
              stm=dsin(thetamis)
              s2pm=dsin(2.0d0*phimis)
              s2tm=dsin(2.0d0*thetamis)                   
              term1=X*X*(1.0d0-cpm*cpm*stm*stm)
              term2=Y*Y*(1.0d0-spm*spm*stm*stm)
              term3=Z*Z*stm*stm
              term4=-X*Y*stm*stm*s2pm
              term5=-X*Z*cpm*s2tm
              term6=-Y*Z*spm*s2tm
            endif
            PSI = 1.0d0/RST + Q/RX - Q*X/bdist/bdist 
     @       + A*(term1+term2+term3+term4+term5+term6) 
c
            dterm1=2.0d0*X*(1.0d0-cpm*cpm*stm*stm)
            dterm2=-Y*stm*stm*s2pm
            dterm3=-Z*cpm*s2tm
            PSIX = -X/RST3 - Q*(X-bdist)/RX3 -Q/bdist/bdist 
     @           + A*(dterm1+dterm2+dterm3)
            if(istar.eq.2)then
c               PSIX = -X/RST3 - Q*(X-1.0d0)/RX3 - 2.0d0*A*(1.0d0-X) 
c     @            +1.0d0/bdist/bdist  
               PSIX = -X/RST3 - Q*(X-bdist)/RX3 - 2.0d0*A + 
     @            A*(dterm1+dterm2+dterm3) 
     @            +1.0d0/bdist/bdist  
            endif
c
            
            dterm1=2.0d0*Y*(1.0d0-spm*spm*stm*stm)
            dterm2=-X*stm*stm*s2tm
            dterm3=-Z*spm*s2tm
            PSIY = -Y/RST3 - Q*Y/RX3   + A*(dterm1+dterm2+dterm3)
c
            dterm1=2.0d0*Z*stm*stm
            dterm2=-X*cpm*s2tm
            dterm3=-Y*spm*s2tm
            PSIZ = -Z/RST3 - Q*Z/RX3 +A*(dterm1+dterm2+dterm3)
c
            RST5 = RST3*RST*RST
            RX5 = RX3*RX*RX
            dterm1=2.0d0*(1.0d0-cpm*cpm*stm*stm)
            PSIXX = -1.0d0/RST3 + 3.0d0*X**2/RST5 
     $        -Q/RX3 + (3.0d0*Q*(X-bdist)**2)/RX5 +A*dterm1
 
            RETURN
          endif
c
          tider=pie*tidephi/180.0d0
          psicos=cox*dcos(tider)+coy*dsin(tider)


c
          rr=x*x+y*y+z*z
          w1=(dsqrt(rr))**3
          w1=1.0d0/w1
c
          psi=1.0d0/dsqrt(rr)+Q
          psix=-x*w1
          psiy=-y*w1
          psiz=-z*w1
          psixx=w1*(3.0d0*x*x/rr-1.0d0)
c

          call lpn(itide,psicos,pn,pd)
          do 10 ii=2,itide
            t1=-Q*rr**(0.5d0*dble(ii))*pn(ii)
            psi=psi+t1
            twx=dble(ii)*x*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
            twy=dble(ii)*y*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
            twz=dble(ii)*z*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
            txx=Q*pn(ii)*(rr)**(0.5d0**dble(ii)-1)
            txx=txx*(2.0d0*x*x*(0.5d0*dble(ii)-1.0d0)/rr+dble(ii))
            psix=psix+twx
            psiy=psiy+twy
            psiz=psiz+twz
            psixx=psixx+txx
 10       continue
c
          RETURN
          END
c
c  %%%%%%%%%%%%%%%%%%%%%%%
c
c  UPDATE September 11, 2001
c
c  Add the iverb flag to the argument list.  If iverb=1, then don't write
c  to unit 2.
c
c  UPDATE September 21, 2008
c
c  Add sw5 to the argument list
c
          subroutine setupgeo(istar,ialphmax,ibetmax,
     $      Nalph,Nbet,ibetlim,fill,omega,Q,finc,
     $      xarray,yarray,zarray,
     %      surf,radarray,gradx,grady,gradz,garray,
     $      xend,separation,Tgrav,Teff,reff,Rl,Tpole,Rpol,Regg,sarea,pot,
     $      gpole,phiar,isquare,iusepot,usepot,ivrt,pervol,fillper,bdist,
     $      potsum,iverb,mmdx,primmass,primK,primrad,ratrad,frac1,frac2,
     &      ecc,period,size1,sw5,tteff2,density,
     @      tidephi,itide,phistart,thetamis,phimis)
c
c
c
c   October 6, 1999
c
c   This subroutine will return the radii and surface coordinates
c   for star 1 or 2:
c
c   xarray, yarray, zarray, surf, gradx, grady, gradz, radarray, garray
c
c   The two element array xend will contain the x-coordinates of the
c   two points along the x-axis.  The gradx term is +1 at positive x-axis
c   and -1 at negative x-axis.
c
c   istar is the flag to identify which star is being computed.  If
c   istar=2, then we need to flip the mass ratio.
c
c   February 15, 2000
c
c   I have added 'dummy' arguments for the x-gradient, gravity, and surface
c   elements.  When star 2 has non-synchronous rotation, the form of the
c   x derivative of the potential needs to be modified.  This modified
c   form is only  needed for the reflection effect.  The computation of
c   the light curve is otherwise OK with the standard gradients.
c
c   ********removed May 11, 2000*************
c
c   May 4, 2000
c
c   Change the distribution of grid points. Use a normal polar coordinate
c   scheme.
c
c   ************************
c
c   February 5, 2001
c
c   Generalize to eccentric orbits.  Need extra parameters:
c
c   ivrt=0, normal mode,  
c   ivrt=1, find the filling so that the volume is equal to pervol
c   fillper is the filling factor at periastron   
c
c   UPDATE August 12, 2004
c
c   Add the arguments frac1,frac2,ratrad, etc. to the argument list.
c   These are the fractional radii, and the ratio of the radii.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0,twopie=pie+pie)
          dimension xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     $      zarray(ialphmax*ibetmax),surf(ialphmax*ibetmax),
     &      gradx(ialphmax*ibetmax),xend(4),ibetlim(ialphmax),
     $      grady(ialphmax*ibetmax),gradz(ialphmax*ibetmax),
     %      radarray(ialphmax*ibetmax),garray(ialphmax*ibetmax),
     $      Rpol(ialphmax),phiar(ialphmax*ibetmax)
          dimension mmdx(ialphmax,ibetmax),phistart(ialphmax)
c
c   UPDATE January 11, 2010
c
c   Add a random offset to the phi coordinates in each ialf row.  This
c   will reduce the noise in high precision curves.  We need the sobel
c   sequence for this.
c
          dimension xsob(2)
c
          
          if(ialphmax.lt.Nalph)then
            write(*,*)'Error:  make Nalphmax greater than ',
     @         Nalph,' for star ',istar
            stop
          endif
          if(ibetmax.lt.1+4*Nbet)then
            write(*,*)'Error:  make ibetmax greater than ',
     @         1+4*Nbet,' for star ',istar
            stop
          endif
c
c   UPDATE December 21, 2008
c
c   Add this routine if radfill is given.  radfill defines the filling factor
c   in terms of the effective radius.  Adjust fill1 and fill2 accordingly
c
c   UPDATE October 10, 2008
c
c   Add this new call to the routine that sets the mass ratio given
c   the density and fill factor of star 1.
c
          if((istar.eq.1).and.(frac1.le.0.0d0).and.(primmass.le.0.0d0)
     @       .and.(density.gt.0.0d0).and.(primrad.le.0.0d0))then
            call setdensity(fill,omega,bdist,Q,period,density,tidephi,
     %      itide,ecc,thetamis,phimis)
          endif
c
c
c  UPDATE August 12, 2004
c
c  If istar=1 and IVRT=0, set the separation and Q depending
c  on the values of primmass and primK.
c
          if(istar.eq.1.and.ivrt.eq.0)then
            call setscale(Q,finc,tteff2,Period,separation,
     &         primmass,primK,primrad,sw5,ecc)
          endif
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
c   Set up the grid on the star, define step size and number of steps.
c
          dtheta=pie/dble(Nalph)
c
c   Initialize the bisection limits.
c
          fbig=fillper
          fsmall=0.0d-8
          fnew=0.5d0*(fbig+fsmall)
c
c   First, find the distance to L1.
c
          call findL1(overQ,omega,x0,1,bdist,tidephi,
     &        ecc,thetamis,phimis)       
          Rl=x0                           !save the L1 distance
c
          x=x0
          y=0.0d0
          z=0.0d0
          cox=1.0d0
          coy=0.0d0
          call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,bdist,
     @        cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          critpsi=psi
c
c
c  If primrad=0, then we can adjust the filling factors to
c  get fractional radii.
c
          if((istar.eq.1).and.(ivrt.eq.0).and.frac1.gt.0.0d0)then
             call findradius(overQ,omega,savepsi0,x0,bdist,reff,
     &           tidephi,itide,ecc,thetamis,phimis)
             bigfrac=reff
             if(frac1.gt.bigfrac)then
               fill=1.0d0
               size1=reff
               write(2,665)
               go to 666
 665           format('Warning:  frac1 exceeds Roche radius. ',
     $           ' Setting fill1=1.0')
             endif
c
c   Presumably the Roche lobe has a fractional radius large than the
c   requested fractional radius.  Use bisection to find the filling
c   factor fill1.
c
             aa=0.0d0
             bb=1.0d0
             y=0.0d0
             z=0.0d0
             do 664 i=1,60
               fff=(aa+bb)*0.5d0
               call POTEN(overQ,omega,x0*fff,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
               call findradius(overQ,omega,psi,x0*fff,bdist,reff,
     @             tidephi,itide,ecc,thetamis,phimis)
               if(frac1.ge.reff)then
                 aa=fff
               else
                 bb=fff
               endif
 664         continue
c             
             fill=fff
             size1=reff
             write(2,663)frac1,fill
 663         format('Info:  frac1 = ',f10.8,', fill1 set to ',f10.8)
             go to 666
          endif
c
          if((istar.eq.2).and.(ivrt.eq.0).and.frac2.gt.0.0d0)then
             call findradius(overQ,omega,savepsi0,x0,bdist,reff,
     @             tidephi,itide,ecc,thetamis,phimis)
             bigfrac=reff
             if(frac2.gt.bigfrac)then
               fill=1.0d0
               write(2,6665)
               go to 666
 6665          format('Warning:  frac2 exceeds Roche radius. ',
     $           ' Setting fill2=1.0')
             endif
c
c   Presumably the Roche lobe has a fractional radius large than the
c   requested fractional radius.  Use bisection to find the filling
c   factor fill1.
c
             aa=0.0d0
             bb=1.0d0
             y=0.0d0
             z=0.0d0
             do 6664 i=1,60
               fff=(aa+bb)*0.5d0
               call POTEN(overQ,omega,x0*fff,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
               call findradius(overQ,omega,psi,x0*fff,bdist,
     &           reff,tidephi,itide,ecc,thetamis,phimis)
               if(frac2.ge.reff)then
                 aa=fff
               else
                 bb=fff
               endif
 6664        continue
c             
             fill=fff
             write(2,6663)frac2,fill
 6663        format('Info:  frac2 = ',f10.8,', fill2 set to ',f10.8)
             go to 666
          endif
c
c  If primrad>0, then we can adjust the fill1 to
c  get the requested radius, if possible.  However, if frac1>0,
c  then don't set the radius to primrad
c
          if((istar.eq.1).and.(ivrt.eq.0).and.(frac1.le.0.0d0).
     &          and.(primrad.gt.0.0d0))then
c
             call findradius(overQ,omega,savepsi0,x0,bdist,reff,tidephi,
     @           itide,ecc,thetamis,phimis)
             bigrad=reff*separation
             if(primrad.gt.bigrad)then
               fill=1.0d0
               write(2,4665)
               go to 666
 4665          format('Warning:  primrad*separation exceeds Roche ',
     @           ' radius.  Setting fill1=1.0')
             endif
c
c   Presumably the Roche lobe has a  radius larger than the
c   requested radius.  Use bisection to find the filling
c   factor fill1.
c
             aa=0.0d0
             bb=1.0d0
             y=0.0d0
             z=0.0d0
             do 4664 i=1,60
               fff=(aa+bb)*0.5d0
               call POTEN(overQ,omega,x0*fff,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
               call findradius(overQ,omega,psi,x0*fff,bdist,reff,
     &           tidephi,itide,ecc,thetamis,phimis)
               if(primrad.ge.reff*separation)then
                 aa=fff
               else
                 bb=fff
               endif
 4664         continue
c             
             fill=fff
             size1=reff
             write(2,4663)primrad,fill
 4663        format('Info:  primrad = ',f13.8,', fill1 set to ',f10.8)
             go to 666
          endif
c
Cc  If primrad=0 and frac1=0 and ratrad>0, then we can adjust the fill1 to
Cc  get the requested radius, if possible, after checking for the.radius
Cc  of star 2.
Cc
          if((istar.eq.1).and.(ivrt.eq.0).and.(frac1.le.0.0d0).
     &          and.(primrad.le.0.0d0).and.(ratrad.gt.0.0d0).
     $          and.(frac2.le.0.0d0))then
c
             cox=1.0d0
             coy=0.0d0
             y=0.0d0
             z=0.0d0
             call POTEN(overQ,omega,x0*fill,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
             call findradius(overQ,omega,psi,fill*x0,bdist,
     &        reff,tidephi,itide,ecc,thetamis,phimis)

             size1=reff
             write(2,3663)ratrad,fill
c             write(*,*)fill,size1
 3663        format('Info:  ratrad = ',f13.8,', fill1 set to ',f10.8)
             go to 666
          endif
c
c  If primrad=0 and frac1=0 and and frac2> and ratrad>0, 
c  then we can adjust the fill1 to
c  get the requested radius, if possible, after checking for the.radius
c  of star 2, which is frac2.
c
          if((istar.eq.1).and.(ivrt.eq.0).and.(frac1.le.0.0d0).
     &          and.(primrad.le.0.0d0).and.(ratrad.gt.0.0d0).
     $          and.(frac2.gt.0.0d0))then
c
c    Now use bisection to adjust fill1 so that reff1/reff2=ratrad.
c
             call findradius(overQ,omega,savepsi0,x0,bdist,
     &         reff,tidephi,itide,ecc,thetamis,phimis)
             radneed=ratrad*frac2
             if(reff.lt.radneed)then
               fill=1.0d0
               write(2,2665)ratrad,frac2
               go to 666
 2665          format('Warning:  radrad=',f12.8,' is not possible with'/,
     $                '          frac2=',f8.6,'. ',
     &                 ' Setting fill1=1.0')
             endif
             aa=0.0d0
             bb=1.0d0
             y=0.0d0
             z=0.0d0
             do 2664 i=1,60
               fff=(aa+bb)*0.5d0
               call POTEN(overQ,omega,x0*fff,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
               call findradius(overQ,omega,psi,x0*fff,bdist,
     &          reff,tidephi,itide,ecc,thetamis,phimis)
               radneed=ratrad*frac2
               if(radneed.ge.reff)then
                 aa=fff
               else
                 bb=fff
               endif
 2664         continue
c             
             fill=fff
             size1=reff
             write(2,2663)ratrad,fill
 2663        format('Info:  ratrad = ',f13.8,', fill1 set to ',f10.8)
             go to 666
          endif
c
c   
c
c  If ratrad>0 and frac1=0
c  then we can adjust the fill2 to
c  get the requested radius, if possible, based on the value of size1
c
          if((istar.eq.2).and.(ivrt.eq.0).and.(ratrad.gt.0.0d0).
     $          and.(frac2.le.0.0d0))then
c
c    Now use bisection to adjust fill2 so that rad2=size1/ratrad.
c
             call findradius(overQ,omega,savepsi0,x0,bdist,
     &         reff,tidephi,itide,ecc,thetamis,phimis)
             radneed=size1/ratrad

c             write(*,*)'&&&& ',radneed,size1,reff
             if(reff.lt.radneed)then
               fill=  1.0d0        
               write(2,1665)ratrad
               go to 666
 1665          format('Warning:  radrad=',f12.8,' is not possible.'/,
     $             ' Setting fill2=1.0')
             endif
             aa=0.0d0
             bb=1.0d0
             y=0.0d0
             z=0.0d0
             do 1664 i=1,60
               fff=(aa+bb)*0.5d0
               call POTEN(overQ,omega,x0*fff,y,z,psi,psix,psixx,psiy,
     &             psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
               call findradius(overQ,omega,psi,x0*fff,bdist,
     &           reff,tidephi,itide,ecc,thetamis,phimis)
               radneed=size1/ratrad
               if(radneed.ge.reff)then
                 aa=fff
               else
                 bb=fff
               endif
 1664         continue
c             
             fill=fff
             write(2,1663)ratrad,fill
 1663        format('Info:  ratrad = ',f13.8,', fill2 set to ',f10.8)
             go to 666
          endif
c
c  
c   Skip down to here when constraints are set
c
 666      nnn=40
          if(ivrt.eq.0)nnn=1
          do 106 iii=1,nnn   ! here is the loop point when we need to invert
c
            if(ivrt.gt.0)fill=fnew
c
c   If the flag 'iusepot' is 1 or larger, then we must compute the
c   filling factor needed to get the entered value of 'usepot'.
c   If the requested potential is *smaller* than the critical potential,
c   then set the filling factor to 1.0.
c
            if(iusepot.ge.1)then
              if(ivrt.eq.0)then
                call findfill(istar,overQ,omega,critpsi,x0,usepot,psi0,fill,
     %              bdist,tidephi,itide,ecc,thetamis,phimis)
                x=fill*x0
              else
                x=fill*x0
                y=0.0d0
                z=0.0d0
                call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @             bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
                psi0=psi     ! value of the potential at x-axis 
              endif
            else
              x=fill*x0
              y=0.0d0
              z=0.0d0
              call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @           bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
              psi0=psi     ! value of the potential at x-axis 
            endif
c
            if(ivrt.eq.0)fillper=fill
c
            vol=0.0d0
            sarea=0.0d0
            r=x       
            potsum=0.0d0  
            do 2526 ialf=1,nalph
              theta=-0.5d0*dtheta+dtheta*dble(ialf)
c
c   UPDATE January 11, 2010
c
c   Change to make similar to W-D
c
              ibetlim(ialf)=1+idnint(1.3d0*dble(4*Nbet)*dsin(theta))
c            
              if(mod(ibetlim(ialf),2).eq.1)ibetlim(ialf)=ibetlim(ialf)-1
              if(isquare.ge.1)ibetlim(ialf)=4*Nbet
              theta=-0.5d0*dtheta+dtheta*dble(ialf)
 2526       continue
c
c
c   UPDATE January 11, 2010
c
c   Now that ibetlim is set, initalize the random starting phi values
c
          nnn=2
          do 765 ialf=1,Nalph
            dphi=twopie/dble(ibetlim(ialf))
            call sobseq(nnn,xsob)
            fac=(xsob(1)-0.5d0)*0.5d0
            fac=0.0d0
            phistart(ialf)=fac*dphi
c            write(*,*)istar,phistart(ialf),(xsob(1)-0.5d0)
c            phistart(ialf)=0.0d0
c            if(dble(ialf/2).eq.(dble(ialf)*0.5d0))phistart(ialf)=fac*dphi 
765       continue
c
c   The following is a quick loop to find the volume.
c
            do 104 ialf=1,Nalph/2
c
c   UPDATE MARCH 17, 2004
c
c   make the initial value of r smaller here.
c
              r=0.0000001d0

              call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,bdist,
     $            tidephi,itide,ecc,thetamis,phimis)
              theta=-0.5d0*dtheta+dtheta*dble(ialf)
c              ibetlim(ialf)=idnint(dsin(theta)*4*Nbet)
c              if(mod(ibetlim(ialf),2).eq.1)ibetlim(ialf)=ibetlim(ialf)-1
c              if(isquare.ge.1)ibetlim(ialf)=4*Nbet
c              if(ialf.le.nalf/2)then
c                if(mod(ialf,2).eq.0)ibetlim(ialf)=4*Nbet
c              else
c                if(mod(ialf,2).eq.1)ibetlim(ialf)=4*Nbet
c              endif
              dphi=twopie/dble(ibetlim(ialf))
              snth=dsin(theta)
              snth3=snth/3.0d0   
              cnth=dcos(theta)
              DO 105 ibet=1,ibetlim(ialf)/2          !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c                iidx=kount(ialphmax,ialf,ibetlim)+ibet
c 
c                mcount=mcount+1
c                mmdx(ialf,ibet)=mcount
c                iidx=mcount
                iidx=kount(ialphmax,ialf,ibetlim)+ibet
                phi=-0.5d0*dphi+dphi*dble(ibet)
c                phiar(ialf,ibet)=phi
                phiar(iidx)=phi
                cox=dcos(phi)*snth             !*dsin(theta)
                coy=dsin(phi)*snth             !*dsin(theta)
                coz=cnth                       !dcos(theta)
                CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $            tidephi,itide,ecc,thetamis,phimis)
                VOL = VOL + 4.0d0*R*R*R*dphi*dtheta*snth3
105           CONTINUE    ! continue ibet loop
104         CONTINUE                   ! continue over ialf
c
            diff=vol-pervol          
            if(ivrt.eq.0)then
              pervol=vol !reference volume
              vol=0.0d0
              sarea=0.0d0
              r=x       
              potsum=0.0d0  
              x=fill*x0
              y=0.0d0
              z=0.0d0
              go to 700
            endif
c
c   Here is a little bisection block which compares the volume just found
c   to the reference volume pervol.
c
            if(diff.le.0.0d0)then
              fsmall=fnew
              fnew=0.5d0*(fsmall+fbig)
            else
              fbig=fnew
              fnew=0.5d0*(fsmall+fbig)
            endif
            acc=0.5d0*dabs(fbig-fsmall)/(fbig+fsmall)
            if(acc.lt.1.0d-10)then      
              vol=0.0d0
              sarea=0.0d0
              r=x       
              potsum=0.0d0  
              go to 700
            endif
 106      continue
c
c   We have the correct volume now.  Go and assign the other variables.
c
 700      vol=0.0d0
          sarea=0.0d0
          potsum=0.0d0
          x=fill*x0
          y=0.0d0
          z=0.0d0
c
c   Note the loop below is set for the whole star.  If using one fourth
c   of the star, change the term in the Vol = command to 4.0
c
          if(itide.lt.2)then
          do 1104 ialf=1,Nalph               !Nalph/2
c
c   UPDATE MARCH 17, 2004
c
c   make the initial value of r smaller here.
c
            r=0.0000001d0
            call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,bdist,
     @         tidephi,itide,ecc,thetamis,phimis)
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
c            ibetlim(ialf)=idnint(dsin(theta)*4*Nbet)
c            if(mod(ibetlim(ialf),2).eq.1)ibetlim(ialf)=ibetlim(ialf)-1
c            if(isquare.ge.1)ibetlim(ialf)=4*Nbet
c              if(ialf.le.nalf/2)then
c                if(mod(ialf,2).eq.0)ibetlim(ialf)=4*Nbet
c              else
c                if(mod(ialf,2).eq.1)ibetlim(ialf)=4*Nbet
c              endif
            dphi=twopie/dble(ibetlim(ialf))
            snth=dsin(theta)
            snth3=dsin(theta)/3.0d0  !*0.333333333333333d0
            cnth=dcos(theta)
            DO 1105 ibet=1, ibetlim(ialf)     !ibetlim(ialf)/2  !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c              write(*,*)ialf,ibet,iidx
              mmdx(ialf,ibet)=iidx
              phi=-0.5d0*dphi+dphi*dble(ibet)
              phi=phi+phistart(ialf)
c
c              if(dble(ialf/2).eq.(dble(ialf)*0.5d0))phi=phi+0.25d0*dphi  !DPHI
c
              phiar(iidx)=phi
              cox=dcos(phi)*snth                !*dsin(theta)
              coy=dsin(phi)*snth                !*dsin(theta)
              coz=cnth                          !dcos(theta)
              CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $         tidephi,itide,ecc,thetamis,phimis)
              call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @          bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
              radarray(iidx) = R
              garray(iidx) = DSQRT(PSIX**2+PSIY**2+PSIZ**2)
              oneoverg=1.0d0/garray(iidx)
              GRADX(iidx) = -PSIX*oneoverg
              GRADY(iidx) = -PSIY*oneoverg
              GRADZ(iidx) = -PSIZ*oneoverg
              surf(iidx) = COX*GRADX(iidx)+COY*GRADY(iidx)
     $           + COZ*GRADZ(iidx)
c
c   The following check is for large separations.
c
              if(surf(iidx).lt.0.7d0)surf(iidx)=0.7d0
c
              surf(iidx) = R**2 / surf(iidx)
c
c   Add terms to account for the delta phi and delta theta terms.
c
c   Expression with distribution of points linear in theta.
c
              surf(iidx)=surf(iidx)*dphi*dtheta*snth
c
c   Expression with distribution of points linear in cos(theta)
c
c               surf(iidx)=surf(iidx)*dphi*dcostheta
c
c   Keep track of the surface area and volume.
c
              sarea=sarea+surf(iidx)
c
c   Expression with distribution of points linear in theta.
c
              VOL = VOL + 1.0d0*R*R*R*dphi*dtheta*snth3
c
c   Expression with distribution of points linear in cos(theta)
c
c              VOL = VOL + R*R*R*dphi*dcostheta/3.0d0
c
c   Assign x,y,z coordinates of grid point
c
              xarray(iidx)=x  !radius vector times the direction cosine
              yarray(iidx)=y  ! "" ""          ""   ""
              zarray(iidx)=z  

c              go to 1105
c
cc
cc   Use symmetry to reflect the various quantities.
cc 
c              I1=nalph-(ialf-1)
c              J2=ibetlim(ialf)-(ibet-1)
cc              ibetlim(I1)=ibetlim(ialf)
cc
c              jjdx1=kount(ialphmax,ialf,ibetlim)+j2
c              jjdx2=kount(ialphmax,I1,ibetlim)+ibet              
c              jjdx3=kount(ialphmax,I1,ibetlim)+j2
c
c              mmdx(ialf,j2)=jjdx1
c              mmdx(I1,ibet)=jjdx2
c              mmdx(I1,j2)=jjdx3
cc
c              xarray(jjdx1)=xarray(iidx)
c              xarray(jjdx2)=xarray(iidx)
c              xarray(jjdx3)=xarray(iidx)
cc
c              yarray(jjdx1)=-yarray(iidx)
c              yarray(jjdx2)=yarray(iidx)
c              yarray(jjdx3)=-yarray(iidx)
cc
c              zarray(jjdx1)=zarray(iidx)
c              zarray(jjdx2)=-zarray(iidx)
c              zarray(jjdx3)=-zarray(iidx)
cc
c              surf(jjdx1)=surf(iidx)
c              surf(jjdx2)=surf(iidx)
c              surf(jjdx3)=surf(iidx)
cc
c              garray(jjdx1)=garray(iidx)
c              garray(jjdx2)=garray(iidx)
c              garray(jjdx3)=garray(iidx)
cc
c              radarray(jjdx1)=radarray(iidx)
c              radarray(jjdx2)=radarray(iidx)
c              radarray(jjdx3)=radarray(iidx)
cc
c              gradx(jjdx1)=gradx(iidx)
c              gradx(jjdx2)=gradx(iidx)
c              gradx(jjdx3)=gradx(iidx)
cc
c              grady(jjdx1)=-grady(iidx)
c              grady(jjdx2)=grady(iidx)
c              grady(jjdx3)=-grady(iidx)
cc
c              gradz(jjdx1)=gradz(iidx)
c              gradz(jjdx2)=-gradz(iidx)
c              gradz(jjdx3)=-gradz(iidx)
c
c              sarea=sarea+surf(jjdx1)
c              sarea=sarea+surf(jjdx2)
c              sarea=sarea+surf(jjdx3)
c  
c              phiar(jjdx1)=twopie-phiar(iidx)
c              phiar(jjdx2)=phiar(iidx)
c              phiar(jjdx3)=twopie-phiar(iidx)
c
1105        CONTINUE    ! continue ialf loop
c
1104      CONTINUE                   ! continue over ibet
c
          endif !end if itide < 2
c
c  If we are using the tidal approximation, 
c  we cannot use symmetry.  Loop over the full range of 
c  Nalph and Nbet
c
          if(itide.ge.2)then
c
c          tider=pie*tidephi/80.0d0

          do 3104 ialf=1,Nalph
c
c   UPDATE MARCH 17, 2004
c
c   make the initial value of r smaller here.
c
            r=0.0000001d0
            call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,bdist,
     @         tidephi,itide,ecc,thetamis,phimis)
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            dphi=twopie/dble(ibetlim(ialf))
            snth=dsin(theta)
            snth3=dsin(theta)/3.0d0  !*0.333333333333333d0
            cnth=dcos(theta)
            DO 3105 ibet=1,ibetlim(ialf)
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c              write(*,*)ialf,ibet,iidx
              mmdx(ialf,ibet)=iidx
              phi=-0.5d0*dphi+dphi*dble(ibet)
              phi=phi+phistart(ialf)
              phiar(iidx)=phi
              cox=dcos(phi)*snth                !*dsin(theta)
              coy=dsin(phi)*snth                !*dsin(theta)
              coz=cnth                          !dcos(theta)
              CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $         tidephi,itide,ecc,thetamis,phimis)
              call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @          bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
c

              radarray(iidx) = R
              garray(iidx) = DSQRT(PSIX**2+PSIY**2+PSIZ**2)
              oneoverg=1.0d0/garray(iidx)
              GRADX(iidx) = -PSIX*oneoverg
              GRADY(iidx) = -PSIY*oneoverg
              GRADZ(iidx) = -PSIZ*oneoverg
              surf(iidx) = COX*GRADX(iidx)+COY*GRADY(iidx)
     $           + COZ*GRADZ(iidx)
c
c   The following check is for large separations.
c
              if(surf(iidx).lt.0.7d0)surf(iidx)=0.7d0
c
              surf(iidx) = R**2 / surf(iidx)
c
c   Add terms to account for the delta phi and delta theta terms.
c
c   Expression with distribution of points linear in theta.
c
              surf(iidx)=surf(iidx)*dphi*dtheta*snth
c
c   Expression with distribution of points linear in cos(theta)
c
c               surf(iidx)=surf(iidx)*dphi*dcostheta
c
c   Keep track of the surface area and volume.
c
              sarea=sarea+surf(iidx)
c
c   Expression with distribution of points linear in theta.
c
              VOL = VOL + 1.0d0*R*R*R*dphi*dtheta*snth3
c
c   Expression with distribution of points linear in cos(theta)
c
c              VOL = VOL + R*R*R*dphi*dcostheta/3.0d0
c
c   Assign x,y,z coordinates of grid point
c
              xarray(iidx)=x  !radius vector times the direction cosine
              yarray(iidx)=y  ! "" ""          ""   ""
              zarray(iidx)=z  
c

3105        CONTINUE    ! continue ialf loop
c
3104      CONTINUE                   ! continue over ibet
c
          endif !end if itide >= 2
c
          REFF = (0.75d0*VOL/pie) **(1.0d0/3.0d0) 

c          REFF = (0.248732415d0*VOL) **(1.0d0/3.0d0) ! 0.3333333333333333d0
c
          Nalf2=Nalph/2
c
          cox=0.0d0
          coy=0.0d0
          coz=1.0d0
          r=radarray(1)
          CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     &        tidephi,itide,ecc,thetamis,phimis)
          call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @       bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
          div = DSQRT(PSIX**2+PSIY**2+PSIZ**2)
          gpole=div          
          rpol(Nalf2)=r
          zpole=z
c
          potsum=0.0d0
          DO 401 IALF = 1, nalph
            DO 400 IBET = 1, ibetlim(ialf)          !4*NBET
c
c   Keep track of the sums of the normalized gravities to compute the
c   intensity weighted effective temperature.
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              potsum=((garray(iidx)/div)**(4.0d0*Tgrav))
     %               *surf(iidx)+potsum
c
 400        continue
401       CONTINUE
c
c   keep track of the point on the star on x-axis
c
          cox=1.0d0
          coy=0.0d0
          coz=0.0d0
          r=fill*x0
          CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,tidephi,
     &         itide,ecc,thetamis,phimis)
          xend(3)=r
c         
          cox=-1.0d0
          coy=0.0d0
          coz=0.0d0
          CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,
     &         bdist,tidephi,itide,ecc,thetamis,phimis)
          xend(4)=r
c
          Tpole=Teff*dsqrt(dsqrt(sarea/potsum))
c
c  UPDATE September 11, 2001
c 
c  Put the if-then clauses around the write statements.
c
          pot=psi0
          if(istar.eq.1)then
            if(iverb.eq.0)then
              write(2,999)Q,1.0d0/Q
              write(2,1000)Rl,Rl*fill,reff,fill*rocheradius(1.0d0/Q)
              write(2,1002)reff*separation
              write(2,1005)rocheradius(1.0d0/Q)
              write(2,1006)Rpol(Nalf2)
              write(2,1004)xend(3),xend(4)
              write(2,5004)(reff-Rpol(Nalf2))/reff*100.0d0
              write(2,5005)(reff-xend(3))/reff*100.0d0
              write(2,5006)(reff-xend(4))/reff*100.0d0
              write(2,1007)savepsi0,psi0
              write(3,2000)reff
              write(3,2001)Rpol(Nalf2)
            endif
            Regg=rocheradius(1.0d0/Q)
c
 5004       format('reff-r_pole   = ',f16.11,' percent') 
 5005       format('reff-x(point) = ',f16.11,' percent') 
 5006       format('reff-x(end)   = ',f16.11,' percent') 
c
c   NEW BUG ALERT  July 13, 2001
c
c   Change the indices of xend to 3,4
c
            if(iverb.eq.0)then
              write(3,2002)xend(3)
              write(3,2003)xend(4)
              write(3,2004)psi0
              write(3,2005)sarea
              write(3,2006)vol
              write(3,2007)Tpole
            endif
          endif
          if(istar.eq.2)then
c
            psi0=psi0/overQ+0.5d0*(overQ-1.0d0)/overQ
            savepsi0=savepsi0/overQ+0.5d0*(overQ-1.0d0)/overQ
            if(iverb.eq.0)then
              write(2,1001)Rl,Rl*fill,reff,fill*rocheradius(Q)
              write(2,1002)reff*separation
              write(2,1005)rocheradius(Q)
              write(2,1006)Rpol(Nalf2)
              write(2,1004)xend(3),xend(4)
              write(2,5004)(reff-Rpol(Nalf2))/reff*100.0d0
              write(2,5005)(reff-xend(3))/reff*100.0d0
              write(2,5006)(reff-xend(4))/reff*100.0d0
              write(2,1007)savepsi0,psi0
              write(3,3000)reff
              write(3,3001)Rpol(Nalf2)
            endif
            Regg=rocheradius(Q)
c
c   NEW BUG ALERT  July 13, 2001
c
c   Change the indices of xend to 3,4
c
            if(iverb.eq.0)then
              write(3,3002)xend(3)
              write(3,3003)xend(4)
              write(3,3004)psi0
              write(3,3005)sarea
              write(3,3006)vol
              write(3,3007)Tpole
            endif
          endif
c
c   Make the xend array contain the poles of the star for compatability
c   with the plotting subroutine
c
          xend(1)=zpole
          xend(2)=-zpole
c         
c   UPDATE September 11, 2001
c
c   Put the if-then clause around the write statement.
c
          if(iverb.eq.0)write(2,1003)sarea,vol,Teff,Tpole
c
 999      format(/'Q = ',f8.5,'  1/Q = ',f15.7)
 1000     format(/'star 1:'/'L1 = ',f6.4,',  fill*L1 = ',f6.4,
     &     ', r_eff = ',f9.7,
     $     ', r_eff (Eggleton) = ',f9.7)
 1001     format(/'star 2:'/'L1 = ',f6.4,',  fill*L1 = ',f6.4,
     &     ', r_eff = ',f9.7,
     $     ', r_eff (Eggleton) = ',f9.7)
 1002     format('effective radius in solar units = ',f9.5)
c
 1003     format('surface area = ',e16.9,2x,'volume = ',e16.9,2x,/
     %     'effective temperature = ',f9.3,2x,'polar temperature = ',f9.3)
 1004     format('x(point) = ',f10.8,2x,'x(end) = ',f10.8)
 1005     format('Roche lobe effective dimensionless radius ',
     &      '(Eggleton formula) = ',f7.5)
 1006     format('polar radius = ',f10.8)
 1007     format('potential at L1 = ',f12.6,2x,'potential at fill*L1 = ',
     %      f12.6)
c
 2000     format( f14.11,11x,'r_eff (star 1)')
 3000     format( f14.11,11x,'r_eff (star 2)')
 2001     format( f14.11,11x,'r_pole (star 1)')
 3001     format( f14.11,11x,'r_pole (star 2)')
 2002     format( f14.11,11x,'x(point) (star 1)')
 3002     format( f14.11,11x,'x(point) (star 2)')
 2003     format( f14.11,11x,'x(end) (star 1)')
 3003     format( f14.11,11x,'x(end) (star 2)')
 2004     format(f17.10, 8x,'potential at fill1*L1')     
 3004     format(f17.10, 8x,'potential at fill2*L1')
 2005     format(e16.9, 9x,'surface area (star 1)')
 3005     format(e16.9, 9x,'surface area (star 2)')
 2006     format(e16.9, 9x,'volume (star 1)')
 3006     format(e16.9, 9x,'volume (star 2)')
 2007     format(f15.9,10x,'polar temperature (star 1)')
 3007     format(f15.9,10x,'polar temperature (star 2)')
c

          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          double precision function rocheradius(q)
c
c      Finds the radius of the Roche lobe around mass 1 as given in 
c      Pringle and Wade where q = M1/M2
c
          implicit double precision(a-h,o-z)
c
          q13=q**(1.0d0/3.0d0)
          q23=q13*q13
          t1=dlog(1.0d0+q13)
          rocheradius=0.49d0*q23/(0.6d0*q23+t1)
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine findL1(Q,omega,x0,iflag,bdist,tidephi,
     &            ecc,thetamis,phimis)
c
c   October 6, 1999
c
c   This routine returns the distance to L1 when given Q.  This is more
c   or less stolen from the Avni code.
c
c   February 15, 2000
c
c   The iflag is added because the potential computation needs to be
c   modified in some cases, specifically when star 2 is not synchronous.
c
          implicit double precision(a-h,o-z)

          x=0.2d0*bdist 
          x=0.99d0*bdist 
c          if(Q.lt.1.0d-3)x=0.95d0*bdist
          if(bdist.gt.1.7d0)x=0.450d0*bdist
c          write(*,*)'x initial = ',x,Q
          y=0.0d0
          z=0.0d0
c
c   UPDATE November 14, 2009
c
c   Make the modifications to use the tidal potential option.
c   cox=1.0 and coy=0.0
c
          cox=1.0d0
          coy=0.0d0
c
c   UPDATE MARCH 5, 2008
C
c   Make the number of loops 40, to ensure convergence for extreme values
c   of the mass ratio or omega.
c
          do 10 i=1,60
c            write (*,*)i,x,dx   
            call POTEN(Q,omega,x,y,z,psi,psix,psixx,psiy,psiz,iflag,
     @         bdist,cox,coy,tidephi,1,ecc,thetamis,phimis)
            dx=-psix/psixx
            if(dabs(dx).lt.1.0d-16)go to 15
            x=x+dx
            dx=dabs(dx)
 10       continue
 15       x0=x           ! here is the distance to L1
c
c          write(*,*)bdist,x0
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          SUBROUTINE RAD(Q,omega,cox,coy,coz,psi0,r,x,y,z,iflag,bdist,
     $         tidephi,itide,ecc,thetamis,phimis)
c
c   October 6, 1999
c
c   This routine finds the radius of a given point on the Roche lobe.
c   From Avni's original code.
c
c   February 15, 2000
c
c   The iflag is added because the potential computation needs to be
c   modified in some cases, specifically when star 2 is not synchronous.
c
c
          implicit double precision(a-h,o-z)
c
          do 10 i=1,190
            X=R*COX
            Y=R*COY
            Z=R*COZ
c
             call spherepot(Q,omega,cox,coz,r,psi,dpsidr,
     &          bdist,tidephi,itide,ecc,thetamis,phimis,coy)
             rnew=r-(psi-psi0)/dpsidr
             dr=dabs(rnew-r)
c             IF(dabs(dr).lt.1.0d-19) GO TO 15
             IF(dabs(dr).lt.1.0d-16) GO TO 15
             r=rnew
 10       continue
c
c   if we made to this point, the radius did not converge.  Try bisection
c   instead.
c  
          call findL1(Q,omega,x0,iflag,bdist,tidephi,ecc,thetamis,
     @              phimis)
c
c   The radius needed is between 0.0 and x0      
c
          aa=1.0d-15
          bb=x0
c
          do 30 i=1,90
            call spherepot(Q,omega,cox,coz,aa,psi,dpsidr,bdist,
     &           tidephi,itide,ecc,thetamis,phimis,coy)
            aapsi=psi-psi0     !should be positive
            call spherepot(Q,omega,cox,coz,bb,psi,dpsidr,
     &         bdist,tidephi,itide,ecc,thetamis,phimis,coy)
            bbpsi=psi-psi0     !should be negative
            rmid=0.50*(aa+bb)
            call spherepot(Q,omega,cox,coz,rmid,psi,dpsidr,
     &         bdist,tidephi,itide,ecc,thetamis,phimis,coy)
            rmidpsi=psi-psi0
            if(aapsi.eq.0.0d0)then
              r=aa
              go to 31
            endif
            if(bbpsi.eq.0.0d0)then
              r=bb
              go to 31
            endif            
            if(aapsi*rmidpsi.gt.0.0d0)then
              aa=rmid
            else
              bb=rmid
            endif
c            write(*,*)aapsi,bbpsi,rmid
30        continue
          r=rmid
31        X=R*COX
          Y=R*COY
          Z=R*COZ
c
c          write(*,*)'%%%%%%%% ',r-rsave

 15       CALL POTEN(Q,omega,x,y,z,psi,psix,psixx,psiy,psiz,iflag,bdist,
     @         cox,coy,tidephi,itide,ecc,thetamis,phimis)


          RETURN
          END
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c  RVG BUG ALERT  May 9, 2001
c
c  Add the spot parameters to this subroutine
c
c  UPDATE August 10, 2004
c
c  Add the 8 new real and 4 new integer variables to the list.
c
c  UPDATE May 8, 2006
c
c  Add isw21-isw24, sw21-sw24, powercoeff to list.
c
          subroutine recordparm(Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,
     @      omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,
     @      betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,
     @      Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,
     @      sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,
     @      icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,
     @      dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,
     @      sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,
     @      spot2parm,spotdparm,primmass,primK,primrad,ratrad,frac1,
     @      frac2,ecosw,temprat,idark1,idark2,isw12,isw13,isw21,isw22,
     @      isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,
     @      sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,isw25,isw26,
     @      isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,ocose,osine,
     @      omegadot,contamS0,contamS1,contamS2,contamS3,sw47,sw48,sw49)
c
c    Will record the parameters used in the file ELC.out, and will also
c    record interesting computed parameters.
c
c
          implicit double precision(a-h,o-z)
c
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @      dwavey(8,3)
          dimension powercoeff(8,9)
c
c   RVG BUG ALERT  May 9, 2001
c
c   Dimension the spot arrays.
c
          dimension spot1parm(2,4),spot2parm(2,4),spotdparm(2,4)
c
          open(unit=2,file='ELC.out',status='unknown')
c
          write(2,*)'This is ELC version 5.0 (February 15, 2014)'
          write(2,1000)Nalph1
          write(2,1001)Nbet1
          write(2,1002)Nalph2
          write(2,1003)Nbet2
          write(2,1004)fill1
          write(2,1005)fill2
          write(2,1006)omega1
          write(2,1007)omega2
          write(2,1008)dphase
          write(2,1009)Q
          write(2,1010)finc
          write(2,1011)Teff1
          write(2,1012)Teff2
          write(2,1013)Tgrav1
          write(2,1014)Tgrav2
          write(2,1015)betarim
          write(2,1016)rinner
          write(2,1017)router
          write(2,1018)tdisk
          write(2,2018)xi
          write(2,1019)Ntheta
          write(2,1020)Nradius
          write(2,1042)alb1
          write(2,1043)alb2
          write(2,2043)Nref
          write(2,1021)rLx
          write(2,1023)Period
          if(fm.gt.1.0d-4)then
            write(2,1024)fm
          else
            write(2,9024)fm
          endif
 9024     format(1pe16.9,4x,'fm')
          write(2,1025)separ
          write(2,4025)gamma
          write(2,5000)t3
          write(2,5001)g3
          write(2,5002)SA3
          write(2,5003)density
          write(2,5004)sw1
          write(2,5005)sw2
          write(2,5006)sw3
          write(2,5007)T0
          write(2,1026)idraw
          write(2,1027)iecheck
          write(2,1028)iidint
          write(2,4000)iatm
          write(2,4001)ism1
c
c  RVG BUG ALERT   May 16, 2001
c
c  Modify the icn? flags so that they are either 0 or 1, which conforms
c  to the output format statement.
c
c   Set the icn? control numbers back to zeros and 1s.
c
          if(icnU.eq.430)then
            iU=0
          else
            iU=1
          endif
          if(icnB.eq.430)then
            iB=0
          else
            iB=1
          endif
          if(icnV.eq.430)then
            iV=0
          else
            iV=1
          endif
          if(icnR.eq.430)then
            iR=0
          else
            iR=1
          endif
          if(icnI.eq.430)then
            iI=0
          else
            iI=1
          endif
          if(icnJ.eq.430)then
            iJ=0
          else
            iJ=1
          endif
          if(icnH.eq.430)then
            iH=0
          else
            iH=1
          endif
          if(icnK.eq.430)then
            iK=0
          else
            iK=1
          endif
c
          write(2,4002)iU,iB,iV,iR,iI,iJ,iH,iK
c
c  END BUG
c
          write(2,5008)iRVfilt
          write(2,5009)isw1
          write(2,5010)isw2
          write(2,5011)isw3
          write(2,5012)isw4
          write(2,3028)ilaw
c
          do 10 i=1,8
            write(2,2000)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),dboly(i,2),
     $           dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
 10       continue
c
          write(2,6000)ecc
          write(2,6001)argper
          write(2,6002)pshift
          write(2,6003)sw5
          write(2,6004)sw6
          write(2,6005)sw7
          write(2,6006)sw8
          write(2,6007)sw9
          write(2,6008)ikeep
          write(2,6009)isynch
          write(2,6010)isw5
          write(2,6011)isw6
          write(2,6012)isw7
          write(2,6013)isw8
          write(2,6014)isw9
c
          write(2,2001)spot1parm(1,1)
          write(2,2002)spot1parm(1,2)
          write(2,2003)spot1parm(1,3)
          write(2,2004)spot1parm(1,4)
c                     
          write(2,2005)spot1parm(2,1)
          write(2,2006)spot1parm(2,2)
          write(2,2007)spot1parm(2,3)
          write(2,2008)spot1parm(2,4)
c                     
c                     
          write(2,2009)spot2parm(1,1)
          write(2,2010)spot2parm(1,2)
          write(2,2011)spot2parm(1,3)
          write(2,2012)spot2parm(1,4)
                      
          write(2,2013)spot2parm(2,1)
          write(2,2014)spot2parm(2,2)
          write(2,2015)spot2parm(2,3)
          write(2,2016)spot2parm(2,4)
c                     
c                     
          write(2,2017)spotdparm(1,1)
          write(2,22018)spotdparm(1,2)
          write(2,2019)spotdparm(1,3)
          write(2,2020)spotdparm(1,4)
                      
          write(2,2021)spotdparm(2,1)
          write(2,2022)spotdparm(2,2)
          write(2,2023)spotdparm(2,3)
          write(2,2024)spotdparm(2,4)
c
c   UPDATE August 10, 2004
c
c   Write out the 8 real and 4 new integer variables here.
c
          write(2,2025)primmass
          write(2,2026)primK
          write(2,2027)primrad
          write(2,2028)ratrad
c
          write(2,2030)frac1
          write(2,2031)frac2
          write(2,2032)ecosw
          write(2,2033)temprat
c
          write(2,2040)idark1
          write(2,2041)idark2
          write(2,2042)isw12
          write(2,3043)isw13
c
          write(2,8001)isw21
          write(2,8002)isw22
          write(2,8003)isw23
          write(2,8004)isw24
c
8001      format(i1,19x,'ialign (0 for rotation aligned with orbit)')
8002      format(i1,19x,'ifastgen (1 for fast genetic mode)')
8003      format(i1,19x,'iwriteeclipse (1 to fit for eclipse times)')         
8004      format(i1,19x,
     @        'frac switch (>1 to enable ELCratio.???? files)')         
c
          do 85000 kk=1,8
              write(2,85001)powercoeff(kk,1),powercoeff(kk,2),
     $       powercoeff(kk,3),powercoeff(kk,4),powercoeff(kk,5),
     $       powercoeff(kk,6),powercoeff(kk,7),powercoeff(kk,8),
     @       powercoeff(kk,9)
85000     continue
c
85001      format(9(f7.4,1x))
c
          write(2,8011)bigI
          write(2,8012)bigbeta
          write(2,8013)sw23
          write(2,8014)sw24
c
8011      format(f11.7,9x,'axis_I (inclination of rotation axis if',
     @      ' ialign=1)')
8012      format(f11.7,9x,'axis_beta (angle of rotation axis wrt to ',
     @      ' orbit if ialign=1)')          
8013      format(f15.7,5x,'t_start')
8014      format(f15.7,5x,'t_end')         
c
c
c  UPDATE November 6, 2008
c
c  write the new variables sw25-sw34 and isw25-isw34 here
c
          write(2,8025)sw25
          write(2,8026)sw26
          write(2,8027)sw27
          write(2,8028)sw28
          write(2,8029)sw29
          write(2,8030)sw30
          write(2,8031)contam
          write(2,8032)Tconj
          write(2,8033)beam1
          write(2,8034)beam2

          write(2,9025)isw25
          write(2,9026)isw26
          write(2,9027)isw27
          write(2,9028)isw28
          write(2,9029)isw29
          write(2,9030)isw30
          write(2,9031)isw31
          write(2,9032)isw32
          write(2,9033)isw33
          write(2,9034)isw34
c
          write(2,8040)ocose
          write(2,8041)osine
          write(2,8042)omegadot
          write(2,8043)contamS0
          write(2,8044)contamS1
          write(2,8045)contamS2
          write(2,8046)contamS3
          write(2,8047)sw47
          write(2,8048)sw48
          write(2,8049)sw49

 8040     format(f14.10,6x,'e*cos(omega)')
 8041     format(f14.10,6x,'e*sin(omega)')
 8042     format(f12.8,8x,'omega_dot (degrees per year)')
 8043     format(f12.8,8x,'contamS0 (season 0 contamination, tag s0)')
 8044     format(f12.8,8x,'contamS1 (season 1 contamination, tag s1)')
 8045     format(f12.8,8x,'contamS2 (season 2 contamination, tag s2)')
 8046     format(f12.8,8x,'contamS3 (season 3 contamination, tag s3)')
 8047     format(f16.8,4x,'Tref for dynamical integrator')
 8048     format(f12.8,8x,'threshold to write chi^2')
 8049     format(f12.8,8x,'sw49 (currently inactive)')


8025      format(f10.7,10x,'asini error')
8026      format(f10.8,10x,'reference phase for disk fraction')
8027      format(f10.8,10x,'radfill1 (set to use fill1 ',
     @          'in terms of R_eff')
8028      format(f10.8,10x,'radfill2 (set to use fill2 ',
     @          'in terms of R_eff')
8029      format(f10.6,10x,'bin size for light curves (minutes)')
8030      format(f10.6,10x,'bin size for RV curves (minutes)')
8031      format(f11.9,9x,'Kepler contamination')
8032      format(f15.8,5x,'Tconj')
8033      format(f8.6,12x,'beam1 (Doppler boost factor, star 1)')
8034      format(f8.6,12x,'beam2 (Doppler boost factor, star 2)')

9025      format(i1,19x,'X-ray foreshortening switch', 
     $        ' (1 for point source)')
9026      format(i1,19x,'iGR (1 for GR, 2 for tidal, 3 for both)')
9027      format(i6,14x,'Nterms for fast analytic')
9028      format(i1,19x,'set to 1 to fit for Tconj')
9029      format(i1,19x,
     $         'set to 1 to fit for e*cos(omega), e*sin(omega)')
9030      format(i1,19x,'body 3 switch')
9031      format(i4,16x,'Ngap')
9032      format(i11,9x,'jdum (seed for markovELC, geneticELC, ',
     @        'randomELC)')
9033      format(i1,19x,'mandel (0 for Gimenez, 1 for Mandel & Agol)')
9034      format(i1,19x,'Iseason (1 for seasonal Kepler contamination)')
c
 2025     format(f13.9,7x,'primmass (star 1 mass in solar masses)')
 2026     format(f14.9,6x,'primK (K-velocity of star 1 in km/sec)')
 2027     format(f14.9,6x,'primrad (star 1 radius in solar radii)')
 2028     format(f16.9,4x,
     &          'ratrad (ratio of star 1 radius and star 2 radius)')
c
 2030     format(f14.12,6x,'frac1 (fractional radius star 1: R_1/a)')
 2031     format(f14.12,6x,'frac2 (fractional radius star 2: R_2/a)')
 2032     format(f12.9,8x,'ecosw (phase difference between eclipses)')
 2033     format(f12.9,8x,'temprat (T_2/T_1)')
c
 2040     format(i1,19x,'idark1')
 2041     format(i1,19x,'idark2')
 2042     format(i6,14x,'Npoly (0 for numerical)')
 3043     format(i1,19x,'ifasttrans (>0 for fast transit mode)')


 1000     format(i4,16x,'Nalph1')
 1001     format(i3,17x,'Nbet1')
 1002     format(i4,16x,'Nalph2')
 1003     format(i3,17x,'Nbet2')
 1004     format(f11.9,9x,'fill1')
 1005     format(f11.9,9x,'fill2')
 1006     format(f11.7,9x,'omega1')
 1007     format(f11.7,9x,'omega2')
 1008     format(f11.6,9x,'dphase')
 1009     format(f15.10,5x,'Q')
 1010     format(f12.9,8x,'finc')
 1011     format(f11.4,9x,'Teff1')
 1012     format(f11.4,9x,'Teff2')
c
c  RVG BUG ALERT   May 16, 2001
c
c  Change the format statements for Tgrav:
c
 1013     format(f9.7,11x,'Tgrav1')
 1014     format(f9.7,11x,'Tgrav2')
c
 1015     format(f8.5,12x,'betarim')
 1016     format(f8.6,12x,'rinner')
 1017     format(f8.6,12x,'router')
 1018     format(f9.3,11x,'tdisk')
 2018     format(f9.6,11x,'xi')
 1019     format(i3,17x,'Ntheta')
 1020     format(i3,17x,'Nradius')
c
c   UPDATE March 26, 2002
c
c   The meaning of rLx is now log10(Lx)
c
c 1021     format(f10.5,10x,'Lx/Lopt')
 1021     format(f10.5,10x,'log10(Lx)')
 1023     format(f16.10,4x,'Period')
 1024     format(f8.5,12x,'fm')
 1025     format(f15.6,5x,'separ')
 1026     format(i1,19x,'idraw')
 1027     format(i1,19x,'iecheck')
 1028     format(i1,19x,'iidint')
 1042     format(f9.7,11x,'alb1')
 1043     format(f9.7,11x,'alb2')
c
c   UPDATE April 15, 2002
c
c   Change the format statement below to i2,18x
c
 2043     format(i2,18x,'Nref')
 2000     format(f7.1,2x,8(f9.6,1x))
 3028     format(i2,18x,'ilaw  (1=lin. law, 2=log. law,',
     %           ' 3=sqrt law, 4=quad. law)')
 4000     format(i1,19x,'iatm')
 4001     format(i1,19x,'ism1')
 4002     format(8(i1,1x),4x,'icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK')
 4025     format(f13.7,7x,'gamma velocity')
 5000     format(f13.5,7x,'t3')
 5001     format(f11.6,9x,'g3')
 5002     format(f12.6,8x,'SA3')
5003      format(f12.6,8x,'density in g/cc')
 5004     format(f12.6,8x,'onephase')
 5005     format(f12.6,8x,'usepot1')
 5006     format(f12.6,8x,'usepot2')
 5007     format(f16.9,4x,'T0 ')
 5008     format(i1,19x,'iRVfilt')
 5009     format(i1,19x,'ionephase')
 5010     format(i1,19x,'isquare')
 5011     format(i1,19x,'iusepot')
 5012     format(i1,19x,'ifixgamma')
 6000     format(f10.8,10x,'eccentricity')
 6001     format(f13.8,7x,'argument of peristron in degrees')
 6002     format(f11.8,9x,'pshift')
c
c   UPDATE April 8, 2002
c
c   Change format statement below.
c
 6003     format(f12.6,8x,'asini (projected semimajor axis in seconds)')
c
c   UPDATE May 27, 2002
c
c   Change this format statement
c
 6004     format(f12.6,8x,'median fit (geneticELC only)')
 6005     format(f12.6,8x,'sw7 (phase range when sw8>sw7>0)')
 6006     format(f12.6,8x,'sw8 (phase range when sw8>sw7>0)')
 6007     format(f13.7,7x,'sw9 (time step when itime=2)')
 6008     format(i1,19x,'ikeep (1 to put eclipse at phase 0.0)')
 6009     format(i1,19x,'isynch (1 to keep rotation synchronous',
     $         ' at periastron)')
 6010     format(i1,19x,'ispotprof')
 6011     format(i1,19x,'igrav')
 6012     format(i1,19x,'itime')
c
c  UPDATE JULY 4, 2004
c
c  The variable isw8 will be assigned to MonteCarlo, which
c  will be used to determine the number of Monte Carlo
c  integrations done on the pixels.
c
 6013     format(i6,14x,'MonteCarlo (0 for interpolation, >10 ',
     $        'for Monte Carlo)')
c
 6014     format(i6,14x,'ielite')
c
c  RVG BUG ALERT  May 9, 2001
c
c  Add these format statements.
c
 2001     format(f11.8, 9x,'Temperature factor spot 1, star 1')
 2002     format(f11.7, 9x,'Latitude of spot 1, star 1 (degrees)') 
 2003     format(f11.7, 9x,'Longitude of spot 1, star 1 (degrees)') 
 2004     format(f11.7, 9x,'Angular radius of spot 1, star 1 (degrees)') 

 2005     format(f11.8, 9x,'Temperature factor spot 2, star 1')
 2006     format(f11.7, 9x,'Latitude of spot 2, star 1 (degrees)') 
 2007     format(f11.7, 9x,'Longitude of spot 2, star 1 (degrees)') 
 2008     format(f11.7, 9x,'Angular radius of spot 2, star 1 (degrees)') 

 2009     format(f11.8, 9x,'Temperature factor spot 1, star 2')
 2010     format(f11.7, 9x,'Latitude of spot 1, star 2 (degrees)') 
 2011     format(f11.7, 9x,'Longitude of spot 1, star 2 (degrees)') 
 2012     format(f11.7, 9x,'Angular radius of spot 1, star 2 (degrees)') 

 2013     format(f11.8, 9x,'Temperature factor spot 2, star 2')
 2014     format(f11.7, 9x,'Latitude of spot 2, star 2 (degrees)') 
 2015     format(f11.7, 9x,'Longitude of spot 2, star 2 (degrees)') 
 2016     format(f11.7, 9x,'Angular radius of spot 2, star 2 (degrees)') 

 2017     format(f11.8, 9x,'Temperature factor spot 1, disk')
22018     format(f11.7, 9x,'Azimuth of spot 1, disk (degrees)') 
 2019     format(f11.7, 9x,'Radial cutoff of spot 1, disk (0 <= r_cut',
     @            ' <=1)') 
 2020     format(f11.7, 9x,'Angular size of spot 1, disk (degrees)') 

 2021     format(f11.8, 9x,'Temperature factor spot 2, disk')
 2022     format(f11.7, 9x,'Azimuth of spot 2, disk (degrees)') 
 2023     format(f11.7, 9x,'Radial cutoff of spot 2, disk (0 <= r_cut',
     @          ' <=1)') 
 2024     format(f11.7, 9x,'Angular size of spot 2, disk (degrees)') 
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine setuptemp(istar,ialphmax,ibetmax,Nalf,ibetlim,
     @       gmatrix,Tpole,Tgrav,tmatrix,gpole,mmdx)
c
c   This routine will assign the temperatures of the grid points
c   based on the polar temperature and the gravity darkening law.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0)
          dimension gmatrix(ialphmax*ibetmax),tmatrix(ialphmax*ibetmax),
     %       ibetlim(ialphmax),mmdx(ialphmax,ibetmax)
c
          tmax=-123456.0d0
          tmin=123456.0d0
          gmin=123456.0d0
          gmax=-123456.0d0
          DIV = gpole                  ! gravity at the pole
c
          DO 10 IALF = 1, NALF
            DO 9 IBET = 1, ibetlim(ialf)    !4*NBET
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              G_div = gmatrix(iidx)/DIV
              tmatrix(iidx)=((G_div**Tgrav*Tpole))
c
c
c
c
c
c  
              if(tmatrix(iidx).lt.tmin)then
                tmin=tmatrix(iidx)
                iamin=ialf
                ibmin=ibet
              endif
              if(tmatrix(iidx).gt.tmax)then
                tmax=tmatrix(iidx)
                iamax=ialf
                ibmax=ibet
              endif
              if(gmatrix(iidx).lt.gmin)then
                gmin=gmatrix(iidx)
                iagmin=ialf
                ibgmin=ibet
              endif
              if(gmatrix(iidx).gt.gmax)then
                gmax=gmatrix(iidx)
                iagmax=ialf
                ibgmax=ibet
              endif
 9          continue
 10       continue
c
          write(2,100)istar,tmin,iamin,ibmin,tmax,iamax,ibmax
          write(2,101)istar,gmin,iagmin,ibgmin,gmax,iagmax,ibgmax
c
 100      format(/'star ',i1,':  min temp = ',f11.1,'   (at ialf = ',i4,
     %       ' ibet = ',i4,')',/'         max temp = ',f11.1,
     *       '     (at ialf = ',i4,
     %       ' ibet = ',i4,')')
 101      format('star ',i1,':  min grav = ',f11.1,'    (at ialf = ',i4,
     %        ' ibet = ',i4,', program units)',
     &                     /'         max grav = ',f11.1,
     @        '     (at ialf = ',i4,
     %        ' ibet = ',i4,', program units)')
c
          return
          end
c
c  ************************
c
          subroutine getcoords(istar,ialphmax,ibetmax,Nalf,ibetlim,
     $      phase,finc,Q,xarray,yarray,zarray,gradx,grady,gradz,temp,
     $      Ncoords,xcoords,ycoords,xend,extension,separation,bdist,
     &      mmdx,tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,
     @      isw7,tertOmega,icounttime)
c
c  October 9, 1999
c
c  This subroutine will return the sky coordinates of the star in the array
c  xcoords(1:Ncoords),ycoords(1:Ncoords).  Only the points that are visible
c  to the observer are included, and eclipses are not accounted for.
c
c  Set istar=1 to do star 1, istar=2 to do star2
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     $        zarray(ialphmax*ibetmax),xcoords(ialphmax*ibetmax*4),
     $        gradx(ialphmax*ibetmax),grady(ialphmax*ibetmax),
     $        gradz(ialphmax*ibetmax),ycoords(ialphmax*ibetmax*4),xend(4),
     $        temp(ialphmax*ibetmax),ibetlim(ialphmax),
     @        mmdx(ialphmax,ibetmax)
c
          character*9 extension
c
          proj=0.0d0
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
          if(istar.eq.1)open(unit=39,file='star1temp.'//extension,
     %               status='unknown')
          if(istar.eq.2)open(unit=39,file='star2temp.'//extension,
     %               status='unknown')

c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
          A2 = DACOS(AX)
          A3 = DSIN(A2)
          IF (A3.LT.0.0d0) A3=0.0d0
c          IF (A3.EQ.0.0d0) GO TO 508
c          B1=AZ/DSIN(A2)
c          IF(B1.GT.1.0d0) B1=1.0d0
c          BETA = DASIN(B1)              !beta is the angle between the surface
c          GO TO 509                    !normal and the radius vector.
c508       BETA = 0.0d0
c509       continue
c
          Ncoords=0
c
          if(istar.eq.1)then
            xx=0.0d0
            yy=0.0d0
            zz=0.0d0
          endif
          if(istar.eq.2)then
            xx=1.0d0
            yy=0.0d0
            zz=0.0d0
          endif
          xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)    ! projected coords
          yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
          xp=xp+xxoff
          yp=yp+yyoff
          Ncoords=Ncoords+1
          xcoords(Ncoords)=xp*separation
          ycoords(Ncoords)=yp*separation


c   Check the visibility of the nose and end
c
          do 10 i=1,2
            if(i.eq.1)proj=AX
            if(i.eq.2)proj=-AX
            if(proj.gt.0.0)then
              xp=xtran(xend(i+2),0.0d0,0.0d0,phase,fincr,Q,istar,bdist) 
              yp=ytran(xend(i+2),0.0d0,0.0d0,phase,fincr,Q,istar,bdist)    
              xp=xp+xxoff
              yp=yp+yyoff
              Ncoords=Ncoords+1
              xcoords(Ncoords)=xp*separation
              ycoords(Ncoords)=yp*separation
            endif
 10       continue
c
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              PROJ = AX * GRADX(iidx) + AY*GRADY(iidx) + 
     @            AZ*GRADZ(iidx)
              IF (PROJ.LT.0.0d0) GO TO 502    ! is the surface element visible?
              xx=xarray(iidx)
              yy=yarray(iidx)
              zz=zarray(iidx)
              xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) ! projected coords
              yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
              xp=xp+xxoff
              yp=yp+yyoff
              Ncoords=Ncoords+1
              xcoords(Ncoords)=xp*separation
              ycoords(Ncoords)=yp*separation
c
c   Record the x,y,z coordinates of the nearby points.  These points
c   will be used for area filling.
c
              xx1=xp*separation
              yy1=yp*separation
              if(ibet.gt.1)then
c                iidx=kount(ialphmax,ialf,ibetlim)+(ibet-1)
                iidx=mmdx(ialf,ibet-1)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
c                iidx=kount(ialphmax,ialf,ibetlim)+ibetlim(ialf)
                iidx=mmdx(ialf,ibetlim(ialf))
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              endif
              xx2=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy2=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx2=xx2+xxoff
              yy2=yy2+yyoff
              xx2=xx2*separation
              yy2=yy2*separation
              if(ialf.gt.1)then
                if(ibet.gt.1)then
                  izz=ialf-1
                  jzz=ibet-1
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                else
                  izz=ialf-1
                  jzz=ibetlim(ialf)
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                endif
              else
                xx=xend(1)
                yy=0.0d0
                zz=0.0d0
              endif
              xx3=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy3=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx3=xx3+xxoff
              yy3=yy3+yyoff
              xx3=xx3*separation
              yy3=yy3*separation
              if(ialf.gt.1)then
               izz=ialf-1
               jzz=ibet
c               iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
                xx=xend(1)
                yy=0.0d0
                zz=0.0d0
              endif
              xx4=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy4=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx4=xx4+xxoff
              yy4=yy4+yyoff
              xx4=xx4*separation
              yy4=yy4*separation
c
              izz=ialf
              jzz=ibet
c              iidx=kount(ialphmax,izz,ibetlim)+jzz
              iidx=mmdx(izz,jzz)
              write(39,69)temp(iidx),xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4
              if(ialf.eq.Nalf)then
                if(ibet.gt.1)then
                  izz=ialf
                  jzz=ibet-1
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                else
                  izz=ialf
                  jzz=ibetlim(ialf)
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                endif
                xx2=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                yy2=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                xx2=xx2+xxoff
                yy2=yy2+yyoff
                xx2=xx2*separation
                yy2=yy2*separation
c
                xx=xend(2)
                yy=0.0d0
                zz=0.0d0
                xx3=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                yy3=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
                xx3=xx3+xxoff
                yy3=yy3+yyoff
                xx3=xx3*separation
                yy3=yy3*separation
c
                xx=xend(2)
                yy=0.0d0
                zz=0.0d0
                xx4=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                yy4=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                xx4=xx4+xxoff
                yy4=yy4+yyoff
                xx4=xx4*separation
                yy4=yy4*separation
c   
                izz=ialf
                jzz=ibet
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(39,69)temp(iidx),xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4
              endif
c
502         CONTINUE
c
 501      continue         ! continue the alpha loop
c
 69       format(f7.1,1x,8(f7.4,2x))
c
          close(39)
          close(40)
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%
c
          double precision function xtran(xx,yy,zz,phase,fincr,Q,istar,
     $       bdist)
c
c   will return the coordinate of a point (xx,yy,zz) projected on the sky
c
c   (xx,yy,zz) refers to the coordinates in the rotating system
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q

c          if(istar.eq.2)xx=xx+bdist
c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif

          qphaser=((phaser))
c
c          xtran=(-xx*dsin(qphaser)-yy*dcos(qphaser))
c     $      -bdist*dsin(qphaser)*(overQ/(1.0d0+overQ))

          xtran=-(xx*dsin(qphaser)+yy*dcos(qphaser))+
     $      bdist*(overQ/(1.0d0+overQ))*dsin(qphaser)

c
c
c   RVG BUG ALERT   May 2, 2001
c
c   Comment out this if-then statement.
c
c          if(phase.gt.180.0d0)xtran=-xtran
c
c 
c   Added February 8, 2001
c
c          xtran=xtran*bdist
c
          return
          end
c
c  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          double precision function ytran(xx,yy,zz,phase,fincr,Q,istar,
     $         bdist)
c
c   will return the coordinate of a point (xx,yy,zz) projected on the sky
c
c   (xx,yy,zz) refers to the coordinates in the rotating system
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q

c          if(istar.eq.2)xx=xx+bdist
c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians).
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif

          qphaser=((phaser))

c          ytran=(xx*dcos(fincr)*dcos(qphaser)-yy*dcos(fincr)*dsin(qphaser)
c     $      +zz*dsin(fincr))
c     $      -bdist*dcos(fincr)*dcos(qphaser)*(overQ/(1.0d0+overQ))

          ytran=-(-xx*dcos(fincr)*dcos(qphaser)+
     @       yy*dcos(fincr)*dsin(qphaser)-zz*dsin(fincr))+
     $       bdist*(-(overQ/(1.0d0+overQ))*dcos(fincr)*dcos(qphaser))

c
c   RVG BUG ALERT   May 2, 2001
c
c   Comment out this statement.
c
c          if(phase.gt.180.0d0)ytran=-ytran
c
c   Added February 8, 2001
c
c          ytran=ytran*bdist
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine sortcircle(N,xcir,ycir)
c
c   October 7, 1999
c
c   This routine will arrange the (x,y) points of the polygon in order by
c   sorting by theta in polar coordinates.  Written by Orosz circa 1996.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xcir(N),ycir(N),theta(10000)
c
          call getmaxvalues(N,xcir,ycir,xmin,xmax,ymin,ymax)  !get the extreme
c                                                            !values
          xcenter=(xmax+xmin)/2.0d0
          ycenter=(ymax+ymin)/2.0d0
c
c   convert to polar coordinates         
c
          do 10 i=1,N
            xxx=xcir(i)-xcenter
            yyy=ycir(i)-ycenter
            if(xxx.eq.0.0)then
              if(yyy.lt.0.0)then
                theta(i)=3.0d0*pie/2.0d0
                go to 10
              endif
              if(yyy.ge.0.0d0)then
                theta(i)=pie/2.0d0
                go to 10
              endif
            endif
            if((yyy.ge.0.0d0).and.(xxx.ge.0.0d0))then
              theta(i)=(atan2(yyy,xxx))
            endif
            if((yyy.ge.0.0d0).and.(xxx.lt.0.0d0))then
              theta(i)=(atan2(yyy,xxx))
            endif
            if((yyy.lt.0.0d0).and.(xxx.lt.0.0d0))then
              theta(i)=2.0d0*pie+(atan2(yyy,xxx))
            endif
            if((yyy.lt.0.0d0).and.(xxx.ge.0.0d0))then
              theta(i)=2.0d0*pie+atan2(yyy,xxx)
            endif
 10       continue
c
          if(N.gt.1)then
            call sort3(N,theta,xcir,ycir)  !sort by theta and swap x and y also
          endif
c
          return
          end
c
c ==========================================================================
c
          subroutine getmaxvalues(N,xdata,ydata,xmin,xmax,ymin,ymax)
c
          implicit double precision(a-h,o-z)
c
          dimension xdata(N),ydata(N)
c
          xmin=100000000000.0d0
          ymin=100000000000.0d0
          xmax=-10000000.0d0
          ymax=-10000000.0d0
c
          do 10 i=1,N
            t1=xdata(i)
            q1=ydata(i)
            if(t1.gt.xmax)xmax=t1
            if(t1.lt.xmin)xmin=t1
            if(q1.gt.ymax)ymax=q1
            if(q1.lt.ymin)ymin=q1
 10       continue
          return
          end
c
c============================================================
c
          SUBROUTINE SORT3(N,RA,RB,rc)
c
c  October 7, 1999
c
c  This routine will sort an array RA, and rearrange the arrays rb and rc.
c  Taken from Numerical Recipes.
c
          implicit double precision(a-h,o-z)

          DIMENSION RA(N),RB(N),rc(N)
c
          L=N/2+1
          IR=N
10        CONTINUE
          IF(L.GT.1)THEN
            L=L-1
            RRA=RA(L)
            RRB=RB(L)
            rrc=rc(L)
          ELSE
            RRA=RA(IR)
            RRB=RB(IR)
            rrc=rc(IR)
            RA(IR)=RA(1)
            RB(IR)=RB(1)
            rc(IR)=RC(1)
            IR=IR-1
            IF(IR.EQ.1)THEN
              RA(1)=RRA
              RB(1)=RRB
              rc(1)=rrc
              RETURN
            ENDIF
          ENDIF
          I=L
          J=L+L
20        IF(J.LE.IR)THEN
            IF(J.LT.IR)THEN
              IF(RA(J).LT.RA(J+1))J=J+1
            ENDIF
            IF(RRA.LT.RA(J))THEN
              RA(I)=RA(J)
              RB(I)=RB(J)
              rc(i)=rc(j)
              I=J
              J=J+J
            ELSE
              J=IR+1
            ENDIF
            GO TO 20
          ENDIF
          RA(I)=RRA
          RB(I)=RRB
          rc(i)=rrc
          GO TO 10
          END
c
c   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
c
          subroutine dump(iunit,N,x,y)
c
          implicit double precision(a-h,o-z)
c
          dimension x(N),y(N)
          character*2 ext
c
          write(ext,100)iunit
          open(unit=iunit,file='fort.'//ext,status='unknown')
          do 10 i=1,N
            write(iunit,200)x(i),y(i)
 10       continue
c
          close(iunit)
 100      format(i2)
 200      format(f7.5,3x,f10.8)
          return
          end
c
c   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
c 
          subroutine gethorizon(istar,ialphmax,ibetmax,Nalf,
     @      ibetlim,phase,finc,Q,psi0,omega,xarray,yarray,zarray,
     @      radarray,gradx,grady,gradz,xend,Nhoriz,xhoriz,yhoriz,phiar,
     @      iedgestar,delphiedge,bdist,mmdx,xhmin,xhmax,yhmin,yhmax,
     @      tidephi,itide,phihor,ecc,thetamis,phimis,tertincl,tertbdist,
     @      tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
c  October 9, 1999
c
c  This subroutine will return the sky coordinates of the horizon of the star
c  xhoriz(1:Nhoriz),yhoriz(1:Nhoriz).  For phases near conjunction, go along
c  the alpha direction and record when the "projection factor" turns negative.
c  For phases near quadrature, so a similar loop in the beta direction.
c
c  Set istar=1 to do star 1, istar=2 to do star2
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
c   UPDATE JULY 2, 2004
c
c   Add this parameter for the temparary arrays.
c
          parameter(itemp=10000)
          dimension xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     $        zarray(ialphmax*ibetmax),xhoriz(4*ibetmax),
     @        yhoriz(4*ibetmax),gradx(ialphmax*ibetmax),
     @        grady(ialphmax*ibetmax),xend(4),gradz(ialphmax*ibetmax),
     @        arrproj(itemp),xdummy(itemp),ydummy(itemp),
     @        phiar(ialphmax*ibetmax),
     @        radarray(ialphmax*ibetmax),ibetlim(ialphmax),
     @        iedgestar(ialphmax*ibetmax),delphiedge(ialphmax*ibetmax)
          dimension mmdx(ialphmax,ibetmax),phihor(ialphmax,4)
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c  initialize
c
          do 1 i=1,itemp
            xdummy(i)=0.0d0
            ydummy(i)=0.0d0
 1        continue
c
          do 3 ialf=1,nalf
            phihor(ialf,1)=-99.00d0
            phihor(ialf,2)=-99.00d0
            do 2 ibet=1,ibetlim(ialf)   !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              iedgestar(iidx)=0
              delphiedge(iidx)=-99.99d0
 2          continue
 3        continue
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
cc
          Ndummy=0
c
c   Loop over alpha first.  
c
          do 950 ialf=1,nalf       
            do 949 ibet=1,ibetlim(ialf)     !nbet4   
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              arrproj(ibet)=AX*GRADX(iidx) + AY*GRADY(iidx) + 
     @           AZ*GRADZ(iidx)
 949        continue
c
c   We have the array of projection factors along a given direction.
c   Now find out where the sign change is.  This is where the line of sight
c   has moved over the horizon.
c
            ihorcount=1
            do 940 ibet=1,ibetlim(ialf)    !nbet4-1
              if(ibet.lt.ibetlim(ialf))then
                index=ibet+1
              else
                index=1
              endif
              rsign=arrproj(ibet)*arrproj(index)
              if(rsign.le.0.0d0)then     ! crossed over
                if(arrproj(ibet).gt.0.0d0)then
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgestar(iidx)=10
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgestar(iidx)=-10
                  index=ibet
                else
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgestar(iidx)=20     ! just appeared at limb
c
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgestar(iidx)=-10     ! just went behind limb
                endif
c
                call acchor(overQ,psi0,omega,
     $              xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,
     $              phihid,ax,ay,az,xacc,yacc,zacc,bdist,tidephi,
     @              itide,ecc,thetamis,phimis)
c
                xx=xacc  
                yy=yacc  
                zz=zacc  
c
                phihor(ialf,ihorcount)=phivis
                ihorcount=ihorcount+1
                izz=ialf
                jzz=ibet
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                diff=(phiar(iidx)-phivis)
                if(dabs(diff).lt.2.0d0)then
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  delphiedge(iidx)=dabs(phiar(iidx)-phivis)
                endif
                if(dabs(diff).ge.2.0d0)then
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  if(phiar(iidx).gt.4.0)then
                    phitemp=2.0*pie-phiar(iidx)
                    delphiedge(iidx)=(phitemp+phivis)
                  endif
                  if(phivis.gt.4.0d0)then
                    phitemp=2.0*pie-phivis
                    izz=ialf
                    jzz=index
c                    iidx=kount(ialphmax,izz,ibetlim)+jzz
                    iidx=mmdx(izz,jzz)
                    delphiedge(iidx)=(phitemp+phiar(iidx))
                  endif
                endif
c
                xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)  
                yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
                xp=xp+xxoff
                yp=yp+yyoff
                Ndummy=Ndummy+1
                xdummy(Ndummy)=xp
                ydummy(Ndummy)=yp
              endif
 940        continue
 950      continue
c
c   Now put beta on the outside loop and look for points when the line
c   of sight passes over the horizon.
c
          kk=1
          do 1950 ibet=1,ibetlim(kk)   !nbet4
            do 1949 ialf=kk,nalf
              izz=ialf
              jzz=ibet
c              iidx=kount(ialphmax,izz,ibetlim)+jzz  ! was (kk)
               iidx=mmdx(izz,jzz)
              arrproj(ialf)=AX*GRADX(iidx) + AY*GRADY(iidx) + 
     @          AZ*GRADZ(iidx)
 1949       continue
c
c   Now find out where the sign change is.  This is where the line of sight
c   has moved over the horizon.
c
            do 1940 ialf=kk,nalf-1
              if(ialf.lt.nalf)then
                index=ialf+1
              else
                index=kk
              endif
              rsign=arrproj(ialf)*arrproj(index)
              if(rsign.le.0.0d0)then     ! crossed over
                if(arrproj(ialf).gt.0.0)then
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgestar(iidx)=30     ! just appeared at limb
c
                  izz=index
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                else
                  izz=index
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgestar(iidx)=30     ! just appeared at limb
c
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                endif
c
                call acchor(overQ,psi0,omega,
     $              xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,
     $              phihid,ax,ay,az,xacc,yacc,zacc,bdist,tidephi,
     %              itide,ecc,thetamis,phimis)
c
                xx=xacc  
                yy=yacc  
                zz=zacc  
c
                xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)  
                yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
                xp=xp+xxoff
                yp=yp+yyoff
                Ndummy=Ndummy+1
                xdummy(Ndummy)=xp
                ydummy(Ndummy)=yp
              endif
 1940       continue
 1950     continue
c
c   Check the visibility of the nose and see if it should be in
c   the horzon
c
          if((phase.eq.90.0d0).or.(phase.eq.270.0d0))then   ! both ends visible
            xp=xtran(xend(3),0.0d0,0.0d0,phase,fincr,Q,istar,bdist) 
            yp=ytran(xend(3),0.0d0,0.0d0,phase,fincr,Q,istar,bdist)   
            Ndummy=Ndummy+1      ! outside the first ring.  Include the
            xdummy(Ndummy)=xp    ! point in the horizon
            ydummy(Ndummy)=yp
            xp=xtran(xend(4),0.0d0,0.0d0,phase,fincr,Q,istar,bdist) 
            yp=ytran(xend(4),0.0d0,0.0d0,phase,fincr,Q,istar,bdist)    
            xp=xp+xxoff
            yp=yp+yyoff
c            Ndummy=Ndummy+1      ! outside the first ring.  Include the
c            xdummy(Ndummy)=xp    ! point in the horizon
c            ydummy(Ndummy)=yp
c            go to 69
          endif
c
c   Now 'sort' the horizon points so that a regular polygon is made.  If
c   we are near the quadrature phases, then use the old algorithm.  For
c   other phases, use the new algorithm which returns horizon points for
c   every degree in polar coordinates.
c
c          if(((phase.gt.80.0d0).and.(phase.lt.100.0d0)).or.
c     %       ((phase.gt.260.0d0).and.(phase.lt.280.0d0)).and.idraw.ge.1)then
c 69         call sortcircle(Ndummy,xdummy,ydummy)
cc
cc   The above array may have repeated points.  Remove them.
cc
c            call uniquepoint(Ndummy,xdummy,ydummy,Nhoriz,xhoriz,yhoriz)
c          else
c
            call newsortcircle(Ndummy,xdummy,ydummy,Nhoriz,
     $         xhoriz,yhoriz,ibetmax,xhmin,xhmax,yhmin,yhmax)

c            write(*,*)istar,phase,Ndummy,Nhoriz

c          endif
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%
c
          subroutine uniquepoint(Nbig,xbig,ybig,Ntrim,xtrim,ytrim)
c
c   October 8, 1999
c
c   This routine will take the large arrays xbig and ybig and remove
c   possible duplicate points.  It is assumed that the arrays xbig
c   and ybig have been passed to 'sortcircle' so that duplicate points
c   are in adjacent array positions.
c
          implicit double precision(a-h,o-z)
c
          dimension xbig(Nbig),ybig(Nbig),xtrim(Nbig),ytrim(Nbig)
c
c   UPDATE JULY 2, 2004
c
c   Change the threshold to 1.0d-5
c
          Ntrim=0
          do 10 i=2,Nbig
            t1=xbig(i)-xbig(i-1)
            t2=ybig(i)-ybig(i-1)
            distance=dsqrt(t1*t1+t2*t2)
            if(distance.gt.1.0d-5)then
              Ntrim=Ntrim+1
              xtrim(Ntrim)=xbig(i-1)
              ytrim(Ntrim)=ybig(i-1)
            endif
 10       continue
c
c   Are the two points at the end the same?  If not, then write the last one.
c
          t1=xbig(Nbig)-xbig(Nbig-1)
          t2=ybig(Nbig)-ybig(Nbig-1)
          distance=dsqrt(t1*t1+t2*t2)
          if(distance.gt.1.0d-5)then
            Ntrim=Ntrim+1
            xtrim(Ntrim)=xbig(Nbig)
            ytrim(Ntrim)=ybig(Nbig)
          endif
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine insidecircle(N,xcir,ycir,xp,yp,iyes,icut)
c
c
c   UPDATE May 8, 2006
c
c   Get rid of the call to checkbetween since that takes up lots of CPU time.
c   Use a simple if-then statement.
c
c    given a polygon with N points (they need to be in order), this
c    routine will check to see if the point (xp,yp) is inside the polygon
c
c    iyes=0 means that the point is outside
c    iyes=100 means that the point is inside
c
          implicit double precision(a-h,o-z)
c
          dimension xcir(N),ycir(N)
c
          iyes=0
c
c          call getmaxvalues(N,xcir,ycir,xmin,xmax,ymin,ymax)  !get the extreme
cc                                                             !values
c          if(xp.le.xmin)then         ! check to see if the
c             iyes=0
c             icut=-100               ! point is anywhere
c             return                  ! near the projected polygon
c          endif
cc
c          if(xp.ge.xmax)then
c             iyes=0
c             icut=-100
c             return
c          endif
cc
c          if(yp.le.ymin)then
c             iyes=0
c             icut=2
c             return
c          endif
cc
c          if(yp.ge.ymax)then
c             iyes=0
c             icut=0
c             return
c          endif
c
c    Now draw a line parallel to the y-axis to see how many sides are 
c    intersected -- if the number is even, then the point is outside.
c
          icut=0
          do 10 i=1,N-1
c
c            xx1=xcir(i)
c            xx2=xcir(i+1)
c            call checkbetween(xp,xx1,xx2,between)
c
c            if(between)then
            if(((xcir(i).le.xp).and.(xp.le.xcir(i+1))).or.
     &          ((xcir(i+1).le.xp).and.(xp.le.xcir(i))))then
c  
c              call getline(yline,xp,xcir(i),xcir(i+1),ycir(i),
c     $            ycir(i+1))
c
              if(xcir(i)-xcir(i+1).eq.0.0d0)yline=ycir(i)
              slope=(ycir(i)-ycir(i+1))/(xcir(i)-xcir(i+1))
              yline=slope*(xp-xcir(i))+ycir(i)
              if((yp.le.yline))icut=icut+1
            endif
 10       continue
c
c          xx1=xcir(1)
c          xx2=xcir(N)
c
c          call checkbetween(xp,xx1,xx2,between)
c          if(between)then
c
          if(((xcir(1).le.xp).and.(xp.le.xcir(N))).or.
     &          ((xcir(N).le.xp).and.(xp.le.xcir(1))))then  
c
c            call getline(yline,xp,xcir(1),xcir(N),ycir(1),
c     $            ycir(N))
c
              if(xcir(1)-xcir(N).eq.0.0d0)yline=ycir(1)
              slope=(ycir(1)-ycir(N))/(xcir(1)-xcir(N))
              yline=slope*(xp-xcir(1))+ycir(1)

            if((yp.le.yline))icut=icut+1
          endif
c
          if((icut.eq.1).or.(icut.eq.3).or.(icut.eq.5))then
            iyes=100    ! inside
          endif
          if((icut.eq.0).or.(icut.eq.2).or.(icut.eq.4))then
            iyes=0      ! outside
          endif
c
c         if((yp.lt.ymax).and.(iyes.eq.0))icut=2
c
          return
          end
c
c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c   UPDATE May 8, 2006
c
c   retire this subroutine, since it takes up too much CPU time.
c
c          subroutine checkbetween(xp,x1,x2,between)
cc
cc    October 8, 1999
cc
cc    This routine will check to see if the point xp is bewteen x1 and
cc    x2 on the x-axis.  between = .true. if this is the case.
cc    This is from 1995-1996 changes to the Avni code
cc    by Orosz.
cc
c          implicit double precision(a-h,o-z)
c
c          logical between
cc
c          between=.false.
cc
c          if((xp.ge.x1).and.(xp.lt.x2))between=.true.
c          if((xp.gt.x2).and.(xp.le.x1))between=.true.
cc          
cc    the points x1 and x2 may come in reverse order, so two statements
cc    are needed
cc
c          return
c          end
c
c ==========================================================================
c
          subroutine getline(yline,xp,x1,x2,y1,y2)
c
c    October 8, 1999
c
c    Check to see if the point (xp,yp) is above the line connecting
c    (x1,y1) and (x2,y2).  This is from 1995-1996 changes to the Avni code
c    by Orosz.
c
c
          implicit double precision(a-h,o-z)
c
         if(x1-x2.eq.0.0d0)then
           yline=(y1)
c           write(*,*)'error in getline: x1=x2'
           return
         endif
c
         slope=(y1-y2)/(x1-x2)
c
         yline=slope*(xp-x1)+y1
c
         return
         end
c
c  *************************************************************************
c
          subroutine getvisib(istar,ialphmax,ibetmax,Nalf,ibetlim,
     %      phase,finc,Q,psi0,omega,gradx,grady,gradz,xarray,yarray,
     @      zarray,xend,visib,Nhoriz,xhoriz,yhoriz,iidint,Ndhoriz,
     @      dxhoriz,dyhoriz,Ndtop,dtopx,dtopy,Ncoords,xcoords,ycoords,
     @      projarray,iecheck,Neclipse,phiar,radarray,delphi,
     @      iedgehor,bdist,mmdx,MonteCarlo,isw13,ialfmin,ialfmax,
     @      xhmin,xhmax,yhmin,yhmax,tidephi,itide,
     @      phistart,ecc,thetamis,phimis,Nhoriz3,xhoriz3,yhoriz3,i3flag,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega)
c
c  October 9, 1999
c
c  This routine will compute the 'projection' factor of each grid element on
c  the star (istar=1 to do star 1, istar=2 to do star2), check for eclipses
c  (the horizon of the other body is in xhoriz,yhoriz), and return the
c  sky coordinates of the visible points.  Set iecheck = -1 to skip the
c  check for 
c  eclipses.
c
c  UPDATE JULY 4, 2004
c
c  Add jdum and MonteCarlo to the argument list.  If MonteCarlo > 10,
c  then use Monte Carlo integration to determine fractionally
c  eclipsed pixels.  If MonteCarlo < 10, then proceed as before
c  and use interpolation in getBBflux and getATMflux.
c
c   UPDATE May 3, 2006
c
c   Add a "fast transit" mode.  If isw13 > 0, then consider ialf ranges
c   only between ialfmin and ialfmax
c
c   UPDATE May 8, 2006
c
c   Add the minimum and maximum x and y-values of the horizon.  Do
c   an if-then check to determine of insidecircle should be called.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          parameter(twopie=2.0d0*pie)
          dimension visib(ialphmax*ibetmax),xcoords(ialphmax*ibetmax*4),
     $        gradx(ialphmax*ibetmax),grady(ialphmax*ibetmax),
     $        gradz(ialphmax*ibetmax),ycoords(ialphmax*ibetmax*4),
     $        xhoriz(Nhoriz),yhoriz(Nhoriz),xend(4),
     @        xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     @        zarray(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     @        dxhoriz(Ndhoriz),dyhoriz(Ndhoriz),dtopx(Ndtop),
     @        dtopy(Ndtop),ibetlim(ialphmax),phiar(ialphmax*ibetmax),
     @        ihid(200000), radarray(ialphmax*ibetmax),
     @        delphi(ialphmax*ibetmax),iedgehor(ialphmax*ibetmax),
     @        mmdx(ialphmax,ibetmax)
          dimension phistart(ialphmax)
          dimension xhoriz3(Nhoriz3),yhoriz3(Nhoriz3)
c
c   UPDATE JULY 7, 2004
c
c   Use the sub-random Sobel sequence instead of ran9.  xsob is needed
c   for this.
c
          dimension xsob(2)
c
c   Initialize some variables here
c
          proj=0.0d0
          theta=0.0d0
          ibet=1
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c  initialize the visibities!
c
          do 1 i=1,nalf
            do 2 j=1,ibetlim(i)  !4*nbet
c              iidx=(i-1)*ibetlim(i)+j
              iidx=mmdx(i,j)
              visib(iidx)=0.0d0
              projarray(iidx)=-1.0d0
              ihid(iidx)=-1
              delphi(iidx)=-999.9d0
              iedgehor(iidx)=-999
 2          continue
 1        continue
c
c    UPDATE May 3, 2006
c
c    Keep track of the smallest and largest values of ialf on star 1 that
c    are eclipsed.
c
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
c
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
c
c   Check to see of the star in question is in front.  If so, then simply
c   find the projection factors.
c
          infront=0
          Ncoords=0
          Neclipse=0
          if((istar.eq.1).and.((phase.ge.0.0d0).
     @           and.(phase.lt.90.0d0)))infront=1
          if((istar.eq.1).and.((phase.ge.270.0d0).
     @           and.(phase.le.360.0d0)))infront=1
          if((istar.eq.2).and.((phase.ge.0.0d0).
     @           and.(phase.lt.90.0d0)))infront=1
          if((istar.eq.2).and.((phase.ge.270.0d0).
     $           and.(phase.le.360.0d0)))infront=1
c
          do 10 i=1,2
            if(i.eq.1)proj=AX
            if(i.eq.2)proj=-AX
            if(proj.gt.0.0d0)then
              xp=xtran(xend(i+2),0.0d0,0.0d0,phase,fincr,Q,istar,bdist) 
              yp=ytran(xend(i+2),0.0d0,0.0d0,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
c
c   If we are looking at star 2 and there is a disk, then check to see if
c   the points are *inside* the top horizon of the disk.
c
              if((iidint.ge.1).and.(istar.eq.2))then
                if(iecheck.ge.0)then
                  iyes=-100
                  call insidecircle(Ndtop,dtopx,dtopy,xp,yp,iyes,icut)
                  if(iyes.ne.100)go to 10   ! the point is outside the
                endif                       ! top horizon, so it is beneath the
              endif                         ! rim.

              if(infront.eq.1)then        
                Ncoords=Ncoords+1    
                xcoords(Ncoords)=xp
                ycoords(Ncoords)=yp
              else
                if(iecheck.ge.0)then
                  iyes=-100
                  call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,
     @               icut)
                  if(iyes.eq.100)then
                    go to 10       ! eclipsed by star 2
                  endif
                endif
c
c   UPDATE JUNE 17, 2005
c
c   Add if.iidint.gt.0 to if-then
c
                if((istar.eq.1).and.(iidint.gt.0))then 
                  if(iecheck.ge.0)then 
                    call insidecircle(Ndhoriz,dxhoriz,dyhoriz,xp,yp,
     @                iyes,icut)
                    if(iyes.eq.100)then
                      go to 10     ! eclipsed by disk
                    endif
                  endif
                endif
              
                Ncoords=Ncoords+1
                xcoords(Ncoords)=xp
                ycoords(Ncoords)=yp
              endif
            endif
 10       continue
c
          iimin=123456
          iimax=-12345
c!!omp parallel private(ialf,ibet,iidx,proj,xx,yy,zz,xp,yp,
c!!omp@ iyes,icut)  shared(ihid,projarray,isw13,istar,ialfmin,ialfmax,
c!!omp@ ibetlim,ax,ay,az,gradx,grady,gradz,xarray,yarray,zarray,phase,
c!!omp@ fincr,Q,bdist,i3flag,Nhoriz3,xhoriz3,yhoriz3,visib,iecheck,
c!!omp@ Ndhoriz,dxhoriz,dyhoriz,Ndtop,dtopx,dtopy,xcoords,ycoords,
c!!omp@ xhmin,xhmax,yhmin,yhmax,iimin,iimax,iidint,xxoff,yyoff,infront,
c!!omp@ Ncoords,Neclipse,Nhoriz,xhoriz,yhoriz,Nalf)
c!!omp flush
c!!omp do
          DO 501 IALF = 1, NALF
            if((isw13.gt.0).and.(istar.eq.1))then
              if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax))go to 501
            endif
            DO 502 IBET = 1,ibetlim(ialf)      !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              PROJ = AX * GRADX(iidx) + AY*GRADY(iidx) + 
     @           AZ*GRADZ(iidx)
              projarray(iidx)=proj
              IF (PROJ.LT.0.) GO TO 502    ! is the surface element visible?
              xx=xarray(iidx)
              yy=yarray(iidx)
              zz=zarray(iidx)
              xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) ! projected coords
              yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
c
c  if I3flag=1, then the third body is in front of the binary.  Check
c  for eclipses
c
              if(i3flag.ge.1)then
                iyes=-100
                call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes,
     @              icut)
                if(iyes.eq.100)then
                    Neclipse=Neclipse+1
                    ihid(iidx)=4
                  go to 502   
                 endif
               endif
c
c   Check to see of the point in question is eclipsed by the other star, or
c   in the case of star 1, eclipsed by the disk, or
c   in the case of a point on the bottom half of star 2, eclipsed by the disk. 
c   icut=2 for points outside and below the horizon.
c 
              if(infront.eq.1)then 
                if((iidint.ge.1).and.(istar.eq.2).and.(zz.lt.0.0d0))then
                  iyes=-100
                  call insidecircle(Ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,
     @               icut)
                  if(iyes.eq.100)then
                    ihid(iidx)=2     !eclipsed by disk
                    go to 502   
                  endif
                endif
                if((iidint.ge.1).and.(istar.eq.2).and.(zz.ge.0.0d0))then
                  icut=-100
                  iyes=-100
                  call insidecircle(Ndtop,dtopx,dtopy,xp,yp,iyes,icut)
                  if((iyes.eq.0).and.(icut.eq.2))then
                    ihid(iidx)=3
                    go to 502
                  endif
                endif
                Ncoords=Ncoords+1  
                xcoords(Ncoords)=xp
                ycoords(Ncoords)=yp
                visib(iidx)=proj
              else
                iyes=-100
                if(iecheck.ge.0)then
c
c   UPDATE May 8, 2006
c
c   Add these if-then statements to see if insidecircle should be called.
c              
                  if(((xhmin.lt.xp).and.(xp.lt.xhmax)).and.
     @                ((yhmin.lt.yp).and.(yp.lt.yhmax)))then
                    call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,
     @                icut)
                    if(iyes.eq.100)then
                      Neclipse=Neclipse+1
                      ihid(iidx)=1
c
c   UPDATE JULY 1, 2004
c
c   Add this to determine the latitude rows above and below the eclipsing
c   horizon.
c
                      if(ialf.lt.iimin)iimin=ialf
                      if(ialf.gt.iimax)iimax=ialf
                      go to 502
                    endif
                  endif
                endif
                if((iidint.ge.1).and.(istar.eq.2).and.(zz.lt.0.0d0))then
                  iyes=-100
                  call insidecircle(Ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,
     @               icut)
                  if(iyes.eq.100)then
                    ihid(iidx)=2
                    go to 502
                  endif   
                endif
                if((iidint.ge.1).and.(istar.eq.1).and.(iecheck.ge.0))then
                  iyes=-100
                  call insidecircle(Ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,
     @                icut)
                  if(iyes.eq.100)then
                    Neclipse=Neclipse+1
                    ihid(iidx)=2
                    go to 502   
                  endif
                endif
c
c   Finally, if the star in question is star 2 and there is a disk, we
c   must check to see if the point is inside the top horizon of the disk.
c   Points outside this horizon and below it are beneath the rim.  Points
c   outside this horizon and above it are still visible.  icut=2
c   for points outside and below.
c
                if((iidint.ge.1).and.(istar.eq.2).and.(zz.ge.0.0d0))then
                  icut=-100
                  iyes=-100
                  call insidecircle(Ndtop,dtopx,dtopy,xp,yp,iyes,icut)
                  if((iyes.eq.0).and.(icut.eq.2))then
                    ihid(iidx)=3
                    go to 502
                  endif
                endif
                Ncoords=Ncoords+1
                xcoords(Ncoords)=xp
                ycoords(Ncoords)=yp
                visib(iidx)=proj
              endif                    ! end if in front
c
502         CONTINUE
 501      continue         ! continue the alpha loop

c!!omp enddo
c!!omp end parallel
c
c          if(Neclipse.eq.0)return
c
c   Now we have to go along the beta direction and find out which visible
c   point is nearest to the eclipsing horizon.
c
          do 602 ialf=1,Nalf 
            if((isw13.gt.0).and.(istar.eq.1))then
              if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax))go to 602
            endif
            do 601 ibet=1,ibetlim(ialf)      !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              if(projarray(iidx).le.0.0d0)go to 601
              if(ibet.lt.ibetlim(ialf))then
                index=ibet+1
              else
                index=1
              endif
c
              izz=ialf
              jzz=index
c              jjdx=kount(ialphmax,izz,ibetlim)+jzz
              jjdx=mmdx(izz,jzz)
              if(projarray(jjdx).le.0.0d0)go to 601
              izz=ialf
              jzz=ibet
c              iidx=kount(ialphmax,izz,ibetlim)+jzz
              iidx=mmdx(izz,jzz)
              ksign=ihid(iidx)*ihid(jjdx)
c
              if(ksign.le.-1)then  ! crossed through the horizon
                if(ihid(iidx).eq.-1)then
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgehor(iidx)=10
c
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgehor(iidx)=-10
                  index=ibet
                else
                  izz=ialf
                  jzz=index
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgehor(iidx)=20
c
                  izz=ialf
                  jzz=ibet
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgehor(iidx)=-10
                endif                
                xpv=xtran(xvis,yvis,zvis,phase,fincr,Q,istar,bdist)  
                ypv=ytran(xvis,yvis,zvis,phase,fincr,Q,istar,bdist)  
                xpv=xpv+xxoff
                ypv=ypv+yyoff  
                xph=xtran(xhid,yhid,zhid,phase,fincr,Q,istar,bdist)  
                yph=ytran(xhid,yhid,zhid,phase,fincr,Q,istar,bdist)    
                xph=xph+xxoff
                yph=yph+yyoff
c
c                if(ksign.eq.-1)call clip(Nhoriz,xhoriz,yhoriz,
c     $             xpv,ypv,xph,yph,xedge,yedge)
c                if(ksign.eq.-2)call clip(Ndhoriz,dxhoriz,dyhoriz,
c     $             xpv,ypv,xph,yph,xedge,yedge)
c                if(ksign.eq.-3)call clip(Ndtop,dtopx,dtopy,
c     $             xpv,ypv,xph,yph,xedge,yedge)
c
c   UPDATE March 26, 2002
c
c   Remove the variable separ from the argument list of accphi.
c
c
c   UPDATE JULY 4, 2004
c
c   If MonteCarlo<10, then we need these calls to use interpolation.
c
                if(MonteCarlo.lt.10)then
                  if(ksign.eq.-1)call accphi(Q,psi0,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Nhoriz,xhoriz,yhoriz,phiacc,bdist,
     @               tidephi,itide,ecc,thetamis,phimis,tertincl,
     @               tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @               tertOmega)
c
                  if(ksign.eq.-2)call accphi(Q,psi0,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Ndhoriz,dxhoriz,dyhoriz,phiacc,bdist,
     @               tidephi,itide,ecc,thetamis,phimis,tertincl,
     @               tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @               tertOmega)
c
                  if(ksign.eq.-3)call accphi(Q,psi0,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Ndtop,dtopx,dtopy,phiacc,bdist,tidephi,
     @               itide,ecc,thetamis,phimis,tertincl,tertbdist,
     @               tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
                  if(ksign.eq.-4)call accphi(Q,psi0,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Nhoriz3,xhoriz3,yhoriz3,phiacc,bdist,
     @               tidephi,itide,ecc,thetamis,phimis,tertincl,
     @               tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @               tertOmega)
c
c                 iidx=kount(ialphmax,ialf,ibetlim)+index
                  iidx=mmdx(ialf,index)
                  diff=(phiar(iidx)-phiacc)
c
                  if(dabs(diff).lt.2.0d0)then
                    delphi(iidx)=(phiar(iidx)-phiacc)
                  endif
                  if(dabs(diff).ge.2.0d0)then
                    if(phiar(iidx).gt.4.0d0)then
                      phitemp=2.0d0*pie-phiar(iidx)
                      delphi(iidx)=(phitemp+phiacc)
                    endif
                    if(phiacc.gt.4.0d0)then
                      phitemp=2.0d0*pie-phiacc
                      delphi(iidx)=(phitemp+phiar(iidx))
                    endif
                  endif
                endif      !    if MonteCarlo < 10
              endif
c
c
601        continue
602      continue
c

c   UPDATE JULY 4, 2004
c
c   if -10 < MonteCarlo < 10, then we are done.
c
         if((MonteCarlo.lt.10).and.(MonteCarlo.gt.-10))return

c   UPDATE JULY 1, 2004
c
c   Add a loop which will use Monte Carlo integration to
c   determine what fraction of a pixel is partially eclipsed
c   by the horizon of the star in front.  The variable MonteCarlo
c   sets the number of integrations.
c
          dtheta=pie/dble(Nalf)
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
          iimin=iimin-1
          if(MonteCarlo.gt.10)then
            if(iimin.lt.1)iimin=1
          endif
          iimax=iimax+1
          if(MonteCarlo.gt.10)then
            if(iimax.gt.Nalf)iimax=Nalf
          endif
c
          do 702 ialf=1,Nalf
            if((isw13.gt.0).and.(istar.eq.1))then
              if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax))go to 7701
            endif
            r=0.0000001d0
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            do 701 ibet=1,ibetlim(ialf)      !4*Nbet
              iidx=mmdx(ialf,ibet)
c
              if(projarray(iidx).lt.0.0d0)go to 7701
c
c   UPDATE July 14, 2004
c
c   We have two options here.  If MonteCarlo > 10, then check
c   all pixels near the eclipsing horizon and get fractional
c   areas.  If MonteCarlo < -10, then check only the latitude row just
c   above the eclipsing horizon and the latitude row just below the
c   eclipsing horizon.
c
              if(MonteCarlo.gt.10)then
                if((iedgehor(iidx).eq.-10).or.(iedgehor(iidx).gt.5)
     %            .or.(ialf.eq.iimin).or.(ialf.eq.iimax)
     %            .or.(ialf.eq.iimin+1).or.(ialf.eq.iimax-1))then
                  dphi=twopie/dble(ibetlim(ialf))
                  phi=-0.5d0*dphi+dphi*dble(ibet)
                  phi=phi+phistart(ialf)
c
c   This loop will find random theta,phi locations on the pixel in
c   question, compute x,y,z coordinates on the star, and determine
c   if that location is eclipsed.  It will then determine the fraction
c   of the pixel that is eclipsed.
c
                  Nloop=MonteCarlo
                  NNhid=0
c
c   Do a check of the pixel corners and edges to see if they are eclipsed.
c   If all corners and all edges are eclipsed, then assume that the pixel
c   is completely hidden.  Likewise, if none of the corners or edges
c   are eclipsed, assume the pixel is completely visible
c
                  do 901 kk=-3,3
                    do 900 ll=-3,3
                      phinew=(dble(ll)/6.0d0)*dphi+phi
                      thetanew=(dble(kk)/6.0d0)*dtheta+theta          
                      snth=dsin(thetanew)
                      cnth=dcos(thetanew)
                      cox=dcos(phinew)*snth                !*dsin(theta)
                      coy=dsin(phinew)*snth                !*dsin(theta)
                      coz=cnth                          !dcos(theta)
                      CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
     $                 bdist,tidephi,itide,ecc,thetamis,phimis)
                      call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,
     @                   cox,coy,tidephi,itide,ecc,thetamis,phimis)
                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                      xp=xp+xxoff
                      yp=yp+yyoff
                      iyes=-1000
                      call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
     &                     iyes,icut)
                      if(i3flag.ge.1)then
                        call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xp,yp,
     &                     iyes,icut)
                      endif
c
                      if(iyes.eq.100)then
                        NNhid=NNhid+1
                      endif
 900                continue
 901              continue
c
                  if(NNhid.eq.0)go to 801   ! completely visible
                  if(NNhid.eq.49)then
                    NNhid=Nloop
                    go to 801        ! completely hidden
                  endif
                  NNhid=0
c
c   UPDATE July 7, 2004
c
c   Use the Sobel sequence instead of ran9.
c
                  nnn=2
                  do 800 jj=1,Nloop
c  
c                    phinew=(ran9(jdum)-0.5d0)*dphi+phi
c                    thetanew=(ran9(jdum)-0.5d0)*dtheta+theta          
c  
                    call sobseq(nnn,xsob)
                    phinew=(xsob(1)-0.5d0)*dphi+phi
                    thetanew=(xsob(2)-0.5d0)*dtheta+theta          
c  
                    snth=dsin(thetanew)
c                    snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                    cnth=dcos(thetanew)
                    cox=dcos(phinew)*snth                !*dsin(theta)
                    coy=dsin(phinew)*snth                !*dsin(theta)
                    coz=cnth                          !dcos(theta)
                    CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
     $                bdist,tidephi,itide,ecc,thetamis,phimis)
                    call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,
     @                   tidephi,itide,ecc,thetamis,phimis)
                    xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
                    yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                    xp=xp+xxoff
                    yp=yp+yyoff
                    iyes=-1000
                    call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,
     @                   icut)
                    if(i3flag.ge.1)then
                      call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes,
     @                  icut)
                    endif
                    if(iyes.eq.100)then
                      NNhid=NNhid+1
                    endif
 800              continue
 801              nvis=Nloop-NNhid
                  visib(iidx)=projarray(iidx)*(dble(nvis)/dble(Nloop))
                endif
              endif  ! end if MonteCarlo > 10
c
c  Check only the latitude row just above and just below.
c
              if(MonteCarlo.lt.-10)then
                if((ialf.eq.iimin).or.(ialf.eq.iimax))then
                  dphi=twopie/dble(ibetlim(ialf))
                  phi=-0.5d0*dphi+dphi*dble(ibet)
                  phi=phi+phistart(ialf)
c
c   This loop will find random theta,phi locations on the pixel in
c   question, compute x,y,z coordinates on the star, and determine
c   if that location is eclipsed.  It will then determine the fraction
c   of the pixel that is eclipsed.
c
                  Nloop=(abs(MonteCarlo))
                  NNhid=0
c
c   Do a check of the pixel corners and edges to see if they are eclipsed.
c   If all corners and all edges are eclipsed, then assume that the pixel
c   is completely hidden.  Likewise, if none of the corners or edges
c   are eclipsed, assume the pixel is completely visible
c
                  do 5901 kk=-3,3
                    do 5900 ll=-3,3
                      phinew=(dble(ll)/6.0d0)*dphi+phi
                      thetanew=(dble(kk)/6.0d0)*dtheta+theta          
                      snth=dsin(thetanew)
c                      snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                      cnth=dcos(thetanew)
                      cox=dcos(phinew)*snth                !*dsin(theta)
                      coy=dsin(phinew)*snth                !*dsin(theta)
                      coz=cnth                          !dcos(theta)
                      CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
     $                   bdist,tidephi,itide,ecc,thetamis,phimis)
                      call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,tidephi,
     &                   itide,ecc,thetamis,phimis)
                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                      xp=xp+xxoff
                      yp=yp+yyoff
                      iyes=-1000
                      call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
     @                  iyes,icut)
                      if(i3flag.ge.1)then
                         call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
     @                    iyes,icut)
                      endif
                      if(iyes.eq.100)then
                        NNhid=NNhid+1
                      endif
 5900               continue
 5901             continue
c
                  if(NNhid.eq.0)go to 5801   ! completely visible
                  if(NNhid.eq.49)then
                    NNhid=Nloop
                    go to 5801        ! completely hidden
                  endif
                  NNhid=0
c
c   UPDATE July 7, 2004
c
c   Use the Sobel sequence instead of ran9.
c
                  nnn=2
                  do 5800 jj=1,Nloop
c
c                  phinew=(ran9(jdum)-0.5d0)*dphi+phi
c                  thetanew=(ran9(jdum)-0.5d0)*dtheta+theta          
c
                    call sobseq(nnn,xsob)
                    phinew=(xsob(1)-0.5d0)*dphi+phi
                    thetanew=(xsob(2)-0.5d0)*dtheta+theta          
c  
                    snth=dsin(thetanew)
c                    snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                    cnth=dcos(thetanew)
                    cox=dcos(phinew)*snth                !*dsin(theta)
                    coy=dsin(phinew)*snth                !*dsin(theta)
                    coz=cnth                          !dcos(theta)
                    CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
     $               bdist,tidephi,itide,ecc,thetamis,phimis)
                    call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,
     &                   tidephi,itide,ecc,thetamis,phimis)
                    xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
                    yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
                    xp=xp+xxoff
                    yp=yp+yyoff
                    iyes=-1000
                    call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
     @                iyes,icut)
                    if(i3flag.ge.1)then
                      call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
     @                iyes,icut)
                    endif
                    if(iyes.eq.100)then
                      NNhid=NNhid+1
                    endif
 5800             continue
 5801             nvis=Nloop-NNhid
c                  write(*,987)dble(nvis)/dble(Nloop),ialf,ibet,istar
                  visib(iidx)=projarray(iidx)*(dble(nvis)/dble(Nloop))
                endif
              endif ! end if MonteCarlo < -10
c
c  UPDATE January 9, 2010
c
c  Check points near the limb and find the fractions of points
c  visible.
c
7701         go to 701    !this part really does not work, so skip it.
c
c                if(MonteCarlo.gt.10)then
c                if((iedgestar(iidx).eq.-10).or.(iedgestar(iidx).
c     @                             gt.5))then
c                  dphi=twopie/dble(ibetlim(ialf))
c                  phi=-0.5d0*dphi+dphi*dble(ibet)
c                  phi=phi+phistart(ialf)
cc
cc   This loop will find random theta,phi locations on the pixel in
cc   question, compute x,y,z coordinates on the star, and determine
cc   if that location is visible.  It will then determine the fraction
cc   of the pixel that is visible.
cc
c                  Nloop=40
c                  NNhid=0
cc
cc   Do a check of the pixel corners and edges to see if they are eclipsed.
cc   If all corners and all edges are eclipsed, then assume that the pixel
cc   is completely hidden.  Likewise, if none of the corners or edges
cc   are eclipsed, assume the pixel is completely visible
cc
cc                  do 9901 kk=-3,3
cc                    do 9900 ll=-3,3
cc                      phinew=(dble(ll)/6.0d0)*dphi+phi
cc                      thetanew=(dble(kk)/6.0d0)*dtheta+theta          
cc                      snth=dsin(thetanew)
cc                      snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
cc                      cnth=dcos(thetanew)
cc                      cox=dcos(phinew)*snth                !*dsin(theta)
cc                      coy=dsin(phinew)*snth                !*dsin(theta)
cc                      coz=cnth                          !dcos(theta)
cc                      CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
cc     $                 bdist,tidephi,itide,ecc,thetamis,phimis)
cc                      call POTEN(overQ,omega,xx,yy,zz,psi,
cc     $                   psix,psixx,psiy,psiz,1,bdist,
cc     @                   cox,coy,tidephi,itide,ecc,thetamis,phimis)
cc                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
cc                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
cc                      iyes=-1000
cc                      call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
cc                      if(iyes.eq.100)then
cc                        NNhid=NNhid+1
cc                      endif
cc 9900               continue
cc 9901             continue
cc
cc                  write(*,*)istar,ialf,ibet,NNhid
cc                  Nkeep=NNhid
cc
cc                  if(NNhid.eq.0)go to 8801   ! completely visible
cc                  if(NNhid.eq.49)then
cc                    NNhid=Nloop
cc                    go to 8801        ! completely hidden
cc                  endif
cc
c                  NNhid=0
c                  psum=0.0d0
cc
cc   Use the Sobel sequence instead of ran9.
cc
c                  nnn=2
c                  do 8800 jj=1,Nloop
cc  
c                    call sobseq(nnn,xsob)
c                    phinew=(xsob(1)-0.5d0)*dphi+phi
c                    thetanew=(xsob(2)-0.5d0)*dtheta+theta          
cc  
c                    snth=dsin(thetanew)
c                    snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
c                    cnth=dcos(thetanew)
c                    cox=dcos(phinew)*snth                !*dsin(theta)
c                    coy=dsin(phinew)*snth                !*dsin(theta)
c                    coz=cnth                          !dcos(theta)
c                    CALL RAD(overQ,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,
c     $                bdist,tidephi,itide,ecc,thetamis,phimis)
c                    call POTEN(overQ,omega,xx,yy,zz,psi,
c     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,
c     &                   tidephi,itide,ecc,thetamis,phimis)
c                    gravity=dsqrt(PSIX**2+PSIY**2+PSIZ**2)
c                    GX = -PSIX/gravity
c                    GY = -PSIY/gravity
c                    GZ = -PSIZ/gravity
c                    proj=ax*gx+ay*gy+az*gz
cc                    write(*,*)proj,visib(iidx)
c                    if(proj.lt.0.0d0)then
c                      NNhid=NNhid+1
cc                      go to 8800
c                    endif
cc
cc   Check to see if the pixel is eclipsed
cc
c                    if((iedgehor(iidx).eq.-10).or.(iedgehor(iidx).gt.5)
c     %                  .or.(ialf.eq.iimin).or.(ialf.eq.iimax)
c     %                 .or.(ialf.eq.iimin+1).or.(ialf.eq.iimax-1))then
cc
c                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
c                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c                      xp=xp+xxoff
c                      yp=yp+yyoff
cc                     write(*,1001)xp,yp,ialf,ibet
c                      iyes=-1000
c                      call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,
c     @                    iyes,icut)
c                      if(iyes.eq.100)then
c                        NNhid=NNhid+1
cc                        go to 8800
c                        proj=0.0d0
c                      endif
c                    endif
cc                    if(proj.lt.0.0d0)proj=0.0d0
c                    psum=psum+proj
c 8800             continue
c 8801             nvis=Nloop-NNhid
cc                  write(*,*)Nloop,NNhid,visib(iidx),psum/dble(Nloop)
c                  if(psum.lt.0.0d0)psum=0.0d0
c                  visib(iidx)=psum !projarray(iidx)*(dble(nvis)/dble(Nloop))
c                endif
c              endif  ! end if MonteCarlo > 10
cc
 701        continue
 702      continue
c
          return
          end
c
c  *************************************************************************
c
          subroutine getBBflux(ialphmax,ibetmax,Nalf,ibetlim,
     $      wave,visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,
     &      flum,flux,delphi,delphiedge,iedgestar,iedgehor,rldint,
     &      separ,mmdx,MonteCarlo,isw13,ialfmin,ialfmax,fluxlat,
     &      istar,phiarr,phihor)
c
c  October 11, 1999
c
c  This routine will compute the intensities of each element, given the
c  temperatures (temp(ialf,ibet)) and the input wavelength.  It will then
c  integrate the flux given the visibilities (visib) and surface elements
c  (surf).   
c
c  The projarray contains the cosine mu terms for each element.  The visib
c  array contains the cosine mu terms for each element, except if the point
c  is eclipsed in which case the visib=0.
c 
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
c   by (separ*solarrad)**2
c
c   
c   UPDATE JULY 4, 2004
c
c   Add the variable MonteCarlo to the argument list.  If MonteCarlo < 10,
c   then proceed as before.  If Monte Carlo > 10, then the fractional
c   pixels were computed in getvisib via Monte Carlo integration.  In
c   that case, we can skip some steps below.
c
          implicit double precision(a-h,o-z)
c
c
c   Set these to the value of ialphmax,ibetmax
c
          integer tempalf,tempbet
          parameter(tempalf=3000,tempbet=3000,itab=tempalf*tempbet)

          parameter(pie=3.14159265358979323d0)
          dimension visib(ialphmax*ibetmax),delphi(ialphmax*ibetmax),
     $        surf(ialphmax*ibetmax),ibetlim(ialphmax),
     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     %        iedgehor(ialphmax*ibetmax),iedgestar(ialphmax*ibetmax),
     $        delphiedge(ialphmax*ibetmax),saveflum(itab)
          dimension mmdx(ialphmax,ibetmax)
          dimension phiarr(ialphmax*ibetmax)
          dimension xrow(2000),yrow(2000),phihor(ialphmax,4)
c
          if(tempalf.lt.ialphmax)then
            write(*,*)'dimension error in getBBflux ',ialphmax,ibetmax
            stop
          endif
          if(tempbet.lt.ibetmax)then
            write(*,*)'dimension error in getBBflux ',ialphmax,ibetmax
            stop
          endif
c
c          if(ilaw.gt.10)then
c            do i=1,8
c              dwavex(i,2)=dwavex(i,1)
c              dwavey(i,2)=dwavey(i,1)
c            enddo
c          endif

c
c   new triangular sampling for quad law
c
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            saveflimbx=flimbx
            saveflimby=flimby
            flimbx=2.0d0*dsqrt(saveflimbx)*saveflimby
            flimby=dsqrt(saveflimbx)*(1.0d0-2.0d0*saveflimby)
          endif
          rdint=pie*(1.0d0-flimbx/3.0d0)
          if((ilaw.eq.2).or.(ilaw.eq.12))then
            rdint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
          endif
          if((ilaw.eq.3).or.(ilaw.eq.13))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
          endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic law, ilaw=4
c
          if((ilaw.eq.4).or.(ilaw.eq.14))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
          endif

          if((ilaw.eq.5).or.(ilaw.eq.15))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
          endif

          flux=0.0d0
          C2 = 1.4384d8          ! 1.4384 * 10.**8      ! hc/(k*1e-8)
          C1 = 1.191044d35       ! 2hc^2/((1e-8)**5)
c
c   Initialize the flum matrix.
c
c
          do 2 ialf=1,nalf
            do 1 ibet=1,ibetlim(ialf)        !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              flum(iidx)=0.0d0
              rinty(iidx)=0.0d0
              saveflum(iidx)=0.0d0
 1          continue
 2        continue
c
c   Compute the intensity values of pixels just behind the edge or the
c   eclipsing horizon for use in fractional eclipse corrections.
c
          wavemu=wave/10000.0d0
          c1=3.74185
          c2=14.3883
c
c   UPDATE JULY 4, 2004
c
c   This loop is no longer needed when using the Monte Carlo
c   routine to compute fractionally eclipsed pixels.
c
          if(MonteCarlo.lt.10)then
            do 4 ialf=1,nalf
              if((istar.eq.1).and.(isw13.gt.0))then
                if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax))go to 4
              endif
              do 3 ibet=1,ibetlim(ialf)
c
cc   UPDATE June 11, 2003
cc
cc   change the 2D arrays into 1D
cc
c                iidx=kount(ialphmax,ialf,ibetlim)+ibet
c   
                iidx=mmdx(ialf,ibet)
                if((iedgehor(iidx).eq.-10).or.(iedgehor(iidx).gt.
     @               5).or.(iedgestar(iidx).eq.-10).or.(iedgestar(iidx)
     $               .gt.5).or.(delphi(iidx).gt.-10.0d0))then
c                  C3 = C2/(WAVE*TEMP(iidx))
c
                  tkkelv=temp(iidx)/1000.0d0
                  C3 = C2/(wavemu*tkkelv)
                  saveflum(iidx)=C1/(dexp(c3)-1.0d0)/wavemu**5
                  dark=(1.0d0-flimbx+flimbx*dabs(projarray(iidx)))
                  if((ilaw.eq.2).or.(ilaw.eq.12))dark=dark-
     &                flimby*dabs(projarray(iidx))*
     %                  dlog(dabs(projarray(iidx)))
                  if((ilaw.eq.3).or.(ilaw.eq.13))dark=dark-flimby*(1.0d0-
     &              dsqrt(dabs(projarray(iidx))))
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic law, ilaw=4
c
                  if((ilaw.eq.4).or.(ilaw.eq.14))dark=dark-flimby*(1.0d0-
     &              dabs(projarray(iidx)))**2
                  if((ilaw.eq.5).or.(ilaw.eq.15))dark=dark-flimby*(1.0d0-
     &              dabs(projarray(iidx)))**2
                  saveflum(iidx)=saveflum(iidx)*dark
                  saveflum(iidx)=surf(iidx)*saveflum(iidx)*
     $              dabs(projarray(iidx))
                endif
 3            continue
 4          continue
          endif
cc
          DO 10 ialf=1,nalf
            if((istar.eq.1).and.(isw13.gt.0))then
              if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax))go to 10
            endif
            dphi=pie/dble(ibetlim(ialf))
            DO 9 ibet = 1,ibetlim(ialf)               !4*nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c 
              iidx=mmdx(ialf,ibet)
              corr1=0.0d0
              corr2=0.0d0
              if((projarray(iidx).le.0.0d0))then
                xrow(ibet)=phiarr(iidx)
                yrow(ibet)=0.0d0
                go to 9
              endif
              tkkelv=temp(iidx)/1000.0d0
              C3 = C2/(wavemu*tkkelv)
              flum(iidx)=C1/(dexp(c3)-1.0d0)/wavemu**5
              dark=(1.0d0-flimbx+flimbx*projarray(iidx))
              if((ilaw.eq.2).or.(ilaw.eq.12))dark=dark-
     &               flimby*projarray(iidx)*
     %               dlog(projarray(iidx))
              if((ilaw.eq.3).or.(ilaw.eq.13))dark=dark-
     &          flimby*(1.0-dsqrt(projarray(iidx)))
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic law, ilaw=4
c
               if((ilaw.eq.4).or.(ilaw.eq.14))dark=dark-flimby*(1.0d0
     @               -dabs(projarray(iidx)))**2
               if((ilaw.eq.5).or.(ilaw.eq.15))dark=dark-flimby*(1.0d0
     @               -dabs(projarray(iidx)))**2
c
              flum(iidx)=flum(iidx)*dark
              rinty(iidx)=flum(iidx) ! save intensities for plotting
              saveflum(iidx)=surf(iidx)*flum(iidx)*
     $           projarray(iidx)
              flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
c
c
c   Correct for fractional pixels near the limb.
c
c   UPDATE JULY 4, 2004
c
c   These corrections are no longer needed when using the Monte
c   Carlo routine to compute fractionally eclipsed pixels.
c
              iidx=mmdx(ialf,ibet)
              if(MonteCarlo.gt.10)then
                corr1=0.0d0
                corr2=0.0d0
                go to 867
              endif
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              if(iedgestar(iidx).eq.10)then
                frac=0.5d0*(dabs(delphiedge(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  corr2=frac*saveflum(iidx)
                  saveflum(iidx)=saveflum(iidx)+corr2
                else
                  if(ibet.lt.ibetlim(ialf))then
c                    iidx=kount(ialphmax,ialf,ibetlim)+ibet+1
                    iidx=mmdx(ialf,ibet+1)
                    corr2=frac*saveflum(iidx)
                    saveflum(iidx)=saveflum(iidx)+corr2
                  else
c                    iidx=kount(ialphmax,ialf,ibetlim)+1
                    iidx=mmdx(ialf,1)
                    corr2=frac*saveflum(iidx)
                    saveflum(iidx)=saveflum(iidx)+corr2
                  endif
                endif
              endif
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              iidx=mmdx(ialf,ibet)
              if(iedgestar(iidx).eq.20)then
                frac=0.5d0*(dabs(delphiedge(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  corr2=frac*saveflum(iidx)
                  saveflum(iidx)=saveflum(iidx)+corr2
                else
                  if(ibet.gt.1)then
c                    iidx=kount(ialphmax,ialf,ibetlim)+(ibet-1)
                    iidx=mmdx(ialf,ibet-1)
                    corr2=frac*saveflum(iidx)
                    saveflum(iidx)=saveflum(iidx)+corr2
                  else
c                    iidx=kount(ialphmax,ialf,ibetlim)+ibetlim(ialf)
                    iidx=mmdx(ialf,ibetlim(ialf))
                    corr2=frac*saveflum(iidx)
                    saveflum(iidx)=saveflum(iidx)+corr2
                  endif
                endif
              endif
c
c
c   Check for fractional pixels near the horizon of the star in front,
c   in the beta direction (along constant latitude rows).
c
              iidx=mmdx(ialf,ibet)
              if(delphi(iidx).ge.-10.0d0)then
                frac=0.5d0*(dabs(delphi(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  corr1=frac*saveflum(iidx)
c                  if(ibet.lt.ibetlim(ialf))then 
cc                    jjdx=kount(ialphmax,ialf,ibetlim)+ibet+1   
c                    jjdx=mmdx(ialf,ibet+1)
c                    corr1=frac*saveflum(jjdx)
c                  else
cc                    jjdx=kount(ialphmax,ialf,ibetlim)+1   
c                    jjdx=mmdx(ialf,1)
c                    corr1=frac*saveflum(jjdx)
c                  endif
                else
                  if(iedgehor(iidx).eq.10)then
                    if(ibet.lt.ibetlim(ialf))then 
c                      jjdx=kount(ialphmax,ialf,ibetlim)+ibet+1   
                      jjdx=mmdx(ialf,ibet+1)
                      corr1=frac*saveflum(jjdx)
                    else
c                      jjdx=kount(ialphmax,ialf,ibetlim)+1   
                      jjdx=mmdx(ialf,1)
                      corr1=frac*saveflum(jjdx)
                    endif
                  endif
c                  iidx=kount(ialphmax,ialf,ibetlim)+ibet
                  iidx=mmdx(ialf,ibet)
                  if(iedgehor(iidx).eq.20)then
                    if(ibet.gt.1)then    
c                      jjdx=kount(ialphmax,ialf,ibetlim)+(ibet-1)/dphi   
                      jjdx=mmdx(ialf,ibet-1)
                      corr1=frac*saveflum(jjdx)
                    else
c                      jjdx=kount(ialphmax,ialf,ibetlim)+ibetlim(ialf)   
                      jjdx=mmdx(ialf,ibetlim(ialf))
                      corr1=frac*saveflum(jjdx) 
                    endif
                  endif
                endif
              endif
c
              iidx=mmdx(ialf,ibet)
867           flux=flux+flum(iidx)  +corr1 

              xrow(ibet)=phiarr(iidx)
              yrow(ibet)=flum(iidx)
              flum(iidx)=flum(iidx) +corr1 
c
 9          continue
c            if(phihor(ialf,1).ge.0.0d0)then
c              xrow(ibetlim(ialf)+1)=phihor(ialf,1)
c              yrow(ibetlim(ialf)+1)=0.0d0
c            endif
c            if(phihor(ialf,2).ge.0.0d0)then
c              xrow(ibetlim(ialf)+1)=phihor(ialf,2)
c              yrow(ibetlim(ialf)+1)=0.0d0
c            endif
c
            fred1=phihor(ialf,1)
            fred2=phihor(ialf,2)
            Irow=ibetlim(ialf)
            call edgecor(Irow,xrow,yrow,fred1,fred2,corr1)
            flux=flux+corr1
c
c            if((istar.eq.1).and.(ialf.eq.32))then
c              open(unit=33,file='row.dat',status='unknown')
c              do 888 jjj=1,ibetlim(ialf)
c                write(33,*)xrow(jjj),yrow(jjj)
c888           continue
c                fred=0.0d0
c                if(phihor(ialf,1).ge.0.0d0)write(33,*)phihor(ialf,1),fred
c                if(phihor(ialf,2).ge.0.0d0)write(33,*)phihor(ialf,2),fred
c              close(33)
c            endif
c
c   UPDATE January 10, 2010
c
c   Use a routine to sample the phi vs. flum 
c   curve and integrate using the trapizoid
c   rule
c
c           call binphi(ibetlim(ialf),xrow,yrow,rowsum,Nbet)
c           rowflux=rowflux+rowsum
c
 10       continue
c
c
c   Scale the light curve by the integral of the limb darkening law
c   for compatibility with Wilson-Devinney.
c        
c          if(montecarlo.gt.10)flux=rowflux  

          if((istar.eq.1).and.(isw13.gt.0))flux=flux+fluxlat
          flux=pie*flux/rdint
c

c          write(*,*)pie/rdint
c
c
c   UPDATE April 3, 2002
c
c   Scale the fluxes.
c
          solarrad=6.9598d10
          flux=flux*(separ*solarrad)**2

c
          rldint=rdint
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine detailrefl(ialphmax1,ibetmax1,
     $      Nalph1,ibetlim1,Nalph2,ibetlim2,ratio1,ratio2,
     $      xarray1,yarray1,zarray1,gradx1,grady1,gradz1,garray1,surf1,
     $      xarray2,yarray2,zarray2,gradx2,grady2,gradz2,garray2,surf2,
     $      temp1,temp2,tempold1,tempold2,dbolx,dboly,ilaw,alb1,alb2,
     $      teff2,Tgrav1,Tgrav2,rLx,iidint,redge,betarim,gpole1,gpole2,
     %      Tpole1,Tpole2,coprat1,coprat2,bdist,mmdx1,mmdx2,
     *      ialphmax2,ibetmax2)
c
c   October 15, 1999
c
c    This routine will alter the temperatures on star istar by
c    means of 'detailed reflection' (R. E. Wilson 1990, ApJ, 356, 613). 
c    The arrays ratio1 and ratio2 store the 'reflection' factors for
c    each surface element.  These can be iterated to any accuracy desired.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xarray1(ialphmax1*ibetmax1),yarray1(ialphmax1*ibetmax1),
     $      zarray1(ialphmax1*ibetmax1),surf1(ialphmax1*ibetmax1),
     &      gradx1(ialphmax1*ibetmax1),temp1(ialphmax1*ibetmax1),
     $      grady1(ialphmax1*ibetmax1),gradz1(ialphmax1*ibetmax1),
     %      garray1(ialphmax1*ibetmax1),ratio1(ialphmax1*ibetmax1),
     $      tempold1(ialphmax1*ibetmax1),ibetlim1(ialphmax1),
     $      ibetlim2(ialphmax2),coprat1(ialphmax1*ibetmax1),
     $      coprat2(ialphmax2*ibetmax2)
          dimension xarray2(ialphmax2*ibetmax2),yarray2(ialphmax2*ibetmax2),
     $      zarray2(ialphmax2*ibetmax2),surf2(ialphmax2*ibetmax2),
     &      gradx2(ialphmax2*ibetmax2),temp2(ialphmax2*ibetmax2),
     $      grady2(ialphmax2*ibetmax2),gradz2(ialphmax2*ibetmax2),
     %      garray2(ialphmax2*ibetmax2),ratio2(ialphmax2*ibetmax2),
     $      tempold2(ialphmax2*ibetmax2),mmdx2(ialphmax2,ibetmax2)
          dimension dbolx(8,2),dboly(8,2),mmdx1(ialphmax1,ibetmax1)
c
c
c   December 15, 2013:  new triangular sampling for quad law
c
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            saveflimbx=flimbx
            saveflimby=flimby
            flimbx=2.0d0*dsqrt(saveflimbx)*saveflimby
            flimby=dsqrt(saveflimbx)*(1.0d0-2.0d0*saveflimby)
          endif
c
c   UPDATE September 4, 1012
c
c   if ilaw > 10, force the coefficients of star 2 to equal those
c   of star 1
c
        
c          if(ilaw.gt.10)then
c            do i=1,8
c              dwavex(i,2)=dwavex(i,1)
c              dwavey(i,2)=dwavey(i,1)
c            enddo
c          endif
c
c   Start with star 1 and compute the flux from star 2.
c
          c1=0.0d0
          iidx=1
          darkbolx1=dbolx(1,1)
          darkboly1=dboly(1,1)
          darkbolx2=dbolx(1,2)
          darkboly2=dboly(1,2)
c
c
c   Define the integrated  limb darkening coefficients.  The equation is
c
c   dint=2*pi*int_0^1{mu*(1-x*(1-mu))d(mu)}  for the linear law, etc.
c
          dint1=pie*(1.0d0-darkbolx1/3.0d0)
          dint2=pie*(1.0d0-darkbolx2/3.0d0)
          if((ilaw.eq.2).or.(ilaw.eq.12))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0+2.0d0*darkboly1/9.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0+2.0d0*darkboly2/9.0d0)
          endif
          if((ilaw.eq.3).or.(ilaw.eq.13))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/5.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/5.0d0)
          endif
c
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic law, ilaw=4
c
          if((ilaw.eq.4).or.(ilaw.eq.14))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/6.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/6.0d0)
          endif
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/6.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/6.0d0)
          endif
c
          if(teff2.gt.0.0d0)then
            C1=(Tpole2/Tpole1)**(4)*(dint1/dint2)
            C1=C1*alb1/dint1
          endif
          DIV1 = gpole1    ! gravity at the pole
          DIV2 = gpole2    ! gravity at the pole
c
c   If teff2 < 0, then star 2 does not exist (X-ray binary mode usually).
c   In this case, we simply set C1=rLx, which is the ratio of the X-ray
c   luminosity to that of the star 1's optical luminosity.  The coordinates,
c   gradients, etc of star 2 have been adjusted correctly above.  
c
c   For the mode with 2 normal stars where star 2 is reasonably spherical,
c   you can input rLx = [(Teff2/Teff1)**4]*[(surface_area2/surface_area1)],
c   set Teff2=-Teff2, and get basically the same light curve.  This
c   is the "inverse square law" discussed by Wilson.
c
          if(teff2.le.0.0d0)then
            C1=rLx*alb1
            C1=C1/dint1
          endif
          diff1max=-1.0d0
          diff2max=-1.0d0
c
          T4g2=4.0d0*Tgrav2
          T4g1=4.0d0*Tgrav1
          do 10 ialf=1,Nalph1/2  !Nalph1/2,1,-1
            do 9 ibet=1,ibetlim1(ialf)/2  !4*Nbet1
              summ=0.0
              do 8 i=1,Nalph2       !1,Nalph2
                do 7 j=1,ibetlim2(i)/2
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c                  iidx=(ialf-1)*ibetlim1(ialf)+ibet
c                  iidx=kount(ialphmax,ialf,ibetlim1)+ibet
                  iidx=mmdx1(ialf,ibet)
c                  jjdx=(i-1)*ibetlim2(i)+j
c                  jjdx=kount(ialphmax,i,ibetlim2)+j
                  jjdx=mmdx2(i,j)
c
                  xflip2=bdist-xarray2(jjdx)     ! move the center of the
                  yflip2=-yarray2(jjdx)          ! second star
                  zflip2=zarray2(jjdx)
                  dist1=(xarray1(iidx)-xflip2)**2 +
     %                  (yarray1(iidx)-yflip2)**2 +
     $                  (zarray1(iidx)-zflip2)**2
                  dist1=dsqrt(dist1)
                  term1=(xflip2-xarray1(iidx))*gradx1(iidx)+
     $                  (yflip2-yarray1(iidx))*grady1(iidx)+
     @                  (zflip2-zarray1(iidx))*gradz1(iidx)
                  foreshort1=(term1/(dist1)) 
c

c   UPDATE March 22, 2002
c
c   If Teff < 0, then bail out here.
c
                  if(teff2.lt.0.0d0)go to 99
c
                  if(foreshort1.le.0.0d0)go to 7
c
                  dist2=dist1            
c
                  xflip1=bdist-xarray1(iidx)
                  yflip1=-yarray1(iidx)
                  zflip1=zarray1(iidx)
                  term2=(xflip1-xarray2(jjdx))*gradx2(jjdx)+
     $                  (yflip1-yarray2(jjdx))*grady2(jjdx)+
     @                  (zflip1-zarray2(jjdx))*gradz2(jjdx)
                  foreshort2=(term2/(dist2))  
c 
                  if(foreshort2.le.-0.05d0)go to 8   ! leave this beta loop
                  if(foreshort2.le.0.0d0)go to 7
                  if(teff2.le.0.0d0)go to 7
c
c                  term3=(garray2(i,j)/div2)**(T4g2)
c                  term3=term3*surf2(i,j)*coprat2(i,j)
c                  term3=term3*foreshort1*foreshort2/(dist2*dist2)
c
                  term3=(garray2(jjdx)/div2)**(T4g2)*
     $     surf2(jjdx)*coprat2(jjdx)*foreshort1*foreshort2/(dist2*dist2)
c
                  if((ilaw.eq.1).or.(ilaw.eq.11))then
                    term3=term3*(1.0d0-darkbolx2+darkbolx2*foreshort2)
                  endif
                  if((ilaw.eq.2).or.(ilaw.eq.12))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*foreshort2*dlog(foreshort2)
                    else
                      ttt=0.0d0
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.3).or.(ilaw.eq.13))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-dsqrt(foreshort2))
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
                  if((ilaw.eq.4).or.(ilaw.eq.14))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-(foreshort2))**2
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.5).or.(ilaw.eq.15))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-(foreshort2))**2
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif

c
c   If there is a disk, we need to check which lines of sight are blocked
c
                  if(iidint.ge.1)then
                    zrim=redge*dtan(betarim*0.017453293d0)
                    xA=xarray1(iidx)
                    yA=yarray1(iidx)
                    zA=zarray1(iidx)
                    xB=bdist-xarray2(jjdx)     
                    yB=-yarray2(jjdx)          
                    zB=zarray2(jjdx)           
                    call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                    if((zB.ge.0.0d0).and.(zcross.lt.zrim))term3=0.0d0
                    if((zB.lt.0.0d0).and.(zcross.gt.-zrim))term3=0.0d0
                  endif
                  summ=summ+term3
 7              continue
 8            continue
c
              do 888 i=1,Nalph2
                do 777 j=ibetlim2(i),ibetlim2(i)/2+1,-1
c                  iidx=(ialf-1)*ibetlim1(ialf)+ibet
c                  jjdx=(i-1)*ibetlim2(i)+j
c                  iidx=kount(ialphmax,ialf,ibetlim1)+ibet
c                  jjdx=kount(ialphmax,i,ibetlim2)+j
                  iidx=mmdx1(ialf,ibet)
                  jjdx=mmdx2(i,j)
                  xflip2=bdist-xarray2(jjdx)     ! move the center of the
                  yflip2=-yarray2(jjdx)          ! second star
                  zflip2=zarray2(jjdx)
                  dist1=(xarray1(iidx)-xflip2)**2 +
     %                  (yarray1(iidx)-yflip2)**2 +
     $                  (zarray1(iidx)-zflip2)**2
                  dist1=dsqrt(dist1)
                  term1=(xflip2-xarray1(iidx))*gradx1(iidx)+
     $                  (yflip2-yarray1(iidx))*grady1(iidx)+
     @                  (zflip2-zarray1(iidx))*gradz1(iidx)
                  foreshort1=(term1/(dist1)) 
c
                  if(foreshort1.le.0.0d0)go to 777
c
                  dist2=dist1            
c
                  xflip1=bdist-xarray1(iidx)
                  yflip1=-yarray1(iidx)
                  zflip1=zarray1(iidx)
                  term2=(xflip1-xarray2(jjdx))*gradx2(jjdx)+
     $                  (yflip1-yarray2(jjdx))*grady2(jjdx)+
     @                  (zflip1-zarray2(jjdx))*gradz2(jjdx)
                  foreshort2=(term2/(dist2))  
c
                  if(foreshort2.le.0.0d0)go to 888
                  if(teff2.le.0.0d0)go to 777
c
c                  term3=(garray2(i,j)/div2)**(T4g2)
c                  term3=term3*surf2(i,j)*coprat2(i,j)
c                  term3=term3*foreshort1*foreshort2/(dist2*dist2)
c
                  term3=(garray2(jjdx)/div2)**(T4g2)*
     %    surf2(jjdx)*coprat2(jjdx)*foreshort1*foreshort2/(dist2*dist2)
c
                  if((ilaw.eq.1).or.(ilaw.eq.11))then
                    term3=term3*(1.0d0-darkbolx2+darkbolx2*foreshort2)
                  endif
                  if((ilaw.eq.2).or.(ilaw.eq.12))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*foreshort2*dlog(foreshort2)
                    else
                      ttt=0.0d0
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.3).or.(ilaw.eq.13))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-dsqrt(foreshort2))
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
                  if((ilaw.eq.4).or.(ilaw.eq.14))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-(foreshort2))**2
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.5).or.(ilaw.eq.15))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly2*(1.0-(foreshort2))**2
                    else
                      ttt=darkboly2
                    endif
                    term3=term3*(1.0d0-darkbolx2*(1.0d0-foreshort2)-ttt)
                  endif

c
c   If there is a disk, we need to check which lines of sight are blocked
c
                  if(iidint.ge.1)then
c                    iidx=(ialf-1)*ibetlim1(ialf)+ibet
c                    jjdx=(i-1)*ibetlim2(i)+j
                    zrim=redge*dtan(betarim*0.017453293d0)
                    xA=xarray1(iidx)
                    yA=yarray1(iidx)
                    zA=zarray1(iidx)
                    xB=bdist-xarray2(jjdx)     
                    yB=-yarray2(jjdx)          
                    zB=zarray2(jjdx)           
                    call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                    if((zB.ge.0.0d0).and.(zcross.lt.zrim))term3=0.0d0
                    if((zB.lt.0.0d0).and.(zcross.gt.-zrim))term3=0.0d0
                  endif
                  summ=summ+term3
 777            continue
 888          continue

c
c   Check to see if the point on star 1 can actually see any point on
c   star 2.  If not, then the summ will be zero.
c
c   UPDATE March 22, 2002
c
c   Delete this statement
c
c              if((teff2.le.0.0d0).and.(iidint.lt.1))summ=foreshort1 ! no disk
c
              if(summ.eq.0.0d0)go to 10  
c
c   If Teff2 < 0, we assume star 2 is a point source.  Thus the integration
c   over the surface of star 2 reduces to the foreshorting angle of
c   the specific ialf-ibet element on star 1.  If there is a disk we have
c   to compute which points on star A are shielded by the disk rim.
c
c
c   UPDATE March 22, 2002
c
c   Comment this out, and move statement 99 one line down
c
c 99           if((teff2.le.0.0d0).and.(iidint.lt.1))summ=foreshort1 ! no disk
 99           if((teff2.le.0.0d0).and.(iidint.ge.1))then
                zrim=redge*dtan(betarim*0.017453293d0)
                xA=xarray1(iidx)
                yA=yarray1(iidx)
                zA=zarray1(iidx)
                xB=bdist
                yB=0.0d0
                zB=0.0d0
                call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
c
c   UPDATE March 22, 2002
c
c   Comment this out.
c
c                summ=foreshort1
                if(summ.lt.0.0d0)summ=0.0d0
                if((zA.ge.0.0d0).and.(zcross.lt.zrim))summ=0.0d0
                if((zA.lt.0.0d0).and.(zcross.gt.-zrim))summ=0.0d0
              endif
c                    
              FpBoverFA=C1/((garray1(iidx)/div1)**(T4g1))*summ
              ratio1(iidx)=1.0d0+FpBoverFA
              tnew=tempold1(iidx)*ratio1(iidx)**0.25d0
              diff=tnew-tempold1(iidx)
              if(diff.gt.diff1max)diff1max=diff
              temp1(iidx)=tnew
              if(summ.gt.0.0d0)jcount=jcount+1
 9          continue
 10       continue
c
c   Now go to star 2 and compute the irradation from star 1
c
          if(teff2.le.0.0d0)go to 50
          C2=(Tpole1/Tpole2)**(4)*(dint2/dint1)
          C2=C2*alb2/dint2
c
          do 20 ialf=1,Nalph2/2  !Nalph2/2,1,-1
            do 19 ibet=1,ibetlim2(ialf)/2   !Nbet2
              summ=0.0d0
              do 18 i=1,Nalph1
                do 17 j=1,ibetlim1(i)/2
c                  iidx=(ialf-1)*ibetlim2(ialf)+ibet
c                  jjdx=(i-1)*ibetlim1(i)+j
c                  iidx=kount(ialphmax,ialf,ibetlim2)+ibet
c                  jjdx=kount(ialphmax,i,ibetlim1)+j
c
                  iidx=mmdx2(ialf,ibet)
                  jjdx=mmdx1(i,j)
                  xflip1=bdist-xarray1(jjdx)     ! move the center of the
                  yflip1=-yarray1(jjdx)        ! first star
                  zflip1=zarray1(jjdx)
                  dist1=(xflip1-xarray2(iidx))**2 +
     %                  (yflip1-yarray2(iidx))**2 +
     $                  (zflip1-zarray2(iidx))**2
                  dist1=dsqrt(dist1)
                  term1=(xflip1-xarray2(iidx))*gradx2(iidx)+
     $                  (yflip1-yarray2(iidx))*grady2(iidx)+
     @                  (zflip1-zarray2(iidx))*gradz2(iidx)
                  foreshort1=(term1/(dist1))    
                  if(foreshort1.lt.0.0d0)go to 17
c
                  dist2=dist1  
                  
                  xflip2=bdist-xarray2(iidx)
                  yflip2=-yarray2(iidx)
                  zflip2=zarray2(iidx)
c
                  term2=(xflip2-xarray1(jjdx))*gradx1(jjdx)+
     $                  (yflip2-yarray1(jjdx))*grady1(jjdx)+
     @                  (zflip2-zarray1(jjdx))*gradz1(jjdx)
                  foreshort2=(term2/(dist2)) 
                  if(foreshort2.lt.0.0d0)go to 18
c
c                  term3=(garray1(i,j)/div1)**(T4g1)
c                  term3=term3*surf1(i,j)*coprat1(i,j)
c                  term3=term3*foreshort1*foreshort2/(dist2*dist2)
                  term3=(garray1(jjdx)/div1)**(T4g1)*
     &     surf1(jjdx)*coprat1(jjdx)*foreshort1*foreshort2/(dist2*dist2)
c
                  if((ilaw.eq.1).or.(ilaw.eq.11))then
                    term3=term3*(1.0d0-darkbolx1+darkbolx1*foreshort2)
                  endif
                  if((ilaw.eq.2).or.(ilaw.eq.12))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*foreshort2*dlog(foreshort2)
                    else
                      ttt=0.0d0
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.3).or.(ilaw.eq.13))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-dsqrt(foreshort2))
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
                  if((ilaw.eq.4).or.(ilaw.eq.14))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-(foreshort2))**2
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.5).or.(ilaw.eq.15))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-(foreshort2))**2
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
c
c   If there is a disk, we need to check which lines of sight are blocked.
c
                  if(iidint.ge.1)then
                    zrim=redge*dtan(betarim*0.017453293d0)
                    xA=xarray1(jjdx)
                    yA=yarray1(jjdx)
                    zA=zarray1(jjdx)
                    xB=bdist-xarray2(iidx) ! move the center of the
                    yB=-yarray2(iidx)    ! second star to be consistent
                    zB=zarray2(iidx)     ! with the disk coordinates
                    call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                    if((zB.ge.0.0).and.(zcross.lt.zrim))term3=0.0
                    if((zB.lt.0.0).and.(zcross.gt.-zrim))term3=0.0
                  endif
                  summ=summ+term3
 17             continue
 18           continue
c
              do 1888 i=1,Nalph1
                do 1777 j=ibetlim1(i),ibetlim1(i)/2+1,-1  
c                  iidx=(ialf-1)*ibetlim2(ialf)+ibet
c                  jjdx=(i-1)*ibetlim1(i)+j
c                  iidx=kount(ialphmax,ialf,ibetlim2)+ibet
c                  jjdx=kount(ialphmax,i,ibetlim1)+j
                  iidx=mmdx2(ialf,ibet)
                  jjdx=mmdx1(i,j)
                  xflip1=bdist-xarray1(jjdx)     ! move the center of the
                  yflip1=-yarray1(jjdx)        ! first star
                  zflip1=zarray1(jjdx)
                  dist1=(xflip1-xarray2(iidx))**2 +
     %                  (yflip1-yarray2(iidx))**2 +
     $                  (zflip1-zarray2(iidx))**2
                  dist1=dsqrt(dist1)
                  term1=(xflip1-xarray2(iidx))*gradx2(iidx)+
     $                  (yflip1-yarray2(iidx))*grady2(iidx)+
     @                  (zflip1-zarray2(iidx))*gradz2(iidx)
                  foreshort1=(term1/(dist1))    
                  if(foreshort1.lt.0.0d0)go to 1777
c
                  dist2=dist1  
                  
                  xflip2=bdist-xarray2(iidx)
                  yflip2=-yarray2(iidx)
                  zflip2=zarray2(iidx)
c
                  term2=(xflip2-xarray1(jjdx))*gradx1(jjdx)+
     $                  (yflip2-yarray1(jjdx))*grady1(jjdx)+
     @                  (zflip2-zarray1(jjdx))*gradz1(jjdx)
                  foreshort2=(term2/(dist2)) 
                  if(foreshort2.lt.0.0d0)go to 1888
c
c                  term3=(garray1(jjdx)/div1)**(T4g1)
c                  term3=term3*surf1(jjdx)*coprat1(jjdx)
c                  term3=term3*foreshort1*foreshort2/(dist2*dist2)
                  term3=(garray1(jjdx)/div1)**(T4g1)*
     &     surf1(jjdx)*coprat1(jjdx)*foreshort1*foreshort2/(dist2*dist2)
c
                  if((ilaw.eq.1).or.(ilaw.eq.11))then
                    term3=term3*(1.0d0-darkbolx1+darkbolx1*foreshort2)
                  endif
                  if((ilaw.eq.2).or.(ilaw.eq.12))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*foreshort2*dlog(foreshort2)
                    else
                      ttt=0.0d0
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.3).or.(ilaw.eq.13))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-dsqrt(foreshort2))
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
                  if((ilaw.eq.4).or.(ilaw.eq.14))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-(foreshort2))**2
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
                  if((ilaw.eq.5).or.(ilaw.eq.15))then
                    if(foreshort2.gt.0.0d0)then
                      ttt=darkboly1*(1.0d0-(foreshort2))**2
                    else
                      ttt=darkboly1
                    endif
                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
                  endif
c
c   If there is a disk, we need to check which lines of sight are blocked.
c
                  if(iidint.ge.1)then
                    zrim=redge*dtan(betarim*0.017453293d0)
                    xA=xarray1(jjdx)
                    yA=yarray1(jjdx)
                    zA=zarray1(jjdx)
                    xB=bdist-xarray2(iidx) ! move the center of the
                    yB=-yarray2(iidx)    ! second star to be consistent
                    zB=zarray2(iidx)     ! with the disk coordinates
                    call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                    if((zB.ge.0.0).and.(zcross.lt.zrim))term3=0.0
                    if((zB.lt.0.0).and.(zcross.gt.-zrim))term3=0.0
                  endif
                  summ=summ+term3
 1777           continue
 1888         continue
c
c   Check to see if the point on star 2 can actually see any point on
c   star 1.  If not, then the summ will be zero.
c
              if(summ.eq.0.0d0)go to 20  
c
              FpAoverFB=C2/((garray2(iidx)/div2)**(T4g2))*summ
              ratio2(iidx)=1.0d0+FpAoverFB
              tnew=tempold2(iidx)*ratio2(iidx)**0.25d0
              diff=tnew-tempold2(iidx)
              if(diff.gt.diff2max)diff2max=diff
              temp2(iidx)=tnew
 19         continue
 20       continue
c
c   Now use symmetry to fill in the other quadrants on the star.  
c
 50       continue
c
          DO 401 IALF = 1, nalph1/2
            DO 400 IBET = 1, ibetlim1(ialf)/2
              I1=nalph1-(ialf-1)
              J2=ibetlim1(ialf)-(ibet-1)
c              iidx=(ialf-1)*ibetlim1(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim1)+ibet
               iidx=mmdx1(ialf,ibet)
c
              izz=ialf
              jzz=j2
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              ratio1(jjdx)=ratio1(iidx)
              temp1(jjdx)=temp1(iidx)

              izz=I1
              jzz=ibet
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              ratio1(jjdx)=ratio1(iidx)
              temp1(jjdx)=temp1(iidx)
c
              izz=I1
              jzz=j2
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              ratio1(jjdx)=ratio1(iidx)
              temp1(jjdx)=temp1(iidx)
c
 400        continue
401       CONTINUE
c
          if(teff2.le.0.0)go to 999
          DO 501 IALF = 1, nalph2/2
            DO 500 IBET = 1, ibetlim2(ialf)/2
              I1=nalph1-(ialf-1)
              J2=ibetlim2(ialf)-(ibet-1)
c              iidx=(ialf-1)*ibetlim2(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim2)+ibet
              iidx=mmdx2(ialf,ibet)
              I1=nalph2-(ialf-1)
              J2=ibetlim2(ialf)-(ibet-1)

              izz=ialf
              jzz=j2
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              ratio2(jjdx)=ratio2(iidx)
              temp2(jjdx)=temp2(iidx)
c
              izz=I1
              jzz=ibet
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              ratio2(jjdx)=ratio2(iidx)
              temp2(jjdx)=temp2(iidx)

              izz=I1
              jzz=j2
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              ratio2(jjdx)=ratio2(iidx)
              temp2(jjdx)=temp2(iidx)
c
 500        continue
501       CONTINUE
c
c   Update the ratio arrays.
c
          call copytemp(ialphmax1,ibetmax1,Nalph1,ratio1,coprat1,
     @       mmdx1,ibetlim1)
          call copytemp(ialphmax2,ibetmax2,Nalph2,ratio2,coprat2,
     @       mmdx2,ibetlim2)
c
          if(diff2max.lt.0.0d0)diff2max=0.0
          if(diff1max.lt.0.0d0)diff1max=0.0

          write(2,72)diff2max
 999      write(2,71)diff1max
c
 71       format(/'maximum temperature change for star 1 = ',f15.9)
 72       format('maximum temperature change for star 2 = ',f15.9)

          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine initratio(ialphmax1,ibetmax1,
     @          Nalph1,Nbet1,Nalph2,Nbet2,ratio1,ratio2,
     &          coprat1,coprat2,ialphmax2,ibetmax2)
c
c   October 15, 1999
c
c   Initialize the ratio arrays to 1.0.
c
          implicit double precision(a-h,o-z)
c
          dimension ratio1(ialphmax1*ibetmax1),ratio2(ialphmax2*ibetmax2)
          dimension coprat1(ialphmax1*ibetmax1),coprat2(ialphmax2*ibetmax2)
c
          do 10 ialf=1,Nalph1
            do 9 ibet=1,4*Nbet1
              iidx=(ialf-1)*4*Nbet1+ibet
              ratio1(iidx)=1.0d0
              coprat1(iidx)=1.0d0
 9          continue
 10       continue
c
          do 20 ialf=1,Nalph2
            do 19 ibet=1,4*Nbet2
              iidx=(ialf-1)*4*Nbet2+ibet
              ratio2(iidx)=1.0d0
              coprat2(iidx)=1.0d0
 19         continue
 20       continue
c
          return
          end
c
c   
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c     
          subroutine copytemp(ialphmax,ibetmax,Nalph,tempold,
     &      tempnew,mmdx,ibetlim)
c
c   October 18, 1999
c
c   Copy the temperature array into a new array.  We need to keep
c   the original temperatures for the reflection effect routine
c
          implicit double precision(a-h,o-z)
c
          dimension tempold(ialphmax*ibetmax),tempnew(ialphmax*ibetmax)
          dimension mmdx(ialphmax,ibetmax),ibetlim(ialphmax)
c
          do 9 ialf=1,nalph
            do 10 ibet=1,ibetlim(ialf)
c              iidx=(ialf-1)*4*Nbet+ibet
              iidx=mmdx(ialf,ibet)
              tempnew(iidx)=tempold(iidx)
 10         continue
 9        continue
c
          return
          end
c
c   **********************************
c
          subroutine clip(Nhoriz,xhoriz,yhoriz,xvis,yvis,xhid,yhid,
     @       xedge,yedge)
c
c   October 21, 1999
c
c   This routine assumes that the point xvis,yvis is outside the polygon
c   (xhoriz,yhoriz) and the point xhid,yhid is inside the horizon.  It
c   then computes the coordinate of the point along the line joining the
c   two points that intersects the horizon.
c
          implicit double precision(a-h,o-z)
c
          dimension xhoriz(Nhoriz),yhoriz(Nhoriz)
c
c   Find the slope
c
          xvsave=xvis
          yvsave=yvis
          xhsave=xhid
          yhsave=yhid
          rise=yvis-yhid
          run=xvis-xhid
          if(run.eq.0)then       !special case
            xedge=xvis
            do 10 i=1,20
              iyes=-100
              yedge=(yvis+yhid)/2.0d0
              call insidecircle(Nhoriz,xhoriz,yhoriz,xedge,yedge,iyes,icut)
              if(iyes.eq.100)then       ! inside horizon
                yhid=yedge
              else                      ! outside horizon
                yvis=yedge
              endif
 10         continue
c
          go to 99
          endif
c
          slope=rise/run
          do 20 i=1,20
            iyes=-100
            xedge=(xvis+xhid)/2.0d0
            yedge=slope*(xedge-xhsave)+yhsave
            call insidecircle(Nhoriz,xhoriz,yhoriz,xedge,yedge,iyes,icut)
            if(iyes.eq.100)then       ! inside horizon
              xhid=xedge
            else                      ! outside horizon
              xvis=xedge
            endif
 20       continue
c
 99       yvis=yvsave
          xvis=xvsave
          xhid=xhsave
          yhid=yhsave
c
          return
          end
c
c  *************************************************************************
c
          subroutine hidgrid(istar,ialphmax,ibetmax,Nalf,ibetlim,
     @      phase,finc,Q,xarray,yarray,zarray,xend,projarray,
     @      garray,gscale,surf,Nhoriz,xhoriz,yhoriz,rinty,extension,
     $      separation,flux,reff,iecheck,tarray,Nh,xh,yh,bdist,mmdx,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega,icounttime,Nhoriz3,xhoriz3,yhoriz3,i3flag)
c
c   January 14, 2000
c
c   This routine will output files used for various external plotting
c   packages.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension ibetlim(ialphmax),
     $        xhoriz(Nhoriz),yhoriz(Nhoriz),xend(4),
     @        xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     @        zarray(ialphmax*ibetmax),rinty(ialphmax*ibetmax),
     @        garray(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     @        surf(ialphmax*ibetmax),tarray(ialphmax*ibetmax),
     @        savex(20000),savey(20000),xh(Nh),yh(Nh),conex(5),coney(5),
     @        mmdx(ialphmax,ibetmax)
          dimension xhoriz3(Nhoriz3),yhoriz3(Nhoriz3)
c
          character*9 extension
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          if(istar.eq.1)open(unit=40,
     %         file='star1inty.'//extension,status='unknown')
          if(istar.eq.2)open(unit=40,
     %         file='star2inty.'//extension,status='unknown')

c
c   Check to see of the star in question is in front.  
c
          infront=0
          ppp=dmod(phase,360.0d0)
          if(ppp.lt.0.0d0)ppp=ppp+360.0d0
          if(ppp.ge.360.0d0)ppp=ppp-360.0d0

          if((istar.eq.1).and.((ppp.ge.0.0d0).
     @        and.(ppp.lt.90.0d0)))infront=1
          if((istar.eq.1).and.((ppp.ge.270.0d0).
     %        and.(ppp.le.360.0d0)))infront=1
          if((istar.eq.2).and.((ppp.ge.0.0d0).
     @        and.(ppp.lt.90.0d0)))infront=1
          if((istar.eq.2).and.((ppp.ge.270.0d0).
     $        and.(ppp.le.360.0d0)))infront=1

c          if((istar.eq.1).and.((phase.ge.0.0d0).
c     @        and.(phase.lt.90.0d0)))infront=1
c          if((istar.eq.1).and.((phase.ge.270.0d0).
c     %        and.(phase.le.360.0d0)))infront=1
c          if((istar.eq.2).and.((phase.ge.0.0d0).
c     @        and.(phase.lt.90.0d0)))infront=1
c          if((istar.eq.2).and.((phase.ge.270.0d0).
c     $        and.(phase.le.360.0d0)))infront=1

c
c   Find the sky coordinates of the center of mass of the star.  This
c   will be recorded as the first line of the star?inty.???.?? file.
c
          if(istar.eq.1)then
            xx=0.0d0
            yy=0.0d0
            zz=0.0d0
c            ddphase=phase
          endif
          if(istar.eq.2)then
            xx=0.0d0                     !FIX JULY 21, 2004 (was 1.0)
            yy=0.0d0
            zz=0.0d0
c            ddphase=dmod(phase+180.0d0,360.0d0)  ! this is for star 2
          endif

          xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)    ! projected coords
          yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
          xp=xp+xxoff
          yp=yp+yyoff
c
          write(40,68)xp*separation,yp*separation,flux,reff*separation,
     %       separation

          isave=0
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)        !4*NBET
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              iidx=mmdx(ialf,ibet)
c
c
c   UPDATE March 4, 2010
c
c   Record the radius of each point.
c
c
              RRRR=sqrt(xarray(iidx)**2+yarray(iidx)**2+zarray(iidx)**2)
              iv1=1
              iv1_3=1
              IF (projarray(iidx).le.0.0d0) go to 502 ! is the surface 
              xx=xarray(iidx)                   ! element visible?
              yy=yarray(iidx)
              zz=zarray(iidx)
              xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)   ! projected coords
              yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
              if((infront.ne.1).or.(i3flag.gt.0))then    
                iyes=-100
                iyes3=-100
                iv1=1
                iv1_3=1
                if(iecheck.ge.0)then 
                   if(infront.eq.0)then
                     call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,
     @                icut)
                   endif
                   if(i3flag.gt.0)then
                     call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xp,yp,
     @                 iyes3,icut)
                   endif
                endif
                if((iyes.eq.100))iv1=0   
                if((iyes3.eq.100))iv1_3=0    ! point could be visible
              endif                       ! but is eclipsed
c       
c   Record the x,y,z coordinates of the nearby points.  These points
c   will be used for area filling
c
              xx1=xp
              yy1=yp
c
              isave=isave+1
              savex(isave)=xp*separation
              savey(isave)=yp*separation
c
              if(ibet.gt.1)then
                izz=ialf
                jzz=ibet-1
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
                izz=ialf
                jzz=ibetlim(ialf)
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              endif
              xx2=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy2=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx2=xx2+xxoff
              yy2=yy2+yyoff
              if(ialf.gt.1)then
                if(ibet.gt.1)then
                  izz=ialf-1
                  jzz=min(ibet-1,ibetlim(ialf-1))
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                else
                  izz=ialf-1
                  jzz=ibetlim(ialf-1)
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                endif
              else
                xx=0.0d0
                yy=0.0d0
                zz=xend(1)
              endif
              xx3=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy3=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx3=xx3+xxoff
              yy3=yy3+yyoff
              if(ialf.gt.1)then
                izz=ialf-1
                jzz=min(ibet,ibetlim(ialf-1))
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
                xx=0.0d0
                yy=0.0d0
                zz=xend(1)
              endif
              xx4=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy4=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx4=xx4+xxoff
              yy4=yy4+yyoff
c
c   Check the corners for eclipsed points.
c
              iv2=1
              iv3=1
              iv4=1
              iv2_3=1
              iv3_3=1
              iv4_3=1
              if((infront.eq.0).or.(i3flag.gt.0))then
                iyes=-100
                iyes3=-100
                iv2=1
                iv2_3=1
                if(infront.eq.0)then
                  call insidecircle(Nhoriz,xhoriz,yhoriz,xx2,yy2,iyes,
     @              icut)
                endif
                if(i3flag.ge.1)then
                  call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,
     @              iyes3,icut)
                endif
                if((iyes.eq.100))iv2=0      
                if((iyes3.eq.100))iv2_3=0      
                iv3=1
                iyes=-100
                iv3_3=1
                iyes3=-100
                if(infront.eq.0)then
                  call insidecircle(Nhoriz,xhoriz,yhoriz,xx3,yy3,iyes,
     @               icut)
                endif
                if(i3flag.ge.1)then
                  call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,
     @               iyes3,icut)
                endif
                if(iyes.eq.100)iv3=0      
                if(iyes3.eq.100)iv3_3=0      
                iv4=1
                iyes=-100
                iv4_3=1
                iyes3=-100
                if(infront.eq.0)then
                  call insidecircle(Nhoriz,xhoriz,yhoriz,xx4,yy4,iyes,
     @               icut)
                endif
                if(i3flag.ge.1)then
                  call insidecircle(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,
     @               iyes3,icut)
                endif
                if(iyes.eq.100)iv4=0      
                if(iyes3.eq.100)iv4_3=0      
              endif
              if(iecheck.le.-1)then
                iv1=1
                iv2=1
                iv3=1
                iv4=1
              endif
c
c   There are 13 possibilities for which corners were hidden.  Do each
c   case separately.  This is for the tertiary.
c
              isgone=0
              if(i3flag.eq.0)go to 897
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0).and.
     @           (iv3.eq.0))go to 897   !points hidden by secondary/primary
c
              if((iv1_3.eq.0).and.(iv2_3.eq.0).and.(iv3_3.eq.1).
     @          and.(iv4_3.eq.1))then
                ncorner=4
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c              
              if((iv1_3.eq.0).and.(iv2_3.eq.0).and.(iv3_3.eq.1)
     @           .and.(iv4_3.eq.0))then
                ncorner=4
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 99
              endif
c              
              if((iv1_3.eq.0).and.(iv2_3.eq.1).and.(iv3_3.eq.1)
     @               .and.(iv4_3.eq.1))then
                ncorner=5
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_3.eq.0).and.(iv2_3.eq.0).and.(iv3_3.eq.0)
     @            .and.(iv4_3.eq.1))then
                ncorner=4
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_3.eq.0).and.(iv2_3.eq.1).and.(iv3_3.eq.1)
     @              .and.(iv4_3.eq.0))then
                ncorner=4
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_3.eq.0).and.(iv2_3.eq.1).and.(iv3_3.eq.0)
     @             .and.(iv4_3.eq.0))then
                ncorner=4
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.1).and.(iv3_3.eq.1)
     @             .and.(iv4_3.eq.1))then
                if(iv1.eq.0)go to 897
                if(iv2.eq.0)go to 897
                if(iv3.eq.0)go to 897
                if(iv4.eq.0)go to 897
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c 
              if((iv1_3.eq.1).and.(iv2_3.eq.0).and.(iv3_3.eq.1)
     @             .and.(iv4_3.eq.1))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.1).and.(iv3_3.eq.0)
     @            .and.(iv4_3.eq.1))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.1).and.(iv3_3.eq.1)
     @             .and.(iv4_3.eq.0))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.0).and.(iv3_3.eq.0)
     @           .and.(iv4_3.eq.1))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.1).and.(iv3_3.eq.0)
     @            .and.(iv4_3.eq.0))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_3.eq.1).and.(iv2_3.eq.0).and.(iv3_3.eq.0)
     @              .and.(iv4_3.eq.0))then  
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
 897          if((iv1_3.eq.0).and.(iv2_3.eq.0).and.(iv3_3.eq.0).and.
     @           (iv4_3.eq.0))go to 99
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).
     @          and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1)
     @           .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1)
     @               .and.(iv4.eq.1))then
                ncorner=5
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0)
     @            .and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1)
     @              .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.0)
     @             .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1)
     @             .and.(iv4.eq.1))then
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c 
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.1)
     @             .and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0)
     @            .and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1)
     @             .and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0)
     @           .and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0)
     @            .and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0)
     @              .and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c


cc   Add an extra step for the back end.
cc
 99           continue
c              endif   ! if Nalf = 1
502         CONTINUE
 501      CONTINUE               
c
c   Add the L1 point for plotting if phase=90.0 or 180.0
c
          if(phase.eq.90.0)then
            do 600 i=1,Nh
              isave=isave+1
              savex(isave)=xh(i)*separation
              savey(isave)=yh(i)*separation
 600        continue
c
            if(isave.gt.1)then
              call sort3(isave,savex,savey,savey)
            endif
c
c  We want the 5 points with the smallest x-coordinates
c
            do 601 i=1,5
              conex(i)=savex(i)
              coney(i)=savey(i)
 601        continue
c
            call sortcircle(5,conex,coney)
c
            xx1=conex(1)
            xx2=conex(2)
            xx3=conex(3)
            xx4=conex(4)
            xx5=conex(5)
c
            yy1=coney(1)
            yy2=coney(2)
            yy3=coney(3)
            yy4=coney(4)
            yy5=coney(5)
c
            ialf=Nalf/2
            ibet=1
            ncorner=5
c            iidx=(ialf-1)*ibetlim(ialf)+ibet
c            iidx=kount(ialphmax,ialf,ibetlim)+ibet
            iidx=mmdx(ialf,ibet)
            write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %            xx1,yy1,
     %            xx2,yy2,
     %            xx3,yy3,
     %            xx4,yy4,
     %            xx5,yy5
          endif
          
          
 68       format(2(f14.8,3x),e16.9,f10.4,2x,f10.4)
 69       format(e16.9,1x,i3,1x,f9.7,1x,e12.6,1x,f8.5,1x,
     %       2(i3,1x),1x,f10.3,2x,f11.6/,10(f11.6,1x))
c
          close(40)
c
          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getextension(phase,extension,isw7,icounttime)
c
c   October 25, 1999
c
c   extension = '001.00'  for phase = 1.0
c   extension = '011.22'  for phase = 11.22
c   extension = '123.45'  for phase = 123.45  etc.
c
          implicit double precision(a-h,o-z)
c
          character*9 extension
c
          if(isw7.gt.1)then
            write(extension,200)icounttime+100000000
            return
          endif
          if((phase.ge.0.0d0).and.(phase.lt.10.0d0))
     @                     write(extension,100)phase
          if((phase.ge.10.0d0).and.(phase.lt.100.0d0))
     @                     write(extension,101)phase
          if((phase.ge.100.0d0).and.(phase.lt.1000.0d0))
     $                     write(extension,102)phase

 100      format('00',f7.5)
 101      format('0',f8.5)
 102      format(f9.5)
 200      format(i9)
c
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine checkinput(ialphmax1,ibetmax1,Nthetamax,Nrmax,
     &       Nalph1,Nbet1,Nalph2,Nbet2,fill1,fill2,omega1,omega2,dphase,
     @       Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,betarim,rinner,router,
     @       Ntheta,Nradius,alb1,alb2,Nref,
     @       Period,fm,separ,idraw,iecheck,iidint,ism1,icnU,icnB,
     @       icnV,icnR,icnI,icnJ,icnH,icnK,ecc,pshift,
     %       ialphmax2,ibetmax2,ecosw,argper,temprat,ilaw,dwavex,dwavey,
     @       tertQ,P2Q,P3Q,P4Q,P5Q,P6Q,P7Q,P8Q)
c
c   November 1, 1999
c
c   This routine will check the input parameter values and flag any illegal
c   entries (Nalf should be positive, etc.).
c
c   UPDATE April 8, 2002
c
c   Add the variable sw5 to the argument list.  If teff2 < 0 and
c   isw5 > 0, then the separation will be set as follows:
c
c   rkns = 2*pie*sw5*c/Period   ! K-velocity of pulsar, if sw5 is
c                                  projected semimajor axis in seconds
c
c          velamp=(Q+1.0d0)*rkns
c          sifinc=dsin(finc*3.141592653589793d0/180.0d0)
c          p=period*24.0d0*3600.0d0
c          a=velamp/(2.0d0*3.141592653588783d0)*p/sifinc
c          separ=a/6.959d5
c
c
c
          implicit double precision(a-h,o-z)
c
          dimension dwavex(8,3),dwavey(8,3)
          parameter(pie=3.14159265358979323d0)

           character*1 bell
c
c   December 15, 2013:  add the check for the triangular limb darkening
c   sampling:  both coefficients must be between 0.0 and 1.0
c

           bell=char(7)
c
           if(tertQ.gt.999999999.0d0)tertQ=999999999.0d0
           if(P2Q.gt.999999999.9d0)P2Q=999999999.0d0
           if(P3Q.gt.999999999.9d0)P3Q=999999999.0d0
           if(P4Q.gt.999999999.9d0)P4Q=999999999.0d0
           if(P5Q.gt.999999999.9d0)P5Q=999999999.0d0
           if(P6Q.gt.999999999.9d0)P6Q=999999999.0d0
           if(P7Q.gt.999999999.9d0)P7Q=999999999.0d0
           if(P8Q.gt.999999999.9d0)P8Q=999999999.0d0
           if((ilaw.eq.5).or.(ilaw.eq.15))then
             do jj=1,8
               if(dwavex(jj,1).lt.0.0d0)dwavex(jj,1)=0.0d0
               if(dwavex(jj,2).lt.0.0d0)dwavex(jj,2)=0.0d0
               if(dwavex(jj,3).lt.0.0d0)dwavex(jj,3)=0.0d0
               if(dwavey(jj,1).lt.0.0d0)dwavey(jj,1)=0.0d0
               if(dwavey(jj,2).lt.0.0d0)dwavey(jj,2)=0.0d0
               if(dwavey(jj,3).lt.0.0d0)dwavey(jj,3)=0.0d0
c
               if(dwavex(jj,1).gt.1.0d0)dwavex(jj,1)=1.0d0
               if(dwavex(jj,2).gt.1.0d0)dwavex(jj,2)=1.0d0
               if(dwavex(jj,3).gt.1.0d0)dwavex(jj,3)=1.0d0
               if(dwavey(jj,1).gt.1.0d0)dwavey(jj,1)=1.0d0
               if(dwavey(jj,2).gt.1.0d0)dwavey(jj,2)=1.0d0
               if(dwavey(jj,3).gt.1.0d0)dwavey(jj,3)=1.0d0
             enddo
           endif
           if(Nalph1.lt.1)then
             write(*,96)bell
             stop
           endif
c
           if(Nalph2.lt.1)then
             write(*,97)bell
             stop
           endif
c
           if(Nbet1.lt.1)then
             write(*,98)bell
             stop
           endif
c
           if(Nbet2.lt.1)then
             write(*,99)bell
             stop
           endif
c
           if(Nalph1.lt.10)then
             write(*,92)bell
           endif
c
           if(Nalph2.lt.10)then
             write(*,93)bell
           endif
c
           if(Nbet1.lt.5)then
             write(*,94)bell
           endif
c
           if(Nbet2.lt.5)then
             write(*,95)bell
           endif
c
           bell=char(7)
           if(Nalph1.gt.ialphmax1)then
             write(*,100)bell,ialphmax1
             stop
           endif
c
           if(Nalph2.gt.ialphmax2)then
             write(*,101)bell,ialphmax2
             stop
           endif
c
           if(4*Nbet1.gt.ibetmax1)then
             write(*,102)bell,ibetmax1
             stop
           endif
c
           if(4*Nbet2.gt.ibetmax2)then
             write(*,103)bell,ibetmax2
             stop
           endif
c
           if(fill1.gt.1.0d0)then
             write(*,104)bell
             stop
           endif
c
           if(fill2.gt.1.0d0)then
             write(*,104)bell
             stop
           endif
c
           if(omega1.le.0.0d0)then
             write(*,106)bell
             omega1=dabs(omega1) !stop
           endif           
c
           if(omega2.le.0.0d0)then
             write(*,107)bell
             stop
           endif    
c
           if((dphase.le.0.0d0).or.(dphase.gt.360.0d0))then
             write(*,108)bell
             stop
           endif    
c
           if(Q.le.0.0)then
             write(*,109)bell
             stop
           endif
c
c           if((finc.lt.0.0d0).or.(finc.gt.180.0d0))then
c             write(*,110)bell
c             stop
c           endif
c
           if(Teff1.lt.0.0d0)then
             write(*,111)bell
             stop
           endif
c
           if(Teff2.lt.0.0d0)then
             write(2,112)
           endif
c
           if(Tgrav1.le.0.0d0)then
             write(*,113)bell
           endif
c
           if(Tgrav2.le.0.0d0)then
             write(*,114)bell
           endif
c
           if(betarim.lt.0.0d0)then
             write(*,115)bell
             stop
           endif
c
           if(rinner.lt.0.0d0)then
             write(*,116)bell
             stop
           endif
c
           if(router.lt.0.0d0)then
             write(*,117)bell
             stop
           endif
c
           if(temprat.gt.0.0d0)then
             Teff2=Teff1*temprat
             write(2,2118)Teff2
           endif
c
           if((rinner.lt.fill2).and.(Teff2.gt.0.0d0).and.(iidint.ge.1))then
             write(*,118)bell,fill2
             write(2,118)bell,fill2
             rinner=fill2
           endif
c
           if(rinner.gt.1.0d0)then
             write(*,119)bell
             stop
           endif
c
           if(router.gt.1.0d0)then
             write(*,120)bell
             stop
           endif
c
c           if((iidint.ge.1).and.(tdisk.lt.0.0d0))then
c             write(*,121)bell
c             stop
c           endif
c
           if((iidint.ge.1).and.(Ntheta.lt.1))then
             write(*,122)bell
             stop
           endif
c
           if((iidint.ge.1).and.(Ntheta.gt.Nthetamax))then
             write(*,123)bell,Nthetamax
             stop
           endif
c
           if((iidint.ge.1).and.(Nradius.lt.1))then
             write(*,124)bell
             stop
           endif
c
           if((iidint.ge.1).and.(Nradius.gt.Nrmax))then
             write(*,125)bell,Nrmax
             stop
           endif
c
           if(alb1.lt.0.0d0)then
             write(*,126)bell
             stop
           endif
c
           if(alb2.lt.0.0d0)then
             write(*,127)bell
             stop
           endif
c
           if(alb1.gt.1.0d0)then
             write(*,128)bell
             stop
           endif
c
           if(alb2.gt.1.0d0)then
             write(*,129)bell
             stop
           endif
c
           if((separ.lt.0.0d0).and.(Period.le.0.0d0))then
             write(*,130)bell
             stop
           endif
c
           if((separ.lt.0.0d0).and.(fm.le.0.0d0))then
             write(*,131)bell
             stop
           endif
c
c   RVG BUG ALERT  April 19, 2001
c
c   Add the variable ecc to the argument list of getradius.
c
           if(separ.lt.0.0d0)then
             write(2,132)
             call getradius(Q,finc,rad_in_cm,fm,period,ecc)
             separ=rad_in_cm/6.9598d10
             write(2,133)separ
           endif
c
           if(idraw.gt.0)then
             write(2,134)
           endif
c
           if(iecheck.lt.0)then
             write(2,135)
           endif
c
           if(iidint.le.0)then
             write(2,136)
           endif
c
c           if(Nref.lt.0)then
c             write(*,137)bell
c             Nref=0
c           endif
c
           if(Nref.gt.5)then
             write(*,138)bell
           endif
c
           if((ecc.lt.0.0d0).or.(ecc.ge.1.0d0))then
             write(*,141)bell
             ecc=0.0d0
           endif
c
           if((pshift.lt.-1.0d0))then
             write(*,142)bell
             pshift=-1.0d0
           endif
           if((pshift.gt.1.0d0))then
             write(*,142)bell
             pshift=1.0d0
           endif

           icount=0
           if(icnU.eq.0)then
             icnU=430
           else
             icount=icount+1
           endif
           if(icnB.eq.0)then
             icnB=430
           else
             icount=icount+1
           endif
           if(icnV.eq.0)then
             icnV=430
           else
             icount=icount+1
           endif
           if(icnR.eq.0)then
             icnR=430
           else
             icount=icount+1
           endif
           if(icnI.eq.0)then
             icnI=430
           else
             icount=icount+1
           endif
           if(icnJ.eq.0)then
             icnJ=430
           else
             icount=icount+1
           endif
           if(icnH.eq.0)then
             icnH=430
           else
             icount=icount+1
           endif
           if(icnK.eq.0)then
             icnK=430
           else
             icount=icount+1
           endif
c
c        
c    UPDATE June 16, 2003
c
c    If in EBOP mode, set ism1=0
c
           if((iecheck.eq.9).and.(ecc.gt.0.0d0))then
             ism1=0
             write(2,9292)
           endif

           if(icount.eq.0)write(*,140)bell
c
c    July 29, 2005
c
c    If ecosw > 0 and ecc > 0 then set the value of argper
c
          if((ecc.gt.0.0d0).and.(ecosw.gt.0.0d0))then
            call getom(ecc,ecosw,argper)
            write(2,88)argper
          endif 
c
88         format('Info:  The value of argper has been set to ',
     %           f8.4,' degrees')
 92        format(a1,'Warning:  Nalph1 is probably too small (try something',
     %                ' greater than 10)')
 93        format(a1,'Warning:  Nalph2 is probably too small (try something',
     %                ' greater than 10)')
 94        format(a1,'Warning:  Nbet1 is probably too small (try something',
     %                ' greater than 6')
 95        format(a1,'Warning:  Nbet2 is probably too small (try something',
     %                ' greater than 6')
 96        format(a1,'Error:  Nalph1 is less than 1')
 97        format(a1,'Error:  Nalph2 is less than 1')
 98        format(a1,'Error:  Nbet1 is less than 1')
 99        format(a1,'Error:  Nbet2 is less than 1')
 100       format(a1,'Error:  Nalph1 exceeds the maximum limit ',
     @        '(currently ',i4,')')
 101       format(a1,'Error:  Nalph2 exceeds the maximum limit ',
     @        '(currently ',i4,')')
 102       format(a1,'Error:  4*Nbet1 exceeds the maximum limit ',
     @        '(currently ',i4,')')
 103       format(a1,'Error:  4*Nbet2 exceeds the maximum limit ',
     @        '(currently ',i4,')')
 104       format(a1,'Error:  fill1 exceeds 1.0')
c 105       format(a1,'Error:  fill2 exceeds 1.0')
 106       format(a1,'Error:  omega1 is less than 0.0')
 107       format(a1,'Error:  omega1 is less than 0.0')
 108       format(a1,'Error:  dphase is out of bounds (0.0 < dphase','
     @          < 360.0)')
 109       format(a1,'Error:  Q is negative')
 110       format(a1,'Error:  finc is out of bounds (0.0 <= finc <=',
     @          '  90.0)')
 111       format(a1,'Error:  Teff1 is negative')
 112       format(/'Info:  Teff2 is negative---star 2 will be invisible')
 2118      format(/'Info:  Teff2 is set to ',f10.4,' K')
 113       format(a1,'Warning:  Tgrav1 is negative')
 114       format(a1,'Warning:  Tgrav2 is negative')
 115       format(a1,'Error:  betarim is negative')
 116       format(a1,'Error:  rinner is negative')
 117       format(a1,'Error:  router is negative')
 118       format(a1,'Warning:  rinner is in inside star 2---setting ',
     @        ' rinner to fill2 (currently ',f5.3,')')
 119       format(a1,'Error:  rinner exceeds 1.0')
 120       format(a1,'Error:  router exceeds 1.0')
c 121       format(a1,'Error:  tdisk is negative')
 122       format(a1,'Error:  Ntheta is less than 1')
 123       format(a1,'Error:  Ntheta exceeds the maximum (currently ',i3,')')
 124       format(a1,'Error:  Nradius is less than 1')
 125       format(a1,'Error:  Nradius exceeds the maximum (currently ',i3,')')
 126       format(a1,'Error:  alb1 is less than 0')
 127       format(a1,'Error:  alb2 is less than 0')
 128       format(a1,'Error:  alb1 exceeds 1.0')
 129       format(a1,'Error:  alb2 exceeds 1.0')
 130       format(a1,'Error:  Period is less than 0.0')
 131       format(a1,'Error:  fm is less than 0.0')
 132       format('Info:  separation is less than 0.0---computing ',
     %             'the separation from Period and ',
     %            '         f(M)')
 133       format('Info:  the separation has been set to ',f9.5,' solar radii')
 134       format('Info:  output files for drawing codes will be written')
 135       format('Info:  eclipse checking is turned off')
 136       format(/'Info:  there will be no accretion disk')
c 137       format(a1,'Error:  Nref is less than zero---setting Nref=0')
 138       format(a1,'Warning:  Nref is rather large---long ',
     @         ' execution time')
 140       format(a1,'Error:  No filters are specified')
 141       format(a1,'Error:  eccentricity is out of range')
 142       format(a1,'Error:  pshift is out of range')
 9292      format('Info:  Use ism1=0 for iececk=9 and ecc > 0.0')
           return
           end
c
c &&&&&&&&&&&&&&&&
c
           subroutine getradius(Q,finc,rad_in_cm,fm,period,ecc)
c
c   November 1, 1999
c 
c   This routine will return the radius of the orbit in cm, 
c   given the mass function fm in solar masses, the period in days, the
c   inclination finc in degrees, and mass ratio Q.  It is assumed that
c   the mass function of star 2 was measured from the motion of star 1.
c
c   RVG BUG ALERT  April 19, 2001
c
c   Add the variable ecc to the argument list of getradius.  Define fmnew
c   as down below.
c
c
          implicit double precision(a-h,o-z)
c
           eccfac=dsqrt(1.0d0-ecc*ecc)**3
           fmnew=fm/eccfac
c
c    UPDATE Oct31, 2002
c
c    Define fmnew as fm
c
           fmnew=fm
           fincr=finc*0.017453292d0        ! radians
           ppp=period*24.0d0               ! period in hours
           ovq=1.0d0/Q
           sinecubed=(dsin(fincr)**3)
           x_mass=fmnew*(1.0d0+ovq)*(1.0d0+ovq)/sinecubed   ! mass of star 2
           sec_mass=x_mass*ovq                       ! mass of star 2
           total_mass=x_mass+sec_mass   !total mass in solar masses
           coef=3.518847d10
           rad_in_cm=(coef)*(ppp*ppp*total_mass)**(0.33333333333333d0)
c 
           return
           end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine disksetup(Nthetamax,Nrmax,Ntheta,Nradius,
     %       betarim,rinner,router,reff2,Rl2,separ,
     $       tdisk,xi,dtemp,dx,dy,dz,drad,
     $       tedge,xedge,yedge,zedge,redge,stepr,stepz,bdist,
     @       ivrt,reper,rsper)
c
c   November 1, 1999
c
c   This routine will return the x, y, and z-coordinates of the grid
c   points on the disk.  Also, the temperatures of each point are returned.
c
c   November 29, 1999
c
c   Use as the radial coordinate zeta=2*dsqrt(r).  This will give more
c   points near the inner edge where the temperature is changing rapidly.
c
c
c   February 12, 2001
c
c   Put in the general case for eccentric orbits.  The flat ivrt=0 means
c   to setup the disk at periastron.  The values of rsmall and redge
c   are saved and used for other phases.
c
c
          implicit double precision(a-h,o-z)
c
          parameter (pie=3.14159265358979323d0)
          dimension dtemp(Nrmax*Nthetamax),dx(Nrmax*Nthetamax),
     &      dy(Nrmax*Nthetamax),dz(Nrmax*Nthetamax),
     &      drad(Nrmax),xedge(Nthetamax*11),yedge(Nthetamax*11),
     &      zedge(Nthetamax*11),tedge(Nthetamax*11)
c
c   Start with the disk face.  It is assumed that the lower face is exactly
c   the same as the upper face, but with a negative z-value.  In practice,
c   however, we never see the bottom face.
c          
          radcon=pie/180.0d0
          if(ivrt.eq.0)then
            redge=router*reff2              ! radius of outer edge in x units
            rsmall=rinner*Rl2               ! radius of inner edge in x units
            reper=redge
            rsper=rsmall
          else
            redge=reper
            rsmall=rsper
          endif
          betarad=betarim*radcon       ! radians
          steptheta=360.0d0/dble(ntheta)
          stepr=(redge-rsmall)/dble(Nradius-1)
c
c   Transform r into zeta.
c
          zetain=2.0d0*dsqrt(rsmall)
          zetaout=2.0d0*dsqrt(redge)
          stepzeta=(zetaout-zetain)/dble(Nradius-1)
c
c  UPDATE DECEMBEE 17, 2001
c
c  If tdisk is negative, we should ignore the disk flux.
c  If this is the case, then assign a dummy disk temperature.
c
          tdummy=10000.0
          if(tdisk.gt.0.0d0)tdummy=tdisk
c
          theta=0.0d0
          zeta=zetain
          do 10 ir=1,Nradius
            zeta=zetain+dble(ir-1)*stepzeta
            drad(ir)=zeta
            r=0.25d0*zeta*zeta
            do 9 ithet=1,Ntheta              ! theta goes from zero to 360-step
              theta=dble(ithet)*steptheta -0.5*steptheta  ! degrees
              thetar=theta*radcon            ! radians
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(ir-1)*Ntheta+ithet
c
              dx(iidx)=bdist-r*dcos(thetar)
              dy(iidx)=r*dsin(thetar)
              dz(iidx)=r*dtan(betarad)
c
c  UPDATE DECEMBEE 17, 2001
c
c  If tdisk is negative, we should ignore the disk flux.
c  If this is the case, then assign a dummy disk temperature.
c
              dtemp(iidx)=tdummy*(r/rsmall)**(xi)
c              dtemp(ir,ithet)=tdisk*(r/rsmall)**(xi)
              tlast=dtemp(iidx)
 9          continue
 10       continue
c
          zrim=redge*dtan(betarad)      ! z coordinate of outer edge
          stepz=zrim*0.2d0             ! 5 steps above and 5 steps below
c                                    ! the plane
          do 20 iz=-5,5
            z=dble(iz)*stepz
            do 19 ithet=1,Ntheta             ! theta goes from zero to 360-step
              theta=dble(ithet)*steptheta-0.5*steptheta   ! degrees
              thetar=theta*radcon         ! radians
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(iz+6-1)*Ntheta+ithet
c
              xedge(iidx)=bdist-redge*dcos(thetar)
              yedge(iidx)=redge*dsin(thetar)
              zedge(iidx)=z
              tedge(iidx)=tlast
 19         continue
 20       continue
c
          write(2,100)rsmall*separ,redge*separ
c
c   UPDATE DECEMBER 17, 2001
c
c   Add an if-then clause in case the disk temperature is negative.
c
          if(tdisk.gt.0.0d0)then
            iidx=(6-1)*Ntheta+1
            write(2,101)tlast,xedge(iidx),yedge(iidx),zedge(iidx)
          else
            write(2,102)
          endif
c
c   Scale the step size in zeta by 1/cos^2(betarim) for use in the
c   flux summing routine.
c
          stepr=stepzeta/(dcos(betarad)*dcos(betarad))

 100      format(//'inner disk radius = ',f11.6,' solar radii',
     &      5x,/'outer disk radius = ',f11.6,' solar radii')
 101      format('temperature at outer edge = ',f7.1,3x,3(f6.4,1x))
 102      format('disk temperature negative, will ignore disk flux')
c
          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine dummyvalues(ialphmax2,ibetmax2,Nalph2,Nbet2,
     $        x2,y2,z2,surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,
     @        temp2,ibetlim2,mmdx2)
c
c  November 1, 1999
c
c  This routine is called when Teff2 < 0.  In this case, star 2 is invisible
c  (usually X-ray binary mode).  The coordinates are set to 0.0, the
c  gradients are set to 0.0, the gravities are set to 1.0, and the
c  limbdarkening coefficients are set to 0.0
c
c  UPDATE March 22, 2002
c
c  Add ibetlim2 to the argument list.  Dimension it below:
c
          implicit double precision(a-h,o-z)

          dimension x2(ialphmax2*ibetmax2),y2(ialphmax2*ibetmax2),
     %      z2(ialphmax2*ibetmax2),surf2(ialphmax2*ibetmax2),
     &      gradx2(ialphmax2*ibetmax2),
     &      grady2(ialphmax2*ibetmax2),gradz2(ialphmax2*ibetmax2),
     $      g2(ialphmax2*ibetmax2),xend2(4),temp2(ialphmax2*ibetmax2),
     %      ibetlim2(ialphmax2),mmdx2(ialphmax2,ibetmax2)
c
          mmcount=0
          do 10 ialf=1,Nalph2
c
c   UPDATE March 22, 2002
c
c   Define the values of ibetlim2, and assign gradients values of 1
c
            ibetlim2(ialf)=4*Nbet2
            do 9 ibet=1,4*Nbet2
c              iidx=(ialf-1)*4*Nbet2+ibet
              mmcount=mmcount+1
              mmdx2(ialf,ibet)=mmcount
              iidx=mmcount
              x2(iidx)=0.0d0          
              y2(iidx)=0.0d0          
              z2(iidx)=0.0d0          
              gradx2(iidx)=1.0d0          
              grady2(iidx)=1.0d0          
              gradz2(iidx)=1.0d0
              g2(iidx)=1.0d0      
              surf2(iidx)=1.762429d-2          
              temp2(iidx)=1.0d0          
 9          continue
 10       continue
c
          xend2(1)=9.9999999d0
          xend2(2)=9.9999999d0
          reff=9.9999999d0
          psi0=-9.999999d0
          Tpole=-9.99999d0
c
          darkbol2=0.0d0
c
          write(3,3000)reff
          write(3,3001)reff
          write(3,3002)xend2(1)
          write(3,3003)xend2(2)
          write(3,3004)psi0
          write(3,3005)reff
          write(3,3006)reff
          write(3,3007)Tpole
c
 3000     format( f9.6,11x,'R_eff (star 2)')
 3001     format( f9.6,11x,'R_pole (star 2)')
 3002     format( f9.6,11x,'x(point) (star 2)')
 3003     format( f9.6,11x,'x(end) (star 2)')
 3004     format(f12.6, 8x,'potential at fill2*L1')
 3005     format(e16.9, 4x,'surface area (star 2)')
 3006     format(e16.9, 4x,'volume (star 2)')
 3007     format(f10.4,10x,'polar temperature (star 2)')

          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine dummyhoriz(ibetmax2,Nbet2,Nhoriz2,
     %       xhoriz2,yhoriz2,Ntop2,xtop2horiz,ytop2horiz)
c
c  November 1, 1999
c
c  This routine is called if Teff2 < 0, in which case star 2 is invisible
c  (X-ray binary mode usually).  The horizon of star 2 is moved off to
c  a suitably large distance so that star 1 is never eclipsed.
c
c
          implicit double precision(a-h,o-z)
c
          dimension xhoriz2(ibetmax2),yhoriz2(ibetmax2),
     %       xtop2horiz(ibetmax2),ytop2horiz(ibetmax2)
c
          Nhoriz2=Nbet2
          Ntop2=Nbet2
c
          steptheta=360.0d0/dble(Nbet2)
          r=10.0
          do 10 i=1,Nbet2
            theta=dble(i)*steptheta
            thetar=theta*3.14159265358979d0/180.0d0
            x=r*dcos(thetar)
            y=r*dsin(thetar)
            xhoriz2(i)=x+999.99d2
            yhoriz2(i)=y+999.99d2
            xtop2horiz(i)=x+999.99d2
            ytop2horiz(i)=y+999.99d2
 10       continue
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine zheight(xA,yA,zA,xB,yB,zB,rout,zcross)
c
c   This program assumes there are two stars in the normal coordinate
c   frame, and that there is a disk of radius r_outer centered on
c   star 2.  Given a point on star 1 (xA,yA,zA), and on star 2 (xB,yB,zB),
c   this routine determines the z-value of where the line joining the two
c   points crosses the disk edge.
c
c   Use Newton's method to find the t such that dziff=0
c
c
          implicit double precision(a-h,o-z)
c
          t=0.5d0
          do 10 i=1,6  
            tnew=t-zdiff(xA,yA,xB,yB,rout,t)
     &             /zprimediff(xA,yA,xB,yB,t)
            t=tnew
 10       continue
c
          z=zA+(zB-zA)*t
c
          zcross=z          
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          double precision function zdiff(xA,yA,xB,yB,rout,ttt)
c
c   November 2, 1999
c
c   When given two grid points xA,yA,zA and xB,yB,zB, parametric equations
c   in ttt can be written that give the x,y,z coordinates of points along
c   the line joining the two grid points.
c   This function computes the difference between the radius of the
c   x,y coordinates
c   of a point given by ttt
c   on a line joining grid points xA,yA,zA and xB,yB,zB and
c   the radius rout.
c
c
          implicit double precision(a-h,o-z)
c
          t1=(xA+(xB-xA)*ttt-xB)**2
          t2=(yA+(yB-yA)*ttt)**2
          t3=0.0d0  
          zdiff=dsqrt(t1+t2+t3)-rout
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          double precision function zprimediff(xA,yA,xB,yB,ttt)
c
c   November 2, 1999
c
c   The derivitive wrt to ttt of zdiff given above.   
c
c
          implicit double precision(a-h,o-z)
c
          t1=(xA+(xB-xA)*ttt-xB)**2
          t2=(yA+(yB-yA)*ttt)**2
          t3=0.0d0           !(zA+(zB-zA)*ttt)**2
c
          t4=2.0d0*(xA+(xB-xA)*ttt-xB)*(xB-xA)
          t5=2.0d0*(yA+(yB-yA)*ttt)*(yB-yA)
          t6=0.0d0  
c
          zprimediff=0.5d0*(t4+t5+t6)/dsqrt(t1+t2+t3)
c
          return
          end
c
c   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
c 
          subroutine gettophorizon(istar,ialphmax,ibetmax,Nalf,
     @      ibetlim,phase,finc,Q,xarray,yarray,zarray,
     @      gradx,grady,gradz,Nhoriz,xhoriz,yhoriz,
     @      bdist,mmdx,tertincl,tertbdist,
     @      tertphase,tertQ,axisscale,isw30,isw7,tertOmega)
c
c  November 3, 1999
c
c  This routine will consider only positive z-values of the star and
c  find the apparent horizon.  This horizon for star 2 is needed if there
c  is a disk---points on the disk that project (in sky coordinates)
c  inside this horizon are behind star 2.
c
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     $        zarray(ialphmax*ibetmax),xhoriz(4*ibetmax),
     @        yhoriz(4*ibetmax),gradx(ialphmax*ibetmax),
     @        grady(ialphmax*ibetmax),gradz(ialphmax*ibetmax),
     @        arrproj(10000),xdummy(10000),ydummy(10000),
     @        ibetlim(ialphmax),mmdx(ialphmax,ibetmax)
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c  Initialize.
c
          do 1 i=1,5000
            xdummy(i)=0.0d0
            ydummy(i)=0.0d0
 1        continue
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
          A2 = DACOS(AX)
          A3 = DSIN(A2)
          IF (A3.LT.0.0d0) A3=0.0d0
c          IF (A3.EQ.0.0d0) GO TO 508
c          B1=AZ/DSIN(A2)
c          IF(B1.GT.1.0d0) B1=1.d0
c          BETA = DASIN(B1)              !beta is the angle between the surface
c          GO TO 509                     !normal and the radius vector.
c508       BETA = 0.0d0
c509       continue
c
          Ndummy=0
c
c   Loop over alpha first.  
c
          do 950 ialf=1,nalf/2       
            do 949 ibet=1,ibetlim(ialf)    !2*Nbet   
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c               iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              arrproj(ibet)=AX*GRADX(iidx) + AY*GRADY(iidx) + 
     @            AZ*GRADZ(iidx)
c
c   Check the last latitude row before the xy plane and include that
c   in the top horizon
c
            if(ialf.eq.nalf/2)then
              if(arrproj(ibet).ge.0.0d0)then
                izz=ialf
                jzz=1
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
                xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)  
                yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
                xp=xp+xxoff
                yp=yp+yyoff
                Ndummy=Ndummy+1
                xdummy(Ndummy)=xp
                ydummy(Ndummy)=yp
              endif
            endif
 949        continue
c
c   We have the array of projection factors along a given direction.
c   Now find out where the sign change is.  This is where the line of sight
c   has moved over the horizon.
c
            do 940 ibet=1,ibetlim(ialf)  !  -1    !nbet4-1
              if(ibet.lt.ibetlim(ialf))then
                index=ibet+1
              else
                index=1
              endif
              rsign=arrproj(ibet)*arrproj(index)
              if(rsign.le.0.0d0)then     ! crossed over
                if(arrproj(ibet).gt.0.0d0)then
                  izz=ialf
                  jzz=ibet
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
c                  rvis=radarray(iidx)
c                  phivis=phiar(iidx)
c
                  izz=ialf
                  jzz=index
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
c                  xhid=xarray(iidx)
c                  yhid=yarray(iidx)
c                  zhid=zarray(iidx)
c                  rhid=radarray(iidx)
c                  phihid=phiar(iidx)
                else
                  izz=ialf
                  jzz=index
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
c                  rvis=radarray(iidx)
c                  phivis=phiar(iidx)
c
                  izz=ialf
                  jzz=ibet
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
c                  xhid=xarray(iidx)
c                  yhid=yarray(iidx)
c                  zhid=zarray(iidx)
c                  rhid=radarray(iidx)
c                  phihid=phiar(iidx)
                endif
c
                xx=xvis
                yy=yvis
                zz=zvis
c
                xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)  
                yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
                xp=xp+xxoff
                yp=yp+yyoff
                Ndummy=Ndummy+1
                xdummy(Ndummy)=xp
                ydummy(Ndummy)=yp
              endif
 940        continue
 950      continue
c
c   Now 'sort' the horizon points so that a regular polygon is made.
c
          call sortcircle(Ndummy,xdummy,ydummy)
c
c   The above array may have repeated points.  Remove them.
c
          call uniquepoint(Ndummy,xdummy,ydummy,Nhoriz,xhoriz,yhoriz)
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getdiskhoriz(Nthetamax,Ntheta,
     %       Q,phase,finc,xedge,yedge,zedge,Ndhoriz,dxhoriz,dyhoriz,
     %       Ndtop,dtopx,dtopy,bdist,tertincl,tertbdist,tertphase,tertQ,
     @       axisscale,isw30,isw7,tertOmega)
c
c   November 3, 1999
c
c   This routine will find the horizon of the disk.  The horizon is simply
c   the lower rim for the front part (proj>0) and the upper rim for the
c   back part (proj<0).
c
c
          implicit double precision(a-h,o-z)
c
          parameter (pie=3.14159265358979323d0)
          dimension xedge(Nthetamax*11),yedge(Nthetamax*11),
     &      zedge(Nthetamax*11),dxhoriz(2*Nthetamax),dyhoriz(2*Nthetamax),
     %      dtopx(2*Nthetamax),dtopy(2*Nthetamax)       
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
          radcon=pie/180.0d0
          fincr=finc*radcon
          sifinc=dsin(fincr)
c
          Ndhoriz=0
          Ndtop=0
          kkk=0
          steptheta=360.0d0/dble(ntheta)
          do 19 ithet=1,Ntheta              ! theta goes from zero to 360-step
            theta=dble(ithet)*steptheta-0.5*steptheta   ! degrees
            angdiff=(theta-phase)*radcon
            proj=sifinc*dcos(angdiff)  
            if(proj.gt.0.0)then
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(1-1)*Ntheta+ithet
c
              xx=xedge(iidx)
              yy=yedge(iidx)
              zz=zedge(iidx)
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,1,bdist)  
              yp=diskytran(xx,yy,zz,phase,fincr,Q,1,bdist)  
              xp=xp+xxoff
              yp=yp+yyoff
              Ndhoriz=Ndhoriz+1
              dxhoriz(Ndhoriz)=xp
              dyhoriz(Ndhoriz)=yp
            else
              iidx=(11-1)*Ntheta+ithet
              xx=xedge(iidx)
              yy=yedge(iidx)
              zz=zedge(iidx)
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,1,bdist)  
              yp=diskytran(xx,yy,zz,phase,fincr,Q,1,bdist)  
              xp=xp+xxoff
              yp=yp+yyoff
              Ndhoriz=Ndhoriz+1
              dxhoriz(Ndhoriz)=xp
              dyhoriz(Ndhoriz)=yp
            endif
            iidx=(11-1)*Ntheta+ithet
            xx=xedge(iidx)
            yy=yedge(iidx)
            zz=zedge(iidx)
            xp=diskxtran(xx,yy,zz,phase,fincr,Q,1,bdist)  
            yp=diskytran(xx,yy,zz,phase,fincr,Q,1,bdist)  
            xp=xp+xxoff
            yp=yp+yyoff
            Ndtop=Ndtop+1
            dtopx(Ndtop)=xp
            dtopy(Ndtop)=yp
c
            if(ithet.gt.1)then
              rsign=proj*rlastproj
              if(rsign.lt.0.0d0)then
                kkk=kkk+1
              endif
            endif
              rlastproj=proj
 19       continue
c
          call sortcircle(Ndhoriz,dxhoriz,dyhoriz)
          call sortcircle(Ndtop,dtopx,dtopy)
c
          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine diskvisib(Nrmax,Nthetamax,Nradius,Ntheta,phase,
     @      finc,Q,betarim,dx,dy,dz,xedge,yedge,zedge,diskproj,edgeproj,
     @      dvisib,evisib,Nskydisk,xskydisk,yskydisk,zskydisk,Nskyedge,
     @      xskyedge,yskyedge,Ntop2,xtop2horiz,ytop2horiz,Nhoriz1,
     @      xhoriz1,yhoriz1,Ndtop,dtopx,dtopy,iecheck,Neclipse,bdist,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega)
c
c   November 8, 1999
c
c   This routine will return an array of projection angles for the
c   disk (diskproj) and for the edge (edgeproj).  It will also check
c   for eclipses by star 1, the top of star 2, and the rim of the disk.
c   If any part of the disk is blocked, then the visibility of that
c   element is set to zero (dvisib, evisib).  For elements that are not
c   blocked, the visibilities are set to the projection.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension diskproj(Nrmax*Nthetamax),edgeproj(Nthetamax*11),
     &      dvisib(Nrmax*Nthetamax),evisib(Nthetamax*11),
     &      xskydisk(Nthetamax*Nrmax),yskydisk(Nthetamax*Nrmax),
     &      zskydisk(Nthetamax*Nrmax),
     &      xskyedge(Nthetamax*11),yskyedge(Nthetamax*11),
     $      xtop2horiz(Ntop2),ytop2horiz(Ntop2),
     @      xhoriz1(Nhoriz1),yhoriz1(Nhoriz1),dx(Nrmax*Nthetamax),
     &      dy(Nrmax*Nthetamax),dz(Nrmax*Nthetamax),xedge(Nthetamax*11),
     &      yedge(Nthetamax*11),zedge(Nthetamax*11),
     &      dtopx(2*Nthetamax),dtopy(2*Nthetamax)
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c  initialize the visibilities
c
          radcon=pie/180.0d0
          do 2 i=1,Nrmax
            do 1 j=1,Nthetamax
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(i-1)*Ntheta+j
c
              dvisib(iidx)=0.0d0
              diskproj(iidx)=0.0d0
 1          continue
 2        continue
c
          do 4 i=1,Nthetamax
            do 3 j=1,11
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(j-1)*Ntheta+i
c
              evisib(iidx)=0.0d0
              edgeproj(iidx)=0.0d0
 3          continue
 4        continue
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          Nskydisk=0
          Nskyedge=0
          Neclipse=0
c
          infront=0
          if((phase.ge.90.0d0).and.(phase.le.270.0d0))infront=1
c
c   Start with the disk face.  Loop over theta and r, compute the projection
c   factors from the standard coordinates, check for eclipses, etc.
c
          steptheta=360.0d0/dble(ntheta)
          betarad=betarim*radcon                  ! radians
c
c   Put the trig calls outside of the loop.
c
          cophase=dcos(phaser)
          siphase=dsin(phaser)
          cofinc=dcos(fincr)
          sifinc=dsin(fincr)
          cobet=dcos(betarad)
          sibet=dsin(betarad)
          do 20 ir=1,Nradius
            do 19 ithet=1,Ntheta             ! theta goes from zero to 360-step
              theta=dble(ithet)*steptheta-0.5*steptheta  ! degrees
              thetar=theta*radcon            ! radians
c
               iidx=(ir-1)*Ntheta+ithet
c               
c              t1=-dcos(phaser)*dsin(fincr)*dsin(betarad)*dcos(thetar)
c              t2=-dsin(phaser)*dsin(fincr)*dsin(betarad)*dsin(thetar)
c              t3=dcos(fincr)*dcos(betarad)
c
              t1=-cophase*sifinc*sibet*dcos(thetar)
              t2=-siphase*sifinc*sibet*dsin(thetar)
              t3=cofinc*cobet
              proj=t1+t2+t3
c
c   This projection factor accounts for points below the rim (in cases of
c   large beta_rim and high inclination).
c
c   old statement:
c
c            front=dcos(phaser-thetar)
c 
c   The correct new statement:
c
              angdiff=(theta-phase)*radcon
              front=sifinc*dcos(angdiff)  !sifinc*dcos(phaser-thetar)
c
c   END BUG
c
              if((ir.eq.Nradius).and.(front.gt.0.0).and.(proj.le.0.0))then
                proj=sifinc*dcos(angdiff)   !dcos(phaser-thetar)
              endif
              diskproj(iidx)=proj
              if(proj.le.0.0)go to 19
              xx=dx(iidx)
              yy=dy(iidx)
              zz=dz(iidx)
c
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,1,bdist)
              yp=diskytran(xx,yy,zz,phase,fincr,Q,1,bdist)
              xp=xp+xxoff
              yp=yp+yyoff              
c
              if(infront.ne.1)then
                if(iecheck.ge.0)then
                  iyes=-100
                  call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,
     @               icut)
                  if(iyes.eq.100)then
                    Neclipse=Neclipse+1
                    go to 19   !eclipsed by star 1
                  endif
                endif
              endif
c
c   Check to see of the top of the star 2 blocks the point in question.
c   Front < 0 for points that are further away than star 2.  These points
c   could be blocked by star 2.  Points with front > 0 in the inner ring
c   may be inside the top horizon of star 2 due to roundoff error.  The
c   if-then block should make sure that points in the inner ring that
c   are in front of star 2 are included.
c
              if(front.lt.0.0)then
                iyes=-100
                call insidecircle(Ntop2,xtop2horiz,ytop2horiz,
     %                  xp,yp,iyes,icut)
                if(iyes.eq.100)go to 19
              endif
c
c   Finally, check to see of the point in question is beneath the disk
c   rim.  If so, then it is invisible to the observer.  To check this
c   we simply see of the point in question is *inside* the top horizon of
c   the disk.
c
              if(ir.ne.Nradius)then
                iyes=-100
                call insidecircle(Ndtop,dtopx,dtopy,xp,yp,iyes,icut)
                if(iyes.ne.100)go to 19 
              endif
              Nskydisk=Nskydisk+1
              xskydisk(Nskydisk)=xp
              yskydisk(Nskydisk)=yp
              zskydisk(Nskydisk)=proj
              dvisib(iidx)=proj
 19         continue
 20       continue
c
          do 30 ithet=1,Ntheta             ! theta goes from zero to 360-step
            theta=dble(ithet)*steptheta-0.5*steptheta  ! degrees
            thetar=theta*radcon            ! radians
c
            do 29 iz=1,11
c
c   Old statement:
c
c              proj=dsin(fincr)*dcos(phaser-thetar)            
c
c   The correct new statements:
c
              angdiff=(theta-phase)*radcon
              proj=sifinc*dcos(angdiff)  !sifinc*dcos(phaser-thetar)
c
              iidx=(iz-1)*Ntheta+ithet

              edgeproj(iidx)=proj
              if(proj.le.0.0d0)go to 29
              xx=xedge(iidx)
              yy=yedge(iidx)
              zz=zedge(iidx)
c
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,1,bdist)
              yp=diskytran(xx,yy,zz,phase,fincr,Q,1,bdist)
              xp=xp+xxoff
              yp=yp+yyoff              
c
              if(infront.ne.1)then
                if(iecheck.ge.0)then
                  iyes=-100
                  call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,
     @              icut)
                  if(iyes.eq.100)then
                    Neclipse=Neclipse+1
                    go to 29   !eclipsed by star 1
                  endif
                endif
              endif
              Nskyedge=Nskyedge+1
              xskyedge(Nskyedge)=xp
              yskyedge(Nskyedge)=yp
              evisib(iidx)=proj
 29         continue
 30       continue
c
          return
          end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getdiskBBflux(Nrmax,Nthetamax,Nradius,
     %        Ntheta,diskproj,edgeproj,dvisib,evisib,dtemp,tedge,drad,
     $        dinty,einty,stepr,stepz,www,iwww,ilaw,dflux,separ)
c
c   November 8, 1999
c
c   This routine will integrate the flux from the visible parts of
c   the disk and return the result as dflux.
c
c   November 16, 1999
c
c   This routine uses passband specific limb darkening coefficients taken
c   from Van Hamme (1993, AJ, 106, 2096).  I assume log(g)=5.
c
c   November 29, 1999
c
c   Use as the radial coordinate zeta=2.0*dsqrt(r).  This will
c   put more grid points at smaller radii where the temperature
c   might be changing rapidly.  r*d(r) = (1/8)*zeta^3*d(zeta).
c   The variable 'stepr' is actually the stepsize in zeta, and the
c   array 'drad' actually contains zeta values.
c
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
c   by (separ*solarrad)**2.
c
          implicit double precision(a-h,o-z)
c
          dimension diskproj(Nrmax*Nthetamax),edgeproj(Nthetamax*11),
     &      dvisib(Nrmax*Nthetamax),evisib(Nthetamax*11),
     &      dinty(Nrmax*Nthetamax),einty(Nthetamax*11),
     &      dtemp(Nrmax*Nthetamax),drad(Nrmax),
     &      tedge(Nthetamax*11)
c
          parameter(pie=3.14159265358979323d0)
c
c
c   December 15, 2013:  new triangular sampling for quad law
c
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            saveflimbx=flimbx
            saveflimby=flimby
            flimbx=2.0d0*dsqrt(saveflimbx)*saveflimby
            flimby=dsqrt(saveflimbx)*(1.0d0-2.0d0*saveflimby)
          endif

          dark=1.0d0
          dflux=0.0
          C2 = 1.4384d8             ! hc/(k*1e-8)
          C1 = 1.191044d35          ! 2hc^2/((1e-8)**5)
c
          steptheta=360.0d0/dble(ntheta)
          deg2rad=pie/180.0d0
c
          c1=3.74185
          c2=14.3883
          wavemu=www/10000.0d0
          DO 10 ir=1,Nradius
            iidx=(ir-1)*Ntheta+1
            if(iwww.eq.1)call flcU50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.2)call flcB50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.3)call flcV50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.4)call flcR50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.5)call flcI50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.6)call flcJ50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.7)call flcH50(dtemp(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.8)call flcK50(dtemp(iidx),ilaw,flimbx,flimby)
c
c            ddint=pie*(1.0d0-flimbx/3.0d0)
c            if(ilaw.eq.2)then
c              ddint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
c            endif
c            if(ilaw.eq.3)then
c              ddint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
c            endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
c            if(ilaw.eq.4)then
c              ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)
c            endif
c
            ringflux=0.0d0
            DO 9 ithet=1,Ntheta
              iidx=(ir-1)*Ntheta+ithet
              dinty(iidx)=0.0d0
              if(diskproj(iidx).le.0.0)go to 9
c              C3 = C2/(www*dtemp(iidx))
              c3=c2/(wavemu*dtemp(iidx)/1000.0d0)
              flum=C1/(dexp(c3)-1.0d0)/wavemu**5
              if(ilaw.le.1)dark=(1.0d0-flimbx+flimbx*diskproj(iidx))
              if(ilaw.eq.2)then
                dark=1.0d0-flimbx*(1.0d0-diskproj(iidx))
                dark=dark-flimby*diskproj(iidx)*dlog(diskproj(iidx))
              endif
              if(ilaw.eq.3)then
                dark=1.0d0-flimbx*(1.0d0-diskproj(iidx))
                dark=dark-flimby*(1.0d0-dsqrt(diskproj(iidx)))
              endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
              if(ilaw.eq.4)then
                dark=1.0d0-flimbx*(1.0d0-diskproj(iidx))
                dark=dark-flimby*(1.0d0-(diskproj(iidx)))**2
              endif
              if(ilaw.eq.5)then
                dark=1.0d0-flimbx*(1.0d0-diskproj(iidx))
                dark=dark-flimby*(1.0d0-(diskproj(iidx)))**2
              endif
c
              flum=flum*dark
              dinty(iidx)=flum ! save intensities for plotting
c
c   Here is the old term when the steps were linear in r:
c
c              flum=drad(ir)*flum*dvisib(ir,ithet)*stepr*steptheta
c
c   Here is the expression for steps in the zeta coordinate:
c
c   April 19, 2001:   RVG BUG ALERT
c
c   Convert the steptheta into radians!
c
              flum=((1.0d0/8.0d0)*drad(ir)**3)*flum*
     &                 dvisib(iidx)*stepr*steptheta*deg2rad
              ringflux=ringflux+flum
 9          continue
            dflux=ringflux+dflux
 10       continue
c
          do 20 ithet=1,Ntheta
            iidx=(1-1)*Ntheta+ithet
            if(iwww.eq.1)call flcU50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.2)call flcB50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.3)call flcV50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.4)call flcR50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.5)call flcI50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.6)call flcJ50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.7)call flcH50(tedge(iidx),ilaw,flimbx,flimby)
            if(iwww.eq.8)call flcK50(tedge(iidx),ilaw,flimbx,flimby)
c
            ringflux=0.0d0
c            ddint=pie*(1.0d0-flimbx/3.0d0)
c            if(ilaw.eq.2)then
c              ddint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
c            endif
c            if(ilaw.eq.3)then
c              ddint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
c            endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
c            if(ilaw.eq.4)then
c              ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)
c            endif
c
            do 19 iz=1,11
              iidx=(iz-1)*Ntheta+ithet
c              jjdx=(ir-1)*Ntheta+ithet
              einty(iidx)=0.0d0
              if(edgeproj(iidx).lt.0.0)go to 19
c              C3 = C2/(www*tedge(ithet,iz))
              c3=c2/(wavemu*tedge(iidx)/1000.0)
              flum=C1/(dexp(c3)-1.0d0)/wavemu**5
              if(ilaw.le.1)dark=(1.0d0-flimbx+flimbx*edgeproj(iidx))
              if(ilaw.eq.2)then
                dark=1.0d0-flimbx*(1.0d0-edgeproj(iidx))
                dark=dark-flimby*edgeproj(iidx)*dlog(edgeproj(iidx))
              endif
              if(ilaw.eq.3)then
                dark=1.0d0-flimbx*(1.0d0-edgeproj(iidx))
                dark=dark-flimby*(1.0d0-dsqrt(edgeproj(iidx)))
              endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
              if(ilaw.eq.4)then
                dark=1.0d0-flimbx*(1.0d0-edgeproj(iidx))
                dark=dark-flimby*(1.0d0-(edgeproj(iidx)))**2
              endif
              if(ilaw.eq.5)then
                dark=1.0d0-flimbx*(1.0d0-edgeproj(iidx))
                dark=dark-flimby*(1.0d0-(edgeproj(iidx)))**2
              endif
c
              flum=flum*dark
              einty(iidx)=flum ! save intensities for plotting
c
c   April 19, 2001:   RVG BUG ALERT
c
c   Convert the steptheta into radians!
c
              flum=flum*evisib(iidx)*stepz*steptheta*deg2rad
c
c   The upper rim points are in the face integration.  If iz=11, then don't
c   add to dflux.
c
              if(iz.lt.11)ringflux=ringflux+flum          
 19         continue
c
c   April 17, 2001
c
c   Add this scaling to make the flux consistent with the stellar flux
c   integration.
c            
c            dflux=pie*ringflux/ddint+dflux
c
            dflux=ringflux+dflux
c
 20       continue
c
c   UPDATE April 3, 2002
c
c   Scale the flux
c
          solarrad=6.9598d10
          dflux=dflux*(separ*solarrad)**2

c          write(*,*)'ddint  ', ddint/pie
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine wlinmod(icount,xmod,ymod,fileout,isw7)
c
c  November 10, 1999
c
c  This routine will open the output file and record the given model
c  with flux in linear units.  The phases will be scaled to go from 0.0 to
c  1.0, and an extra phase will be added.
c
c
c
          implicit double precision(a-h,o-z)

          dimension xmod(icount),ymod(icount)
          character*(*) fileout
c
          open(unit=20,file=fileout,status='unknown')
c
          do 10 i=1,icount
            write(20,100)xmod(i),ymod(i)
 10       continue
c
          if(isw7.ge.2)then
            close(20)
            return
          endif
          do 20 i=1,icount
            write(20,100)xmod(i)+1.0d0,ymod(i)
 20       continue
c
          close(20)
c
 100      format(f23.15,3x,1pe21.14)
c
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine getvel(ialphmax,ibetmax,Nalf,ibetlim,
     &      istar,omega,phase,finc,
     %      Q,flum,xcoords,ycoords,flux,separ,period,gamma,vel,delvel,
     $      rldint,ecc,argrad,mmdx,isw13,ialfmin,ialfmax,
     $      bigI,bigbeta,zcoords)

c
c    November 12, 1999
c
c    This routine will compute the flux-weighted radial velocity of the
c    star in question.
c
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)    
          dimension flum(ialphmax*ibetmax),xcoords(ialphmax*ibetmax),
     &      ycoords(ialphmax*ibetmax),ibetlim(ialphmax),
     &      mmdx(ialphmax,ibetmax),zcoords(ialphmax*ibetmax)
c
c   RVG BUG ALERT   April 23, 2001
c
c   Move the definitions of argfac, efact, and dint to the top here
c
          argfac=ecc*dcos(argrad)
          efact=1.0d0/dsqrt(1.0d0-ecc*ecc)
          rdint=rldint/pie
          vel=0.0d0
          delvel=0.0d0
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c
          siphase=dsin(phaser)
          cophase=dcos(phaser)
          sifinc=dsin(fincr)
          cofinc=dcos(fincr)
c
c   Compute the expected K velocity, which is the circular velocity times 
c   dsin(finc).
c
c    
          a=separ*6.9598d5            !separation in km
          p=period*24.00d0*3600.00d0       !period in seconds
          velamp=2.0d0*pie*a/p*efact
c
c    Check to see if the star has any flux before going further!
c        
          if(flux.le.0.0d0)then
c
c   RVG BUG ALERT   April 23, 2001
c
c   Move this if-then block a bit further down.
c   Set delvel=0.0d0 in the case when the flux is 0.  Also, set
c   the velocity to the velocity expected from orbital motion so the
c   output velocity curve is smooth during the eclipse
c
            ppp = (PHASE/180.0d0)*pie    
            siphase=dsin(ppp)
            vel=overQ/(1.0d0+overQ)*(siphase+argfac)*sifinc
            vel=vel*velamp+gamma
            delvel=0.0d0
            return
          endif
c
c   UPDATE October 21, 2002
c
c   Scale the fluxes by (separ*solarrad)**2
c
          sI=dsin(pie*bigI/180.0d0)
          bigbetar=pie*bigbeta/180.0d0
          cB=dcos(bigbetar)
          sB=dsin(bigbetar)

          solarrad=6.9598d10
          sscale=(separ*solarrad)**2
          do 10 ialf=1,Nalf
            if((isw13.gt.0).and.(istar.eq.0))then
              if((ialf.lt.ialfmin).or.(ialf.gt.ialfmax)) go to 10
            endif
            do 9 ibet=1,ibetlim(ialf)        !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              xxx=xcoords(iidx)
              yyy=ycoords(iidx)
              zzz=zcoords(iidx)
              xp=-xxx*siphase-yyy*cophase
              yp=xxx*cofinc*cophase-yyy*cofinc*siphase+zzz*sifinc
              v1=omega*sI*(xp*cB+yp*sB)
              v1=v1*flum(iidx)*sscale
              delvel=delvel+v1
 9          continue
 10       continue
c
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c
c   RVG BUG FIX   May 2, 2001
c
c   The following if-then statement is no longer needed.
c
c          if(phase.gt.180.0d0)delvel=-1.0d0*delvel

          siphase=dsin(phaser)
c
c   Bug fix, February 28, 2000
c
c          vel=velamp*(siphase*sifinc+delvel/flux)+gamma
c
c   RVG BUG ALERT   APRIL 23, 2001
c
c   Move this correction of delvel to the top, and change the last
c   part of the first vel equation.
c
          delvel=delvel/flux/rdint
          vel=overQ/(1.0d0+overQ)*(siphase+argfac)*sifinc+delvel
          vel=velamp*vel+gamma
c
          return
          end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine writepoints(ialphmax1,ibetmax1,Nthetamax,
     %           Nsky1,xsky1,ysky1,Nsky2,xsky2,
     &           ysky2,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,xhoriz2,yhoriz2,
     &           Nskydisk,xskydisk,yskydisk,zskydisk,
     &           Ntop2,xtop2horiz,ytop2horiz,
     &           Ndtop,dtopx,dtopy,Ndhoriz,dxhoriz,dyhoriz,
     %           Nskyedge,xskyedge,yskyedge,extension,separ,teff2,
     &           iidint,ialphmax2,ibetmax2,icounttime,Nsky3,xsky3,
     @           ysky3,Nhoriz3,xhoriz3,yhoriz3,isw30)
c
c   November 18, 1999
c
c   This routine will simply write the x,y sky coordinates of all of the
c   components for use in quick plotting routines.  The horizons will contain
c   potentially eclipsed points, but all other coordinates should contain
c   only visible points.
c
c
          implicit double precision(a-h,o-z)
c
          dimension xsky1(ialphmax1*ibetmax1*4),ysky1(ialphmax1*ibetmax1*4),
     &      xsky2(ialphmax2*ibetmax2*4),ysky2(ialphmax2*ibetmax2*4),
     %      xhoriz1(Nhoriz1),yhoriz1(Nhoriz1),xhoriz2(Nhoriz2),
     &      yhoriz2(Nhoriz2),xskydisk(Nskydisk),yskydisk(Nskydisk),
     &      zskydisk(Nskydisk),xsky3(Nsky3),ysky3(Nsky3),
     &      xtop2horiz(Ntop2),ytop2horiz(Ntop2),xhoriz3(Nhoriz3),
     &      dtopx(2*Nthetamax),dtopy(2*Nthetamax),yhoriz3(Nhoriz3),
     &      dxhoriz(Ndhoriz),dyhoriz(Ndhoriz),xskyedge(Nskyedge),
     &      yskyedge(Nskyedge)
c
          character*9 extension
c
          if(Nsky1.gt.0)then
            open(unit=40,file='star1coo.'//extension,status='unknown')
c
            do 10 i=1,Nsky1
              write(40,100)separ*xsky1(i),separ*ysky1(i)
 10         continue
            close(40)
c
            open(unit=40,file='star1horiz.'//extension,status='unknown')
c
            do 15 i=1,Nhoriz1
              write(40,100)separ*xhoriz1(i),separ*yhoriz1(i)
 15         continue
            close(40)
          endif             ! endif Nsky1
c
          if(Nsky3.gt.0)then
            open(unit=40,file='star3coo.'//extension,status='unknown')
c
            do 704 i=1,Nsky3
              write(40,100)separ*xsky3(i),separ*ysky3(i)
 704        continue
            close(40)
c
            open(unit=40,file='star3horiz.'//extension,status='unknown')
c
            do 75 i=1,Nhoriz3
              write(40,100)separ*xhoriz3(i),separ*yhoriz3(i)
 75         continue
            close(40)
          endif             ! endif Nsky1
c
          if(Nsky2.gt.0)then
            if(teff2.gt.0.0d0)then
              open(unit=40,file='star2coo.'//extension,status='unknown')
c
              do 20 i=1,Nsky2
                write(40,100)separ*xsky2(i),separ*ysky2(i)
 20           continue
              close(40)
c
              open(unit=40,file='star2horiz.'//extension,status=
     @             'unknown')
c
              do 30 i=1,Nhoriz2
                write(40,100)separ*xhoriz2(i),separ*yhoriz2(i)
 30           continue
              close(40)
c
              if(iidint.ge.1)then
                open(unit=40,file='star2tophor.'//extension,status=
     @            'unknown')
c
                do 40 i=1,Ntop2
                  write(40,100)separ*xtop2horiz(i),separ*ytop2horiz(i)
 40             continue
                close(40)
              endif         ! endif iidint > 0
            endif         ! endif teff2 > 0
          endif         ! endif Nsky2 > 0
c
c          write(*,*)'iidint writepoints = ',iidint,Nskydisk

          if(iidint.gt.0)then
            if(Nskydisk.gt.0)then
              open(unit=40,file='diskcoo.'//extension,status='unknown')
c
              do 50 i=1,Nskydisk
                write(40,101)separ*xskydisk(i),separ*yskydisk(i),
     @            zskydisk(i)
 50           continue
              close(40)
            endif
c
            if(Nskyedge.gt.0)then
              open(unit=40,file='diskedge.'//extension,status='unknown')
c
              do 60 i=1,Nskyedge
                write(40,100)separ*xskyedge(i),separ*yskyedge(i)
 60           continue
              close(40)
            endif
c
            if(Ndtop.gt.0)then
              open(unit=40,file='disktophor.'//extension,status=
     @          'unknown')
c
              do 70 i=1,Ndtop
                write(40,100)separ*dtopx(i),separ*dtopy(i)
 70           continue
              close(40)
            endif
c
            if(Ndhoriz.gt.0)then
              open(unit=40,file='diskhoriz.'//extension,status='unknown')
c
              do 80 i=1,Ndhoriz
                write(40,100)separ*dxhoriz(i),separ*dyhoriz(i)
 80           continue
              close(40)
            endif
c
          endif
c
 100      format(2(f15.9,5x))
 101      format(3(f15.9,5x))
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&
c
c   November 19, 1999
c
c   This routine was taken from Numerical Recipes, second edition.
c
c
      SUBROUTINE LOCATE(XX,N,X,J)
c
c   Taken from Numerical Recipes.
c
          implicit double precision(a-h,o-z)

      DIMENSION XX(N)
      JL=0
      JU=N+1
10    IF(JU-JL.GT.1)THEN
        JM=(JU+JL)/2
        IF((XX(N).GT.XX(1)).EQV.(X.GT.XX(JM)))THEN
          JL=JM
        ELSE
          JU=JM
        ENDIF
      GO TO 10
      ENDIF
      J=JL
      RETURN
      END
c
c  &&&&&&&&&&&&&&
c
          subroutine computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
     @      atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @      atmint6,atmint7,atmint8,outinty,icnU,
     @      icnB,icnV,icnR,icnI,icnJ,icnH,icnK,itguess,dwavex,
     @      dwavey,ilaw,iatm,istar)
c
c   This routine will return values of the specific intensity for the
c   8 filters based on the input values of Tin, gin, and rmuin.
c
c   UPDATE SEPTEMBER 11, 2009
c
c   Modify this routine to use a parameterized limb darkening law when
c   iatm=2.  When iatm=2, compute the intensity at mu=1, then use
c   the limb darkening law to find I(mu).
c
          implicit double precision(a-h,o-z)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8),tempgh(400),
     &       tempgl(1000),ghinty(400,8),yscratch(400),tscratch(2),glinty(400,8),
     &       tinty(2,8),y2scratch(2),ingh(400),ingl(400),gnew(2)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
          dimension dwavex(8,3),dwavey(8,3)
c
c          call locate(atmT,Nlines,Tin,indexT)
c
c    UPDATE October 23, 2009
c
c     If iatm=2, then we are using a combination of model atmospheres
c     and a limb darkening law.  The model atmosphere intensity for 
c     mu=1 will be found, and then a limb darkening law will be
c     used to find the intensity at other values of mu.
c
c     First, we need to save the input value of mu
c
          rsavemu=1.0d0
          if(iatm.ge.2)rsavemu=rmuin 
c
c
          call hunt(atmT,Nlines,Tin,itguess)
c
          gnew(1)=0.0d0
          gnew(2)=0.0d0
          indexT=itguess
          tscratch(1)=atmT(indexT+1)
c
c   Now search the Tvalues equal to atmT(indexT+1) and find the array
c   of gravities.
c
          Nhigh=0
          ingh(1)=1
          ingl(1)=1
          do 1 i=0,Nlines-(indexT+1)
            if(atmT(indexT+1+i).eq.atmT(indexT+1))then
              Nhigh=Nhigh+1
              tempgh(Nhigh)=atmg(indexT+1+i)
              ingh(Nhigh)=indexT+1+i
            else
              go to 5
            endif
 1       continue
c
5       call locate(tempgh,Nhigh,gin,indexgh)
c
c   Here is the case when the input log(g) value is in between
c   two tabulated log(g) values:
c
         if((indexgh.lt.Nhigh).and.(indexgh.gt.0))then
           gnew(1)=tempgh(indexgh)
           gnew(2)=tempgh(indexgh+1)
         endif 
c
c   If the input log(g) is larger than the largest tabulated log(g), then
c   wing it:  the polint routine will attempt to extrapolate.  This
c   is not too bad if the input log(g) is not too much larger than the
c   largest entry.
c
         if((indexgh.eq.Nhigh).and.(Nhigh.gt.1))then
           gnew(1)=tempgh(Nhigh-1)
           gnew(2)=tempgh(Nhigh)
         endif 
c
c   Same, but for an input log(g) value smaller than the smallest table
c   entry for that temperature:
c
         if(indexgh.eq.0)then
           gnew(1)=tempgh(1)
           gnew(2)=tempgh(2)
           indexgh=1               !UPDATE June 14, 2003
         endif 
c
c   Get the intensities for the gravities corresponding to indexgh
c   and indexgh+1.  The index numbers for these entries in the table
c   are ingh(indexgh) and ingh(indexgh+1).
c
c         write(*,*)Tin,gin,ingh(indexgh),rmuin,imuguess
c
         if(ilaw.gt.10)then
            do i=1,8
             dwavex(i,2)=dwavex(i,1)
             dwavey(i,2)=dwavey(i,1)
            enddo
         endif

         if(iatm.ge.2)rmuin=1.0d0
         call indexinty(ingh(indexgh),maxlines,maxmu,atmmu,atmint1,
     @     atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,
     &     Nmu,rmuin,outinty,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK)
         do 9 j=1,8
           ghinty(1,j)=outinty(j)
 9       continue
c
c          write(*,69)Tin,gin,rmuin,outinty(2)
c
         if(iatm.ge.2)rmuin=1.0d0
         call indexinty(ingh(indexgh+1),maxlines,maxmu,atmmu,atmint1,
     @      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,Nmu,
     @      rmuin,outinty,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK)
         do 10 ij=1,8
           ghinty(2,ij)=outinty(ij)
 10      continue
c
c          write(*,69)Tin,gin,rmuin,outinty(2)
c
c          m=2
          do 20 i=1,8
            if ((i.eq.1).and.(icnU.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.2).and.(icnB.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.3).and.(icnV.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.4).and.(icnR.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.5).and.(icnI.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.6).and.(icnJ.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.7).and.(icnH.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if ((i.eq.8).and.(icnK.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            do 19 j=1,2
              yscratch(j)=ghinty(j,i)
 19         continue
            diff=dabs(gnew(1)-gnew(2))
            qqq=0.0d0
            if(diff.gt.1.0d-5)then
c
c              call polint(gnew,yscratch,m,gin,qqq,dy)
c
              qqq=((gnew(2)-gin)*yscratch(1)+(gin-gnew(1))*yscratch(2))
     @             /(gnew(2)-gnew(1))

              outinty(i)=qqq
              tinty(1,i)=qqq
            else
              outinty(i)=yscratch(1)
              tinty(1,i)=yscratch(1)
            endif
 20       continue
c
c   Now search the Tvalues equal to atmT(indexT+1) and find the gravities.
c
          tscratch(2)=atmT(indexT)
c
          Nlow=0
          do 1000 i=0,indexT-1
            if(atmT(indexT-i).eq.atmT(indexT))then
              Nlow=Nlow+1
              tempgl(Nlow)=atmg(indexT-i)
              ingl(Nlow)=indexT-i
            else
              go to 1500
            endif
 1000     continue
 1500     call locate(tempgl,Nlow,gin,indexgl)
c
c
c   Here is the case when the input log(g) value is in between
c   two tabulated log(g) values:
c
         if((indexgl.lt.Nlow).and.(indexgl.gt.0))then
           gnew(1)=tempgl(indexgl)
           gnew(2)=tempgl(indexgl+1)
         endif 
c
c   If the input log(g) is larger than the largest tabulated log(g), then
c   wing it:  the polint routine will attempt to extrapolate.  This
c   is not too bad if the input log(g) is not too much larger than the
c   largest entry.
c
         if(indexgl.eq.Nlow)then
           gnew(1)=tempgl(Nlow-1)
           gnew(2)=tempgl(Nlow)
         endif 
c
c   Same, but for an input log(g) value smaller than the smallest table
c   entry for that temperature:
c
         if(indexgl.eq.0)then
           gnew(1)=tempgl(1)
           gnew(2)=tempgl(2)
           indexgl=1
         endif 
c
         if(iatm.ge.2)rmuin=1.0d0
         call indexinty(ingl(indexgl),maxlines,maxmu,atmmu,atmint1,
     @     atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,Nmu,
     @     rmuin,outinty,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK)
          do 90 j=1,8
            glinty(1,j)=outinty(j)
 90       continue
c
c          write(*,69)Tin,gin,rmuin,outinty(2)
c
         if(iatm.ge.2)rmuin=1.0d0
         call indexinty(ingl(indexgl+1),maxlines,maxmu,atmmu,atmint1,
     @      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,Nmu,
     @      rmuin,outinty,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK)
         do 91 j=1,8
            glinty(2,j)=outinty(j)
 91      continue
c
c          write(*,69)Tin,gin,rmuin,outinty(2)
c
         do 200 i=1,8
           if((i.eq.1).and.(icnU.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if((i.eq.2).and.(icnB.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.3).and.(icnV.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.4).and.(icnR.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.5).and.(icnI.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.6).and.(icnJ.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.7).and.(icnH.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           if ((i.eq.8).and.(icnK.eq.430))then
             outinty(i)=1.0d0
             go to 200
           endif
           do 190 j=1,2
             yscratch(j)=glinty(j,i)
 190       continue
           diff=dabs(gnew(1)-gnew(2))
           if(diff.gt.1.0d-5)then
c
c             call polint(gnew,yscratch,m,gin,qqq,dy)
c
             qqq=((gnew(2)-gin)*yscratch(1)+(gin-gnew(1))*yscratch(2))
     @            /(gnew(2)-gnew(1))
             outinty(i)=qqq
             tinty(2,i)=qqq
           else
             outinty(i)=yscratch(1)
             tinty(2,i)=yscratch(1)
           endif
 200     continue
c
c   Finally, take the final pass and interpolate between T
c
          do 300 i=1,8
            if ((i.eq.1).and.(icnU.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.2).and.(icnB.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.3).and.(icnV.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.4).and.(icnR.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.5).and.(icnI.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.6).and.(icnJ.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.7).and.(icnH.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            if ((i.eq.8).and.(icnK.eq.430))then
              outinty(i)=1.0d0
              go to 300
            endif
            do 290 j=1,2
              y2scratch(j)=tinty(j,i)
 290        continue
            if(tscratch(1).ne.tscratch(2))then
c
c              call polint(tscratch,y2scratch,m,Tin,qqq,dy)
c
              qqq=((tscratch(2)-Tin)*y2scratch(1)+(Tin-tscratch(1))
     @             *y2scratch(2))/(tscratch(2)-tscratch(1))

              outinty(i)=qqq
            else
              outinty(i)=y2scratch(1)
            endif
 300      continue
c
c   UPDATE October 23, 2009
c
c   If iatm=2, we are using a limb darkening law to find the specific
c   intensity at values of mu different than 1.0.  Apply the limb
c   darkening correction here, based on ilaw and the user supplied
c   coefficients.
c
          if(iatm.ge.2)then
            do 400 i=1,8
              fx=dwavex(i,istar)
              fy=dwavey(i,istar)
c
c   December 15, 2013:  add triangular sampling
c
              if((ilaw.eq.5).or.(ilaw.eq.15))then
                savefx=fx
                savefy=fy
                fx=2.0d0*dsqrt(savefx)*savefy
                fy=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
              endif
              dark=(1.0d0-fx+fx*rsavemu)
              if(ilaw.eq.2)dark=dark-fy*dabs(rsavemu)*dlog(dabs(rsavemu))
              if(ilaw.eq.3)dark=dark-fy*(1.0d0-dsqrt(dabs(rsavemu)))
              if(ilaw.eq.4)dark=dark-fy*(1.0d0-dabs(rsavemu))**2
              if(ilaw.eq.5)dark=dark-fy*(1.0d0-dabs(rsavemu))**2
              if(ilaw.eq.12)dark=dark-fy*dabs(rsavemu)*dlog(dabs(rsavemu))
              if(ilaw.eq.13)dark=dark-fy*(1.0d0-dsqrt(dabs(rsavemu)))
              if(ilaw.eq.14)dark=dark-fy*(1.0d0-dabs(rsavemu))**2
              if(ilaw.eq.15)dark=dark-fy*(1.0d0-dabs(rsavemu))**2
              outinty(i)=outinty(i)*dark
400         continue
            rmuin=rsavemu
          endif
          return
          end
c
c   &&&&&&&&&&&&&&&&&
c
          subroutine indexinty(index,maxlines,maxmu,atmmu,
     &        atmint1,atmint2,atmint3,atmint4,atmint5,
     @        atmint6,atmint7,atmint8,Nmu,rmuin,
     %        outinty,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK)
c
c   November 25, 1999
c
c   This subroutine will read the return values of the intensity at the
c   angle rmuin for model index in the table.
c
c
          implicit double precision(a-h,o-z)

          dimension atmmu(maxlines,maxmu),Nmu(maxlines)
          dimension xmu(400),outinty(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
c   This if-then clause seems to be needed...
c
          if(index.gt.maxlines)index=maxlines
          if((index.le.0))then
            do 1 i=1,8
              outinty(i)=0.0d0
 1          continue
            return
          endif
c
c   Copy the mu values to a one dimensional array
c
          k=8
c          iset=0
          do 10 i=1,Nmu(index)
            xmu(i)=atmmu(index,i)
 10       continue
c             
          N=Nmu(index)
c
          call locate(xmu,N,rmuin,muindex)
          m=2
          k=min(max(muindex-(m-1)/2,1),N+1-m)
          if(k.ge.N)k=N-1
          if(k.lt.1)k=1
c          write(*,*)'k= ',k,m
          do 20 i=1,8
            if((i.eq.1).and.(icnU.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.2).and.(icnB.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.3).and.(icnV.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.4).and.(icnR.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.5).and.(icnI.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.6).and.(icnJ.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.7).and.(icnH.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif
            if((i.eq.8).and.(icnK.eq.430))then
              outinty(i)=1.0d0
              go to 20
            endif

            if(i.eq.1)then
              qqq=((xmu(k+1)-rmuin)*atmint1(index,k)+
     &               (rmuin-xmu(k))*atmint1(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.2)then
              qqq=((xmu(k+1)-rmuin)*atmint2(index,k)+
     &               (rmuin-xmu(k))*atmint2(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.3)then
              qqq=((xmu(k+1)-rmuin)*atmint3(index,k)+
     &               (rmuin-xmu(k))*atmint3(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.4)then
              qqq=((xmu(k+1)-rmuin)*atmint4(index,k)+
     &               (rmuin-xmu(k))*atmint4(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.5)then
              qqq=((xmu(k+1)-rmuin)*atmint5(index,k)+
     &               (rmuin-xmu(k))*atmint5(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.6)then
              qqq=((xmu(k+1)-rmuin)*atmint6(index,k)+
     &               (rmuin-xmu(k))*atmint6(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.7)then
              qqq=((xmu(k+1)-rmuin)*atmint7(index,k)+
     &               (rmuin-xmu(k))*atmint7(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif
            if(i.eq.8)then
              qqq=((xmu(k+1)-rmuin)*atmint8(index,k)+
     &               (rmuin-xmu(k))*atmint8(index,k+1))/
     $               (xmu(k+1)-xmu(k))
              outinty(i)=dabs(qqq)
            endif

c           if(outinty(i).lt.0.0d0)outinty(i)=0.0d0
 20       continue
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&
c
          subroutine loadtable(maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &       atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,
     &       Tmax,Tmin,gmax,gmin)
c
c   November 25, 1999
c
c   This routine will read the file with the model atmosphere data.  The
c   name is assumed to be 'ELC.atm', the the form is assumed to be the
c   following:
c
c   Teff   g
c   N_mu
c   mu1    intyU intyB intyV intyR intyI intyJ intyH intyK
c   mu2    intyU intyB intyV intyR intyI intyJ intyH intyK
c   ...
c
c
c   UPDATE January 9, 2009
c
c   make the variable atmint two dimensional, and have 8 copies called
c   atmint1, atmint2, ...
c
c
          implicit double precision(a-h,o-z)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)

          character*40 blank
c
c   UPDATE June 14, 2002
c
c   Declare the variable bell to be character*1
c
          character*1 bell
c
          ios=0
          open(unit=19,file='ELC.atm',status='old',err=999,iostat=ios)
c
c   Read the header(s).
c
          nskip=0
          do 5 i=1,100
            read(19,6)blank
            if(blank(1:2).eq.'#'.or.blank(1:2).eq.'!'.or.
     @        blank(1:2).eq.'%')nskip=nskip+1
 5        continue
 6        format(a40)
c
          rewind(19)
c
          if(nskip.le.0)go to 8
          do 7 i=1,Nskip
            read(19,6)blank
 7        continue
c
c   Attempt to read in the intensity values.
c
 8        Tmax=-1000.0d0
          Tmin=10000000.0d00
          gmax=-10000.0d0
          gmin=11111.0d0
          do 10 i=1,maxlines
            read(19,*,end=15)atmT(i),atmg(i)
            read(19,*,end=15)Nmu(i)
c
            if(atmT(i).gt.Tmax)Tmax=atmT(i)
            if(atmT(i).lt.Tmin)Tmin=atmT(i)
            if(atmg(i).gt.gmax)gmax=atmg(i)
            if(atmg(i).lt.gmin)gmin=atmg(i)
            do 9 j=1,Nmu(i)
c              read(19,*,end=15)atmmu(i,j),(atmint(i,j,k),k=1,8)
              read(19,*,end=15)atmmu(i,j),atmint1(i,j),atmint2(i,j),
     $          atmint3(i,j),atmint4(i,j),atmint5(i,j),atmint6(i,j),
     &          atmint7(i,j),atmint8(i,j)

c
c   Add this line to check for repeated mu values.  If there 
c   is a repeat, then add 0.0001 (February 9, 2000).
c
              if(j.gt.1)then
                if(atmmu(i,j).eq.atmmu(i,j-1))then
c                atmmu(i,j)=atmmu(i,j)+0.0001d0
                  atmmu(i,j-1)=atmmu(i,j-1)-0.00005
                endif
              endif
 9          continue
 10       continue
 15       close(19)
c
          Nlines=i-1
c
 999      if(ios.ne.0)then
            bell=char(7)
            write(*,100)bell
          endif
c
 100      format(a1,'Error:  I can''t find the file ''ELC.atm''!')
c

          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
      SUBROUTINE POLINT(XA,YA,N,X,Y,DY)
c
c   Taken from Numerical Recipes.
c
          implicit double precision(a-h,o-z)
c
      PARAMETER (NMAX=10) 
      DIMENSION XA(N),YA(N),C(NMAX),D(NMAX)
      NS=1
      DIF=DABS(X-XA(1))
      DO 11 I=1,N 
        DIFT=DABS(X-XA(I))
        IF (DIFT.LT.DIF) THEN
          NS=I
          DIF=DIFT
        ENDIF
        C(I)=YA(I)
        D(I)=YA(I)
11    CONTINUE
      Y=YA(NS)
      NS=NS-1
      DO 13 M=1,N-1
        DO 12 I=1,N-M
          HO=XA(I)-X
          HP=XA(I+M)-X
          W=C(I+1)-D(I)
          DEN=HO-HP
          IF(DEN.EQ.0.0d0)then
             write(*,*)'pause in polint ',den,x,xa(i),ya(i)
          endif
          DEN=W/DEN
          D(I)=HP*DEN
          C(I)=HO*DEN
12      CONTINUE
        IF (2*NS.LT.N-M)THEN
          DY=C(NS+1)
        ELSE
          DY=D(NS)
          NS=NS-1
        ENDIF
        Y=Y+DY
13    CONTINUE
      RETURN
      END
c
c  &&&&&&&&&&&&&&&&&
c
          subroutine getATMflux(ialphmax,ibetmax,Nalf,ibetlim,visib,
     @      projarray,temp,surf,garray,rinty,flum,maxlines,maxmu,Nlines,
     &      atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @      atmint6,atmint7,atmint8,gscale,fluxU,fluxB,fluxV,fluxR,
     @      fluxI,fluxJ,fluxH,fluxK,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,
     @      icnK,iRVfilt,delphi,delphiedge,iedgestar,iedgehor,separ,
     @      mmdx,MonteCarlo,dwavex,dwavey,ilaw,iatm,istar,darkint)
c
c  November 30, 1999
c
c  This routine will return fluxes computed from model atmospheres.
c  The flum  and rinty arrays will contain the intensities for the V band.
c  The rinty array contains the specific intensities, while the
c  flum array contains the intensities weighted by the area and the surf
c  vectors.
c
c  The projarray contains the cosine mu terms for each element.  The visib
c  array contains the cosine mu terms for each element, except if the point
c  is eclipsed in which case the visib=0.
c 
c  The parameter gscale is used to convert the gravities in program units
c  into cgs units.  This number is G*M/(a*a).
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
c   by (separ*solarrad)**2
c
c   
c   UPDATE JULY 4, 2004
c
c   Add the variable MonteCarlo to the argument list.  If MonteCarlo < 10,
c   then proceed as before.  If Monte Carlo > 10, then the fractional
c   pixels were computed in getvisib via Monte Carlo integration.  In
c   that case, we can skip some steps below.
c
c   UPDATE SEPTEMBER 11, 2009
c
c   Add the ability to use a parameterized limb darkening law to this
c   routine.  computeinty is modified so that when iatm=2, the flux
c   at mu=1 is found, then I(mu)=I_0*ld_law
c

          implicit double precision(a-h,o-z)

          parameter(pie=3.141592653589793d0)
c
c   Set these to the value of ialphmax,ibetmax
c
          integer tempalf,tempbet
          parameter(tempalf=3000,tempbet=3000,itab=tempalf*tempbet)

          dimension visib(ialphmax*ibetmax),ibetlim(ialphmax),
     $        surf(ialphmax*ibetmax),garray(ialphmax*ibetmax),
     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     $        delphi(ialphmax*ibetmax),delphiedge(ialphmax*ibetmax),
     $        iedgestar(ialphmax*ibetmax),iedgehor(ialphmax*ibetmax),
     &        mmdx(ialphmax,ibetmax)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8),
     @       corr1(8),corr2(8),saveflum(itab,8),darkint(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
          dimension dwavex(8,3),dwavey(8,3)
c
c  
c
          if(tempalf.lt.ialphmax)then
            write(*,*)'dimension error in getATMflux'
            write(*,*)'tempalf = ',tempalf,'  ialphmax = ',ialphmax
            stop
          endif
          if(tempbet.lt.ibetmax)then
            write(*,*)'dimension error in getATMflux'
            write(*,*)'tempbet = ',tempbet,'  ibetmax = ',ibetmax
            stop
          endif
c
          fluxU=0.0d0
          fluxB=0.0d0
          fluxV=0.0d0
          fluxR=0.0d0
          fluxI=0.0d0
          fluxJ=0.0d0
          fluxH=0.0d0
          fluxK=0.0d0
          corr1(1)=0.0d0
          corr1(2)=0.0d0
          corr1(3)=0.0d0
          corr1(4)=0.0d0
          corr1(5)=0.0d0
          corr1(6)=0.0d0
          corr1(7)=0.0d0
          corr1(8)=0.0d0
          corr2(1)=0.0d0
          corr2(2)=0.0d0
          corr2(3)=0.0d0
          corr2(4)=0.0d0
          corr2(5)=0.0d0
          corr2(6)=0.0d0
          corr2(7)=0.0d0
          corr2(8)=0.0d0
c
c   Initialize the flum matrix.
c
          do 2 ialf=1,nalf
            do 1 ibet=1,ibetlim(ialf)       !4*Nbet
c              iidx=(ialf-1)*4*Nbet+ibet
              iidx=mmdx(ialf,ibet)
              flum(iidx)=0.0d0
              rinty(iidx)=0.0d0
              saveflum(iidx,1)=0.0d0
              saveflum(iidx,2)=0.0d0
              saveflum(iidx,3)=0.0d0
              saveflum(iidx,4)=0.0d0
              saveflum(iidx,5)=0.0d0
              saveflum(iidx,6)=0.0d0
              saveflum(iidx,7)=0.0d0
              saveflum(iidx,8)=0.0d0
 1          continue
 2        continue
c
c          Nalf2=Nalf/2
c
c   Find the rough place in the atmosphere table.
c
          Tin=temp(1)
          call locate(atmT,Nlines,Tin,indexT)
          itguess=indexT
c
c   Loop for fractional pixels near the edge.
c
c
c   UPDATE JULY 4, 2004
c
c   if MonteCarlo > 10, we can skip this loop.
c
          if(MonteCarlo.lt.10)then
            do 4 ialf=1,nalf
              do 3 ibet=1,ibetlim(ialf)
c                iidx=(ialf-1)*ibetlim(ialf)+ibet
c                iidx=kount(ialphmax,ialf,ibetlim)+ibet
                iidx=mmdx(ialf,ibet)
                if((iedgehor(iidx).eq.-10).or.(iedgehor(iidx).gt.
     @               5).or.(iedgestar(iidx).eq.-10).
     $               or.(iedgestar(iidx).gt.5).or.(delphi(iidx).
     $               gt.-10.0d0))then
c
                  Tin=temp(iidx)
                  gin=dlog10(gscale*garray(iidx))
                  rmuin=dabs(projarray(iidx))
c                  write(*,*)gin,istar
c  
                  call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
     &             atmT,atmg,atmmu,Nmu,
     &             atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     &             atmint7,atmint8,outinty,
     %             icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,itguess,
     &             dwavex,dwavey,ilaw,iatm,istar)
c
                  do 88 k=1,8
                    saveflum(iidx,k)=outinty(k)*surf(iidx)*
     @                 dabs(projarray(iidx))
 88               continue
                endif
 3            continue
 4          continue
          endif
c
          DO 10 ialf=1,nalf
            DO 9 ibet = 1,ibetlim(ialf)      !4*nbet
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              iidx=mmdx(ialf,ibet)
              corr1(1)=0.0d0
              corr1(2)=0.0d0
              corr1(3)=0.0d0
              corr1(4)=0.0d0
              corr1(5)=0.0d0
              corr1(6)=0.0d0
              corr1(7)=0.0d0
              corr1(8)=0.0d0
              corr2(1)=0.0d0
              corr2(2)=0.0d0
              corr2(3)=0.0d0
              corr2(4)=0.0d0
              corr2(5)=0.0d0
              corr2(6)=0.0d0
              corr2(7)=0.0d0
              corr2(8)=0.0d0
              dphi=pie/dble(ibetlim(ialf))
              if(projarray(iidx).le.0.0d0)go to 9
              Tin=temp(iidx)
              gin=dlog10(gscale*garray(iidx))
              rmuin=projarray(iidx)
c
c                write(*,*)ialf,ibet,Tin,gin
c
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @          atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @          atmint6,atmint7,atmint8,outinty,icnU,icnB,icnV,icnR,
     @          icnI,icnJ,icnH,icnK,itguess,dwavex,dwavey,ilaw,
     @          iatm,istar)
c
              rinty(iidx)=outinty(iRVfilt) ! save intensities for plotting
c              write(33,*)rinty(iidx),projarray(iidx),ialf,ibet
c
              do 8 k=1,8
                saveflum(iidx,k)=
     @             outinty(k)*surf(iidx)*projarray(iidx)
                outinty(k)=outinty(k)*surf(iidx)*visib(iidx)
 8            continue
c
c   Check for fractional pixels near the horizon of the star in front,
c   in the beta direction (along constant latitude rows).
c
c
c   UPDATE JULY 4, 2004
c
c   If MonteCarlo > 10, we can skip this step since the fractional
c   pixel corrections were done in getvisib.
c
              if(MonteCarlo.gt.10)then
                corr1(1)=0.0d0
                corr1(2)=0.0d0
                corr1(3)=0.0d0
                corr1(4)=0.0d0
                corr1(5)=0.0d0
                corr1(6)=0.0d0
                corr1(7)=0.0d0
                corr1(8)=0.0d0
                go to 867
              endif
c
              if(delphi(iidx).ge.-10.0d0)then
                frac=0.5d0*(dabs(delphi(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  corr1(1)=frac*saveflum(iidx,1)
                  corr1(2)=frac*saveflum(iidx,2)
                  corr1(3)=frac*saveflum(iidx,3)
                  corr1(4)=frac*saveflum(iidx,4)
                  corr1(5)=frac*saveflum(iidx,5)
                  corr1(6)=frac*saveflum(iidx,6)
                  corr1(7)=frac*saveflum(iidx,7)
                  corr1(8)=frac*saveflum(iidx,8)
                else
                  if(iedgehor(iidx).eq.10)then
                    if(ibet.lt.ibetlim(ialf))then  
                      izz=ialf
                      jzz=ibet+1
c                      iidx=(izz-1)*ibetlim(ialf)+jzz
c                      iidx=kount(ialphmax,izz,ibetlim)+jzz
                      iidx=mmdx(izz,jzz)
                      corr1(1)=frac*saveflum(iidx,1)
                      corr1(2)=frac*saveflum(iidx,2)
                      corr1(3)=frac*saveflum(iidx,3)
                      corr1(4)=frac*saveflum(iidx,4)
                      corr1(5)=frac*saveflum(iidx,5)
                      corr1(6)=frac*saveflum(iidx,6)
                      corr1(7)=frac*saveflum(iidx,7)
                      corr1(8)=frac*saveflum(iidx,8)
                    else
                      izz=ialf
                      jzz=1
c                      iidx=(izz-1)*ibetlim(ialf)+jzz
c                      iidx=kount(ialphmax,izz,ibetlim)+jzz
                      iidx=mmdx(izz,jzz)
                      corr1(1)=frac*saveflum(iidx,1)
                      corr1(2)=frac*saveflum(iidx,2)
                      corr1(3)=frac*saveflum(iidx,3)
                      corr1(4)=frac*saveflum(iidx,4)
                      corr1(5)=frac*saveflum(iidx,5)
                      corr1(6)=frac*saveflum(iidx,6)
                      corr1(7)=frac*saveflum(iidx,7)
                      corr1(8)=frac*saveflum(iidx,8)
                    endif
                  endif

                  izz=ialf
                  jzz=ibet
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
c                  iidx=kount(ialphmax,izz,ibetlim)+jzz
                  iidx=mmdx(izz,jzz)
                  if(iedgehor(iidx).eq.20)then
                    if(ibet.gt.1)then    
                      izz=ialf
                      jzz=ibet-1
c                      iidx=(izz-1)*ibetlim(ialf)+jzz
c                      iidx=kount(ialphmax,izz,ibetlim)+jzz
                      iidx=mmdx(izz,jzz)
                      corr1(1)=frac*saveflum(iidx,1)
                      corr1(2)=frac*saveflum(iidx,2)
                      corr1(3)=frac*saveflum(iidx,3)
                      corr1(4)=frac*saveflum(iidx,4)
                      corr1(5)=frac*saveflum(iidx,5)
                      corr1(6)=frac*saveflum(iidx,6)
                      corr1(7)=frac*saveflum(iidx,7)
                      corr1(8)=frac*saveflum(iidx,8)
                    else
                      izz=ialf
                      jzz=ibetlim(ialf)
c                      iidx=(izz-1)*ibetlim(ialf)+jzz
c                      iidx=kount(ialphmax,izz,ibetlim)+jzz
                      iidx=mmdx(izz,jzz)
                      corr1(1)=frac*saveflum(iidx,1) 
                      corr1(2)=frac*saveflum(iidx,2) 
                      corr1(3)=frac*saveflum(iidx,3) 
                      corr1(4)=frac*saveflum(iidx,4) 
                      corr1(5)=frac*saveflum(iidx,5) 
                      corr1(6)=frac*saveflum(iidx,6) 
                      corr1(7)=frac*saveflum(iidx,7) 
                      corr1(8)=frac*saveflum(iidx,8) 
                    endif
                  endif
                endif
              endif
c
c 6969         format(a10,e16.7,2x,2(i2,2x),f9.6)
c
              izz=ialf
              jzz=ibet
c              iidx=(izz-1)*ibetlim(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim)+jzz
               iidx=mmdx(izz,jzz)
              if(iedgestar(iidx).eq.10)then
                frac=0.5d0*(dabs(delphiedge(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  izz=ialf
                  jzz=ibet
c                  iidx=(izz-1)*ibetlim(ialf)+jzz
                  iidx=mmdx(izz,jzz)
                  corr2(1)=frac*saveflum(iidx,1)
                  corr2(2)=frac*saveflum(iidx,2)
                  corr2(3)=frac*saveflum(iidx,3)
                  corr2(4)=frac*saveflum(iidx,4)
                  corr2(5)=frac*saveflum(iidx,5)
                  corr2(6)=frac*saveflum(iidx,6)
                  corr2(7)=frac*saveflum(iidx,7)
                  corr2(8)=frac*saveflum(iidx,8)
                else
                  if(ibet.lt.ibetlim(ialf))then
                    izz=ialf
                    jzz=ibet+1
c                    iidx=(izz-1)*ibetlim(ialf)+jzz
c                    iidx=kount(ialphmax,izz,ibetlim)+jzz
                    iidx=mmdx(izz,jzz)
                    corr2(1)=frac*saveflum(iidx,1)
                    corr2(2)=frac*saveflum(iidx,2)
                    corr2(3)=frac*saveflum(iidx,3)
                    corr2(4)=frac*saveflum(iidx,4)
                    corr2(5)=frac*saveflum(iidx,5)
                    corr2(6)=frac*saveflum(iidx,6)
                    corr2(7)=frac*saveflum(iidx,7)
                    corr2(8)=frac*saveflum(iidx,8)
                  else
                    izz=ialf
                    jzz=1
c                    iidx=(izz-1)*ibetlim(ialf)+jzz
c                    iidx=kount(ialphmax,izz,ibetlim)+jzz
                    iidx=mmdx(izz,jzz)
                    corr2(1)=frac*saveflum(iidx,1)
                    corr2(2)=frac*saveflum(iidx,2)
                    corr2(3)=frac*saveflum(iidx,3)
                    corr2(4)=frac*saveflum(iidx,4)
                    corr2(5)=frac*saveflum(iidx,5)
                    corr2(6)=frac*saveflum(iidx,6)
                    corr2(7)=frac*saveflum(iidx,7)
                    corr2(8)=frac*saveflum(iidx,8)
                  endif
                endif
              endif
c
              izz=ialf
              jzz=ibet
c              iidx=(izz-1)*ibetlim(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim)+jzz
              iidx=mmdx(izz,jzz)
              if(iedgestar(iidx).eq.20)then
                frac=0.5d0*(dabs(delphiedge(iidx))-dphi)/dphi
                if(frac.lt.0.0d0)then
                  corr2(1)=frac*saveflum(iidx,1)
                  corr2(2)=frac*saveflum(iidx,2)
                  corr2(3)=frac*saveflum(iidx,3)
                  corr2(4)=frac*saveflum(iidx,4)
                  corr2(5)=frac*saveflum(iidx,5)
                  corr2(6)=frac*saveflum(iidx,6)
                  corr2(7)=frac*saveflum(iidx,7)
                  corr2(8)=frac*saveflum(iidx,8)
                else
                  if(ibet.gt.1)then
                    izz=ialf
                    jzz=ibet-1
c                    iidx=(izz-1)*ibetlim(ialf)+jzz
c                    iidx=kount(ialphmax,izz,ibetlim)+jzz
                    iidx=mmdx(izz,jzz)
                    corr2(1)=frac*saveflum(iidx,1)
                    corr2(2)=frac*saveflum(iidx,2)
                    corr2(3)=frac*saveflum(iidx,3)
                    corr2(4)=frac*saveflum(iidx,4)
                    corr2(5)=frac*saveflum(iidx,5)
                    corr2(6)=frac*saveflum(iidx,6)
                    corr2(7)=frac*saveflum(iidx,7)
                    corr2(8)=frac*saveflum(iidx,8)
                  else
                    izz=ialf
                    jzz=ibetlim(ialf)
c                    iidx=(izz-1)*ibetlim(ialf)+jzz
c                    iidx=kount(ialphmax,izz,ibetlim)+jzz
                    iidx=mmdx(izz,jzz)
                    corr2(1)=frac*saveflum(iidx,1)
                    corr2(2)=frac*saveflum(iidx,2)
                    corr2(3)=frac*saveflum(iidx,3)
                    corr2(4)=frac*saveflum(iidx,4)
                    corr2(5)=frac*saveflum(iidx,5)
                    corr2(6)=frac*saveflum(iidx,6)
                    corr2(7)=frac*saveflum(iidx,7)
                    corr2(8)=frac*saveflum(iidx,8)
                  endif
                endif
              endif
c
 867          fluxU=fluxU+outinty(1)+corr1(1) !+corr2(1)
              fluxB=fluxB+outinty(2)+corr1(2)!+corr2(2)
              fluxV=fluxV+outinty(3)+corr1(3)!+corr2(3)
              fluxR=fluxR+outinty(4)+corr1(4)!+corr2(4)
              fluxI=fluxI+outinty(5)+corr1(5)!+corr2(5)
              fluxJ=fluxJ+outinty(6)+corr1(6)!+corr2(6)
              fluxH=fluxH+outinty(7)+corr1(7)!+corr2(7)
              fluxK=fluxK+outinty(8)+corr1(8)!+corr2(8)
              izz=ialf
              jzz=ibet
c              iidx=(izz-1)*ibetlim(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim)+jzz
               iidx=mmdx(izz,jzz)
              flum(iidx)=outinty(iRVfilt)+corr1(iRVfilt) !+corr2(iRVfilt) 
 9          continue
 10       continue
c
c          if(darkint(1).ne.0.0d0)fluxU=pie*fluxU/darkint(1)
c          if(darkint(2).ne.0.0d0)fluxB=pie*fluxB/darkint(2)
c          if(darkint(3).ne.0.0d0)fluxV=pie*fluxV/darkint(3)
c          if(darkint(4).ne.0.0d0)fluxR=pie*fluxR/darkint(4)
c          if(darkint(5).ne.0.0d0)fluxI=pie*fluxI/darkint(5)
c          if(darkint(6).ne.0.0d0)fluxJ=pie*fluxJ/darkint(6)
c          if(darkint(7).ne.0.0d0)fluxH=pie*fluxH/darkint(7)
c          if(darkint(8).ne.0.0d0)fluxK=pie*fluxK/darkint(8)
c
c  UPDATE April 3, 2002
c
c  Scale the fluxes.
c
          solarrad=6.9598d10
          fluxU=fluxU*(separ*solarrad)**2
          fluxB=fluxB*(separ*solarrad)**2
          fluxV=fluxV*(separ*solarrad)**2
          fluxR=fluxR*(separ*solarrad)**2
          fluxI=fluxI*(separ*solarrad)**2
          fluxJ=fluxJ*(separ*solarrad)**2
          fluxH=fluxH*(separ*solarrad)**2
          fluxK=fluxK*(separ*solarrad)**2
c
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine parms(iunit,Teff2,Q,finc,separ,period,reff1,reff2,
     @        vrot1,vrot2,gscale1,gscale2,omega1,
     $        omega2,bdist,ecc)
c
c   November 30, 1999
c
c   This routine will compute the component masses, radii, etc. based
c   on the mass ratio, inclination, orbital separation, and orbital period.
c   Set iunit=1 to print to the output file, or 0 to print to screen.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
           
           fincr=finc*pie/180.0d0        ! radians
           ppp=period*24.0d0                            ! period in hours
c           coef=3.518847d10
c           coef3=4.35713636d31
           sifinc=dsin(fincr)
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
c
           rM1=total_mass/(1.0d0+Q)
           rM2=Q*rM1
c
c   Use the value of GM_sun found from the solar system.
c
           gmsun=1.32712440018d20  !mks units
c
           solarrad=6.9598d8
           p=period*86400.0d0
           rM1=(separ*solarrad)**(3)*4.0d0*pie*pie
           rM1=rM1/(gmsun*p*p*(1.0d0+Q))
           rM2=Q*rM1

           R1=reff1*separ
           if(Teff2.gt.0.0d0)then
             R2=reff2*separ
           else
             R2=0.00d0
           endif
c
           gsun=2.739910d4
           gpole1=gsun*rM1/(R1*R1)  
           if(Teff2.gt.0.0d0)then
             gpole2=gsun*rM2/(R2*R2)  
           else
             gpole2=1.0d0
           endif
c
           gscale1=27397.726d0*rM1/(separ*separ*bdist*bdist)
           gscale2=27397.726d0*rM2/(separ*separ*bdist*bdist)

           gscale1=27397.726d0*rM1/(separ*separ)
           gscale2=27397.726d0*rM2/(separ*separ)
c
           fact=solarrad*2.0d0*pie/86400.0d0/1.0d3  !50.613093d0
c
           vrot1=fact*R1/period*sifinc
           vrot2=fact*R2/period*sifinc
c
c   UPDATE MARCH 4, 2005
c
c   Was (separ/(1.0d0+Q))*bdist)
c
           a2=(separ/(1.0d0+Q))
c
c   UPDATE September 12, 2001
c 
c   Bug fix, change a1=(separ-a2)*bdist  to  a1=separ(1.0d0-bdist/(1.0d0+Q))
c

c           aa1=separ*(1.0d0-bdist/(1.0d0+Q))
           a1=separ-a2
c
c   RVG BUG ALERT  April 20, 2001
c
c   Change efact below
c
c           efact=1.0d0/dsqrt(1.0-ecc*ecc)
c
           efact=1.0d0/dsqrt(1.0-ecc*ecc)
           velK1=fact*a1/period*sifinc*efact
           velK2=fact*a2/period*sifinc*efact
c
c
c   NEW BUG August 10, 2001
c
c   Add a correction factor to the rotational velocities in the
c   case of eccentric orbits.
c
           hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))


           if(iunit.ge.1)write(2,100)rM1,R1,dlog10(gpole1),rM2,R2,
     $        dlog10(gpole2),
     $        period,a1,a2,separ,velK1,velK2,vrot1,vrot2,
     &        omega1*vrot1*hutfac,omega2*vrot2*hutfac
           if(iunit.le.0)write(*,100)rM1,R1,dlog10(gpole1),rM2,R2,
     $        dlog10(gpole2),
     $        period,a1,a2,separ,velK1,velK2,vrot1,vrot2,
     &        omega1*vrot1*hutfac,omega2*vrot2*hutfac

c
 100       format(/'M1 = ',f7.4,' M_sun;',1x,'R1 = ',f8.4,' R_sun;',1x,
     %          'log(g1) = ',f8.6,' cgs', 
     &        /'M2 = ',f7.4,' M_sun;',1x,'R2 = ',f8.4,' R_sun;',1x,
     %          'log(g2) = ',f8.6,' cgs', 
     %        /'P = ',f11.6,' d;',1x,'a1 = ',f7.3,' R_sun;',1x,
     $        'a2 = ',f8.3,' R_sun;',1x,'a = ',f8.3,' R_sun',
     %        /'K1 = ',f8.3,' km/sec;',1x,'K2 = ',f8.3,' km/sec;',1x,
     &        /'V1_rot*sin(i) = ',f8.3,' km/s;',1x,'V2_rot*sin(i) = ',
     %        f8.3,' km/s',/'V1_rot*sin(i) = ',f8.3,' km/s;',
     %        1x,'V2_rot*sin(i) = ',
     %        f8.3,' km/s (scaled by omegas)')
c
           return
           end
c
c
c  %%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine wmagmod(icount,xmod,ymod,fileout,isw7,zeropoint)
c
c  November 10, 1999
c
c  This routine will open the output file and record the given model
c  with flux in linear units.  The phases will be scaled to go from 0.0 to
c  1.0, and an extra phase will be added.
c
          implicit double precision(a-h,o-z)
c
          dimension xmod(icount),ymod(icount)
c
c   UPDATE June 17, 2002
c
c   Change the declaration of fileout to character*(*)
c
          character*(*) fileout
c
          open(unit=20,file=fileout,status='unknown')
c
c   UPDATE April 3, 2002
c
c   Add a variable called zeropoint, instead of 40.0d0
c
c          zeropoint=75.0d0
          err=0.005d0
          do 10 i=1,icount
            write(20,100)xmod(i),-2.5d0*dlog10(ymod(i))+zeropoint,err
 10       continue
c
          if(isw7.ge.2)then
            close(20)
            return
          endif
          do 20 i=1,icount
            write(20,100)xmod(i)+1.0d0,-2.5d0*dlog10(ymod(i))+zeropoint,err
 20       continue
c
          close(20)
c
 100      format(f16.10,3x,f13.9,3x,f9.6)
c
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine  getdiskATMflux(Nrmax,Nthetamax,Nradius,Ntheta,
     @      diskproj,edgeproj,dvisib,evisib,dtemp,tedge,drad,dinty,
     @      einty,stepr,stepz,maxlines,maxmu,Nlines,atmT,atmg,atmmu,Nmu,
     &      atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,
     @      atmint8,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,dfluxU,
     @      dfluxB,dfluxV,dfluxR,dfluxI,dfluxJ,dfluxH,dfluxK,iRVfilt,
     @      separ,dwavex,dwavey,ilaw,iatm,Tmin)
c
c
c  November 30, 1999
c
c  This routine will return fluxes computed from model atmospheres.
c  The flum  and rinty arrays will contain the intensities for the V band.
c  The rinty array contains the specific intensities, while the
c  flum array contains the intensities weighted by the area and the surf
c  vectors.
c
c  The projarray contains the cosine mu terms for each element.  The visib
c  array contains the cosine mu terms for each element, except if the point
c  is eclipsed in which case the visib=0.
c 
c
c   UPDATE April 3, 2002
c
c   Add separ to the argument list of getBBflux, getATMflux,
c   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
c   by (separ*solarrad)**2
c
c   UPDATE SEPTEMBER 11, 2009
c
c   If iatm=2, then use a parameterized limb darkening law to 
c   compute the flux at angles less than mu=1.
c
          implicit double precision(a-h,o-z)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)

          dimension diskproj(Nrmax*Nthetamax),edgeproj(Nthetamax*11),
     &      dvisib(Nrmax*Nthetamax),evisib(Nthetamax*11),
     &      dinty(Nrmax*Nthetamax),einty(Nthetamax*11),
     &      dtemp(Nrmax*Nthetamax),drad(Nrmax),
     &      tedge(Nthetamax*11)
c
          dimension dwavex(8,3),dwavey(8,3)

          parameter(pie=3.14159265358979323d0)
c
          isaveatm=iatm
          if(iatm.ge.2)iatm=1
          dfluxU=0.0d0
          dfluxB=0.0d0
          dfluxV=0.0d0
          dfluxR=0.0d0
          dfluxI=0.0d0
          dfluxJ=0.0d0
          dfluxH=0.0d0
          dfluxK=0.0d0
c
          steptheta=360.0d0/dble(ntheta)
          deg2rad=pie/180.0d0
c
c   Find the rough place in the table
c
          Tin=dtemp(1)
          call locate(atmT,Nlines,Tin,indexT)
          itguess=indexT

          DO 10 ir=1,Nradius
            DO 9 ithet=1,Ntheta
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(ir-1)*Ntheta+ithet
c
              if(diskproj(iidx).le.0.0d0)go to 9
              Tin=dtemp(iidx)
              if(Tin.lt.Tmin)Tin=Tmin+1.0
              if((Tin.lt.6800.0d0))then
                gin=3.9d0   !UPDATE AUG-04-2008  was 4.9
              else
                gin=3.9d0   !UPDATE AUG-04-2008  was 4.9
              endif
              rmuin=diskproj(iidx)
c
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
     &           atmT,atmg,atmmu,Nmu,
     &           atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     &           atmint7,atmint8,outinty,
     %           icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,itguess,
     &           dwavex,dwavey,ilaw,iatm,1)
c
              dinty(iidx)=outinty(iRVfilt)  ! save intensities for plotting
c
              if(dtemp(iidx).lt.Tmin)then
                scale=(dtemp(iidx)/Tmin)**4
              else
                scale=1.0d0
              endif
c
c   April 18, 2001  RGV BUG ALERT
c
c   Convert the steptheta into radians!
c
              do 8 k=1,8
                outinty(k)=outinty(k)*((1.0d0/8.0d0)*drad(ir)**3)*
     &                 dvisib(iidx)*stepr*steptheta*scale*deg2rad
 8            continue
c
              dfluxU=dfluxU+outinty(1)
              dfluxB=dfluxB+outinty(2)
              dfluxV=dfluxV+outinty(3)
              dfluxR=dfluxR+outinty(4)
              dfluxI=dfluxI+outinty(5)
              dfluxJ=dfluxJ+outinty(6)
              dfluxH=dfluxH+outinty(7)
              dfluxK=dfluxK+outinty(8)
 9          continue
 10       continue
c
          do 20 ithet=1,Ntheta
            do 19 iz=1,11
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(iz-1)*Ntheta+ithet
c
              einty(iidx)=0.0d0
              if(edgeproj(iidx).lt.0.0)go to 19
              Tin=tedge(iidx)
              if(Tin.lt.Tmin)Tin=Tmin+1.0
              if((Tin.lt.6800.0d0))then
                gin=3.9d0               !UPDATE AUG-04-2008  was 4.9
              else
                gin=3.9d0               !UPDATE AUG-04-2008  was 4.9
              endif
              rmuin=edgeproj(iidx)
c
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @          atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @          atmint6,atmint7,atmint8,outinty,icnU,icnB,icnV,icnR,
     @          icnI,icnJ,icnH,icnK,itguess,dwavex,dwavey,ilaw,
     @          iatm,1)
c
              einty(iidx)=outinty(iRVfilt)  ! save intensities for plotting
c
              if(tedge(iidx).lt.Tmin)then
                scale=(tedge(iidx)/Tmin)**4
              else
                scale=1.0d0
              endif
c
c   April 18, 2001  RGV BUG ALERT
c
c   Convert the steptheta into radians!
c
              do 18 k=1,8
                outinty(k)=outinty(k)*
     %             evisib(iidx)*stepz*steptheta*scale*deg2rad
 18           continue
c
c   The upper rim points are in the face integration.  If iz=11, then don't
c   add to dflux.
c
              if(iz.lt.11)then          
                dfluxU=dfluxU+outinty(1)
                dfluxB=dfluxB+outinty(2)
                dfluxV=dfluxV+outinty(3)
                dfluxR=dfluxR+outinty(4)
                dfluxI=dfluxI+outinty(5)
                dfluxJ=dfluxJ+outinty(6)
                dfluxH=dfluxH+outinty(7)
                dfluxK=dfluxK+outinty(8)
              endif
 19         continue
 20       continue
c
c   UPDATE April 3, 2002
c
c   Scale the fluxes.
c
          solarrad=6.9598d10
          dfluxU=dfluxU*(separ*solarrad)**2
          dfluxB=dfluxB*(separ*solarrad)**2
          dfluxV=dfluxV*(separ*solarrad)**2
          dfluxR=dfluxR*(separ*solarrad)**2
          dfluxI=dfluxI*(separ*solarrad)**2
          dfluxJ=dfluxJ*(separ*solarrad)**2
          dfluxH=dfluxH*(separ*solarrad)**2
          dfluxK=dfluxK*(separ*solarrad)**2
c
          if(isaveatm.ge.2)iatm=isaveatm
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine thirdlight(iatm,t3,g3,SA3,third,maxlines,maxmu,
     @       Nlines,atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,
     @       atmint5,atmint6,atmint7,atmint8,icnU,
     @       icnB,icnV,icnR,icnI,icnJ,icnH,icnK,separ,dwavex,dwavey,
     @       ilaw,istar,reff)
c
c  January 7, 2000
c 
c  This subroutine will compute a 'third light' flux using the
c  model atmosphere table.  The user specifies the temperature,
c  gravity, and fractional surface area of the third star.  The
c  fractional surface area is given in terms of the ratio of the
c  surface area of star 3 to that of star 1.  Finally, the third light
c  that is added to the output light curves is given by
c
c  third(ifilt) = SA3*inty(ifilt)*2*pi*pi*SA1)
c
c  
c  December 19, 2000
c
c  Bug fix:  third(ifilt) = SA1*SA3*inty(ifilt,mu=1)/4.0
c
c  UPDATE April 2, 2002
c
c  Add separ to the argument list of thirdlight.  Then scale the fluxes
c  by (separ*solarrad)**2
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
          dimension third(8),summ(8)
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %      Nmu(maxlines),outinty(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
          dimension dwavex(8,3),dwavey(8,3)
c
c   Initialize
c
          do 10 i=1,8
            third(i)=0.0d0
            summ(i)=0.0d0
 10       continue
c
c   Check for negative values of the input parameters.  If
c   any are negative, then the third light option is turned off.
c
          if(t3.le.0.0d0)then
            write(2,100)
            return
          endif
c
          if(g3.le.0.0d0)then
            write(2,100)
            return
          endif
c
          if(SA3.le.0.0d0)then
            write(2,100)
            return
          endif
c
c
c   If the atmosphere option is not on, then set the third light
c   to zero.
c 
          if(iatm.le.0d0)then
            write(2,100)
            return
          endif
c
c   Now compute the third light.  Define a series of mu values
c   from 0.01 to 1.0 and integrate.
c
          Tin=t3
          gin=g3
          itguess=1
c
c   UPDATE JULY 16, 2011
c
c   Change the routine below to make the scaling
c   agree better.
c
          solarrad=6.9598d10
c
          hhh=0.01d0
          do 4 i=100,0,-1
            rmuin=dble(i)/100.0d0
            if(rmuin.gt.0.0d0)then
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @          atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @          atmint6,atmint7,atmint8,outinty,icnU,icnB,icnV,icnR,
     @          icnI,icnJ,icnH,icnK,itguess,dwavex,dwavey,ilaw,
     @          iatm,istar)
            else
              outinty(1)=0.0d0
              outinty(2)=0.0d0
              outinty(3)=0.0d0
              outinty(4)=0.0d0
              outinty(5)=0.0d0
              outinty(6)=0.0d0
              outinty(7)=0.0d0
              outinty(8)=0.0d0
            endif
c
            do 88 k=1,8
              if(i.eq.100)then
                summ(k)=summ(k)+1.0d0*hhh*outinty(k)*rmuin
              else
                summ(k)=summ(k)+2.0d0*hhh*outinty(k)*rmuin
              endif
              third(k)=summ(k)*pie*reff*reff
              third(k)=SA3*third(k)*(separ*solarrad)**2
 88         continue
 4        continue

 100      format(/'Info:  There is no third light')
c
          return
          end
c
c
c
c  *************************************************************************
c
          subroutine hiddiskgrid(Nrmax,Nthetamax,Nradius,Ntheta,
     @     diskproj,edgeproj,dtemp,tedge,dx,dy,dz,
     @     xxedge,yyedge,zzedge,dinty,einty,phase,finc,Q,
     $     Nhoriz,xhoriz,yhoriz,extension,separation,flux,bdist,
     @     tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @     tertOmega,icounttime)
c
c   January 14, 2000
c
c   This routine will output files used for various external plotting
c   packages.  This routine is for the disk.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xhoriz(Nhoriz),yhoriz(Nhoriz)
          dimension diskproj(Nrmax*Nthetamax),edgeproj(Nthetamax*11),
     &      dinty(Nrmax*Nthetamax),einty(Nthetamax*11),
     &      dtemp(Nrmax*Nthetamax),dy(Nrmax*Nthetamax),
     &      tedge(Nthetamax*11),dx(Nrmax*Nthetamax),dz(Nrmax*Nthetamax),
     %      xxedge(Nthetamax*11),yyedge(Nthetamax*11),
     &      zzedge(Nthetamax*11)
c
c
          character*9 extension
c
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @        axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
c          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          open(unit=40,file='diskinty.'//extension,status='unknown')
c
c   Check to see if star 1 is in front.  
c
          istar=1
          infront=0
          if((istar.eq.1).and.((phase.ge.0.0d0).
     @        and.(phase.lt.90.0d0)))infront=1
          if((istar.eq.1).and.((phase.ge.270.0d0).
     @        and.(phase.le.360.0d0)))infront=1
c          if((istar.eq.2).and.((phase.ge.0.0d0).
c     @        and.(phase.lt.90.0d0)))infront=1
c          if((istar.eq.2).and.((phase.ge.270.0d0).
c     $        and.(phase.le.360.0d0)))infront=1
c
c   Find the sky coordinates of the center of mass of the disk.  This
c   will be recorded as the first line of the diskinty.???.?? file.
c
          xx=1.0d0
          yy=0.0d0
          zz=0.0d0
          xp=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)    
          yp=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
          xp=xp+xxoff
          yp=yp+yyoff
c
c          if(phase.gt.180.0d0)then
c            yp=-yp
c          endif
c
          write(40,68)xp*separation,yp*separation,flux
c
          DO 501 ir=1,Nradius-1
            DO 502 ithet=1,Ntheta
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(ir-1)*Ntheta+ithet
c
              iv1=1
              IF (diskproj(iidx).le.0.0d0) go to 502 ! is the surface 
              xx=dx(iidx)                   ! element visible?
              yy=dy(iidx)
              zz=dz(iidx)
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
              yp=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
c
c              if(phase.gt.180.0d0)then
c                yp=-yp
c              endif
c
              if(infront.eq.1)then    
                iyes=-100
                iv1=1
                call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                if((iyes.eq.100))iv1=0    ! point could be visible
              endif                       ! but is eclipsed
c       
c   Record the x,y,z coordinates of the nearby points.  These points
c   will be used for area filling
c
              xx1=xp
              yy1=yp
c
              if(ithet.gt.1)then
                izz=ir
                jzz=ithet-1
                iidx=(izz-1)*Ntheta+jzz
                xx=dx(iidx)
                yy=dy(iidx)
                zz=dz(iidx)
              else
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                xx=dx(iidx)
                yy=dy(iidx)
                zz=dz(iidx)
              endif
              xx2=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy2=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx2=xx2+xxoff
              yy2=yy2+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy2=-yy2
c              endif
c
              if(ithet.gt.1)then
                izz=ir+1
                jzz=ithet-1
                iidx=(izz-1)*Ntheta+jzz
                xx=dx(iidx)
                yy=dy(iidx)
                zz=dz(iidx)
              else
                izz=ir+1
                jzz=Ntheta
                iidx=(izz-1)*Ntheta+jzz
                xx=dx(iidx)
                yy=dy(iidx)
                zz=dz(iidx)
              endif
              xx3=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy3=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx3=xx3+xxoff
              yy3=yy3+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy3=-yy3
c              endif
c
              izz=ir+1
              jzz=ithet
              iidx=(izz-1)*Ntheta+jzz
              xx=dx(iidx)                   
              yy=dy(iidx)
              zz=dz(iidx)
              xx4=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy4=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx4=xx4+xxoff
              yy4=yy4+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy4=-yy4
c              endif
c
c   Check the corners for eclipsed points.
c
              iv2=1
              iv3=1
              iv4=1
              if(infront.eq.1)then
                iyes=-100
                iv2=1
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx2,yy2,iyes,icut)
                if((iyes.eq.100))iv2=0      
                iv3=1
                iyes=-100
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx3,yy3,iyes,icut)
                if(iyes.eq.100)iv3=0      
                iv4=1
                iyes=-100
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx4,yy4,iyes,icut)
                if(iyes.eq.100)iv4=0      
              endif
c
c   There are 13 possibilities for which corners were hidden.  Do each
c   case separately.
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=5
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=4
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c 
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ir
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)dinty(iidx),ncorner,diskproj(iidx),
     %            dtemp(iidx),
     %            ir,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
 99           continue
502         CONTINUE
501       CONTINUE               
c
          DO 5001 iz=1,10
            DO 5002 ithet=1,Ntheta
              iidx=(iz-1)*Ntheta+ithet
              iv1=1
              IF (edgeproj(iidx).le.0.0d0) go to 5002 ! is the surface 
              xx=xxedge(iidx)                   ! element visible?
              yy=yyedge(iidx)
              zz=zzedge(iidx)
              xp=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)   
              yp=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
c              
c              if(phase.gt.180.0d0)then
c                yp=-yp
c              endif
c
              if(infront.eq.1)then    
                iyes=-100
                iv1=1
                call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                if((iyes.eq.100))iv1=0    ! point could be visible
              endif                       ! but is eclipsed
c       
c   Record the x,y,z coordinates of the nearby points.  These points
c   will be used for area filling
c
              xx1=xp
              yy1=yp
c
              if(ithet.gt.1)then
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                xx=xxedge(iidx)
                yy=yyedge(iidx)
                zz=zzedge(iidx)
              else
                izz=iz
                jzz=Ntheta
                iidx=(izz-1)*Ntheta+jzz
                xx=xxedge(iidx)
                yy=yyedge(iidx)
                zz=zzedge(iidx)
              endif
              xx2=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy2=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx2=xx2+xxoff
              yy2=yy2+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy2=-yy2
c              endif
c
              if(ithet.gt.1)then
                izz=iz+1
                jzz=ithet-1
                iidx=(izz-1)*Ntheta+jzz
                xx=xxedge(iidx)
                yy=yyedge(iidx)
                zz=zzedge(iidx)
              else
                izz=iz+1
                jzz=Ntheta
                iidx=(izz-1)*Ntheta+jzz
                xx=xxedge(iidx)
                yy=yyedge(iidx)
                zz=zzedge(iidx)
              endif
              xx3=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy3=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx3=xx3+xxoff
              yy3=yy3+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy3=-yy3
c              endif
c
              izz=iz+1
              jzz=ithet
              iidx=(izz-1)*Ntheta+jzz
              xx=xxedge(iidx)                   
              yy=yyedge(iidx)
              zz=zzedge(iidx)
              xx4=diskxtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              yy4=diskytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xx4=xx4+xxoff
              yy4=yy4+yyoff
c
c              if(phase.gt.180.0d0)then
c                yy4=-yy4
c              endif
c
c   Check the corners for eclipsed points.
c
              iv2=1
              iv3=1
              iv4=1
              if(infront.eq.1)then
                iyes=-100
                iv2=1
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx2,yy2,iyes,icut)
                if((iyes.eq.100))iv2=0      
                iv3=1
                iyes=-100
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx3,yy3,iyes,icut)
                if(iyes.eq.100)iv3=0      
                iv4=1
                iyes=-100
                call insidecircle(Nhoriz,xhoriz,yhoriz,xx4,yy4,iyes,icut)
                if(iyes.eq.100)iv4=0      
              endif
c
c   There are 13 possibilities for which corners were hidden.  Do each
c   case separately.
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 999
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 999
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=5
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 999
              endif
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 999
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 999
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.1))then
                ncorner=4
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 999
              endif
c 
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.1).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.1))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 999
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0).and.(iv4.eq.0))then  
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=iz
                jzz=ithet
                iidx=(izz-1)*Ntheta+jzz
                write(40,69)einty(iidx),ncorner,edgeproj(iidx),
     %            tedge(iidx),
     %            iz,ithet,iv1,iv2,iv3,iv4,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 999
              endif
c
 999          continue
 5002       continue
 5001     continue
 68       format(2(f9.4,3x),e16.9)
 69       format(e16.9,3x,i3,4x,f6.4,2x,e12.6,1x,1x,
     %       2(i3,1x),6x,4(i1,1x)/,10(f9.4,1x))
c
          close(40)
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine hunt(xx,n,x,jlo)
c
c   This routine was taken from Numerical Recipes, second edition.
c
          implicit double precision(a-h,o-z)

          integer jlo,n
c          real*8  x,xx(n)
          dimension xx(n)
          integer inc,jhi,jm
          logical*2 ascnd
          ascnd=xx(n).gt.xx(1)
          if(jlo.le.0.or.jlo.gt.n)then
            jlo=0
            jhi=n+1
            go to 3
          endif
          inc=1
          if((x.ge.xx(jlo)).eqv.ascnd)then
 1          jhi=jlo+inc
            if(jhi.gt.n)then
              jhi=n+1
            else if((x.ge.xx(jhi)).eqv.ascnd)then
              jlo=jhi
              inc=inc+inc
              go to 1
            endif
          else
            jhi=jlo
 2          jlo=jhi-inc
            if(jlo.lt.1)then
              jlo=0
            else if((x.lt.xx(jlo)).eqv.ascnd)then
              jhi=jlo
              inc=inc+inc
              go to 2
            endif
          endif
 3        if(jhi-jlo.eq.1)return
          jm=(jhi+jlo)/2
          if((x.gt.xx(jm)).eqv.ascnd)then
            jlo=jm
          else
            jhi=jm
          endif
          go to 3
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine recordparm1(fill1,fill2,omega1,
     $       omega2,Q,finc,Teff1,Teff2,betarim,
     $       rinner,router,tdisk,xi,
     %       rLx,separ,gamma,t3,g3,SA3,density)
c
c    Will record the parameters used in the file ELC.parm, and will also
c    record interesting computed parameters.
c
          implicit double precision(a-h,o-z)
c
          open(unit=3,file='ELC.parm',status='unknown')
c
          write(3,1004)fill1
          write(3,1005)fill2
          write(3,1006)omega1
          write(3,1007)omega2
          write(3,1009)Q
          write(3,1010)finc
          write(3,1011)Teff1
          write(3,1012)Teff2
          write(3,1015)betarim
          write(3,1016)rinner
          write(3,1017)router
          write(3,1018)tdisk
          write(3,2018)xi
          write(3,1021)rLx
          write(3,1025)separ
          write(3,4025)gamma
          write(3,5000)t3
          write(3,5001)g3
          write(3,5002)SA3
          write(3,5003)density
c
c 1000     format(i5,20x,'Nalph1')
 1004     format(f15.13,10x,'fill1')
 1005     format(f15.13,10x,'fill2')
 1006     format(f15.9,10x,'omega1')
 1007     format(f15.9,10x,'omega2')
 1009     format(f18.15,7x,'Q')
 1010     format(f15.12,10x,'finc')
 1011     format(f11.4,14x,'Teff1')
 1012     format(f11.4,14x,'Teff2')
 1015     format(f13.10,12x,'betarim')
 1016     format(f13.10,12x,'rinner')
 1017     format(f13.10,12x,'router')
 1018     format(f12.3,13x,'tdisk')
 2018     format(f12.5,13x,'xi')
 1021     format(f15.10,10x,'log10(Lx)')
 1025     format(f23.10,2x,'separ')
 4025     format(f12.6,13x,'gamma velocity')
 5000     format(f15.4,10x,'t3')
 5001     format(f15.5,10x,'g3')
 5002     format(f17.8,8x,'SA3')
 5003     format(f17.6,8x,'density in g/cc')
c
          return
          end
c
c  &&&#$%&&&&&$&&&&@&&()&&&&&&&)(&&&&&&&&
c
          subroutine parms1(Teff2,Q,finc,separ,period,reff1,reff2,
     $        gpole1,gpole2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,
     $        obsparm,bdist,ecc,argper,teff1)
c
c   April 26, 2000
c
c   This routine will compute the component masses, radii, etc. based
c   on the mass ratio, inclination, orbital separation, and orbital period.
c   These values will be written to ELC.parm (unit=3)
c
c
c   July 24, 2000
c
c   Add the array obsparm to the argument list.  This contains the 
c   computed physical parameters of stars 1 and 2
c
c   UPDATE September 21, 2008
c
c   Add K_1 and K_2 to the list
c
c   obsparm(1) = mass of star 1      (solar)
c   obsparm(2) = radius of star 1    (solar)
c   obsparm(3) = gravity of star 1   (log cgs)
c   obsparm(4) = V_rot*sin(i) star 1 (km/sec)
c   obsparm(5) = mass of star 2      (solar)
c   obsparm(6) = radius of star 2    (solar)
c   obsparm(7) = gravity of star 2   (log cgs)
c   obsparm(8) = V_rot*sin(i) star 2 (km/sec)
c   obsparm(9) = duration of X-ray eclipse (degrees)
c   obsparm(10) = K_1 (km/sec)
c   obsparm(11) = K_2 (km/sec)
c
c   UPDATE September 11, 2001
c
c   Change the dimemsion of obsparm to 9.  The X-ray eclipse duration
c   (in degrees) will be stored there
c
c   UPDATE September 21, 2008
c
c   Make the dimension of obsparm 11
c
c   UPDATE October 10, 2008
c
c   Add finc, Q, ecc, argper, teff1, teff2 to the list in obsparm
c 
c   UPDATE March 15, 2011
c
c   make the dimension of obsparm 18 (add sum of fractional radii)
c
          implicit double precision(a-h,o-z)
          dimension obsparm(19)
c
          parameter(pie=3.14159265358979323d0)
c
           fpsq=4.0d0*pie*pie
           fincr=finc*3.141592653589879d0/180.0d0        ! radians
           ppp=period*24.0d0               ! period in hours
c           coef=3.518847d10
c           coef3=4.35713636d31
           sifinc=dsin(fincr)
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
c
           gmsun=1.32712440018d20   !m^3/sec^2
           smet=separ*6.9598d8
           total_mass=smet*smet*smet*fpsq/(period*86400.0d0)**2/gmsun
           solarrad=6.9598d10
c
           rM1=total_mass/(1.0d0+Q)
           rM2=Q*rM1           
c
           R1=reff1*separ
           if(Teff2.gt.0.0d0)then
             R2=reff2*separ
           else
             R2=0.00d0
           endif
c
           gsun=2.739910d4
           gpole1=gsun*rM1/(R1*R1)  
           if(Teff2.gt.0.0d0)then
             gpole2=gsun*rM2/(R2*R2)  
           else
             gpole2=1.0d0
           endif
c
           gscale1=27397.726d0*rM1/(separ*separ*bdist*bdist)
           gscale2=27397.726d0*rM2/(separ*separ*bdist*bdist)
           gscale1=27397.726d0*rM1/(separ*separ)
           gscale2=27397.726d0*rM2/(separ*separ)
c
           fact=solarrad*2.0d0*pie/86400.0d0/1.0d5  !50.613093d0
           vrot1=fact*R1/period*sifinc
           vrot2=fact*R2/period*sifinc
c
c   UPDATE MARCH 4, 2005
c
c   change a2 and a1 below
c
           a2=separ/(1.0d0+Q)*bdist
c
c   UPDATE September 12, 2001
c 
c   Bug fix, change a1=(separ-a2)*bdist  to  a1=separ(1.0d0-bdist/(1.0d0+Q))
c

           a1=separ*(1.0d0-bdist/(1.0d0+Q))
c
           a2=separ/(1.0d0+Q)
           a1=separ-a2
           efact=1.0d0/dsqrt(1.0-ecc*ecc)
           velK1=fact*a1/period*sifinc*efact
           velK2=fact*a2/period*sifinc*efact
c
c           if(iunit.ge.1)write(2,100)rM1,R1,dlog10(gpole1),rM2,R2,
c     $        dlog10(gpole2),
c     $        period,a1,a2,separ,velK1,velK2,vrot1,vrot2,
c     &        omega1*vrot1,omega2*vrot2
c           if(iunit.le.0)write(*,100)rM1,R1,dlog10(gpole1),rM2,R2,
c     $        dlog10(gpole2),
c     $        period,a1,a2,separ,velK1,velK2,vrot1,vrot2,
c     &        omega1*vrot1,omega2*vrot2
c

c
c   NEW BUG August 10, 2001
c
c   Add a correction factor to the rotational velocities in the
c   case of eccentric orbits.
c
           hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))

           obsparm(1)=rM1
           obsparm(5)=rM2
           obsparm(2)=R1
           obsparm(6)=R2
           obsparm(3)=dlog10(gpole1)
           obsparm(7)=dlog10(gpole2)
           obsparm(4)=vrot1*omega1*hutfac
           obsparm(8)=vrot2*omega2*hutfac
c
c   UPDATE September 21, 2008
c
c   Add the K-velocities to obsparm
c
           obsparm(10)=velK1
           obsparm(11)=velK2
c
           obsparm(12)=finc
           obsparm(13)=Q
           obsparm(14)=ecc
           obsparm(15)=argper
           obsparm(16)=teff1
           obsparm(17)=teff2
c
c   UPDATE March 15, 2011
c
c   Add sum of fractional radii to index 18
c           
           obsparm(18)=(R1+R2)/separ
c
c
c   UPDATE September 11, 2001
c
c   initialize obsparm(9)
c
c           obsparm(9)=0.0d0
c
           write(3,1000)rM1
           write(3,2000)rM2
           write(3,1001)R1
           write(3,2001)R2
           write(3,1002)dlog10(gpole1)
           write(3,2002)dlog10(gpole2)
           write(3,1003)a1
           write(3,1004)a2
           write(3,1005)separ
           write(3,1006)velK1
           write(3,2006)velK2
           write(3,1007)vrot1
           write(3,2007)vrot2
           write(3,1008)vrot1*omega1*hutfac
           write(3,2008)vrot2*omega2*hutfac
c
 1000      format( f15.10,10x,'mass of star 1 in solar masses')
 2000      format( f15.10,10x,'mass of star 2 in solar masses')
 1001      format(f15.10,10x,'radius of star 1 in solar radii')
 2001      format(f15.10,10x,'radius of star 2 in solar radii')
 1002      format( f9.6,16x,'log(g) of star 1, cgs')
 2002      format( f9.6,16x,'log(g) of star 2, cgs')
 1003      format(f11.5, 14x,'a1 (solar radii)')
 1004      format(f11.5, 14x,'a2 (solar radii)')
 1005      format(f15.10, 10x,'a (solar radii)')
 1006      format( f15.10,10x,'K_1 (km/sec)')
 2006      format( f15.10,10x,'K_2 (km/sec)')
 1007      format( f9.4,16x,'V1_rot*sin(i) (km/sec)')
 2007      format( f9.4,16x,'V2_rot*sin(i) (km/sec)')
 1008      format( f9.4,16x,'V1_rot*sin(i), scaled by omega1 (km/sec)')
 2008      format( f9.4,16x,'V2_rot*sin(i), scaled by omega2 (km/sec)')
c
           close(3)
c
           return
           end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine copyinty(ialphmax1,ibetmax1,Nalph1,
     $              Nalph2,rinty1,saveinty1,rinty2,saveinty2,
     &            mmdx1,mmdx2,ibetlim1,ibetlim2,ialphmax2,ibetmax2)
c
c   May 1, 2000
c
c   This routine is needed to fix a bug in the output routine---the
c   incorrect intensities for the BB mode were being written.
c
          implicit double precision(a-h,o-z)
c
          dimension rinty1(ialphmax1*ibetmax1),
     $        rinty2(ialphmax2*ibetmax2),
     $        saveinty1(ialphmax1*ibetmax1),saveinty2(ialphmax2*ibetmax2)
          dimension mmdx1(ialphmax1,ibetmax1),mmdx2(ialphmax2,ibetmax2)
          dimension ibetlim1(ialphmax1),ibetlim2(ialphmax2)
c
          do 10 ialf=1,Nalph1
            do 9 ibet=1,ibetlim1(ialf)

c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*4*Nbet1+ibet
c
              iidx=mmdx1(ialf,ibet)
              saveinty1(iidx)=rinty1(iidx)
 9          continue
 10       continue
c
          do 20 ialf=1,Nalph2
            do 19 ibet=1,ibetlim2(ialf)
c              iidx=(ialf-1)*4*Nbet2+ibet
              iidx=mmdx2(ialf,ibet)
              saveinty2(iidx)=rinty2(iidx)
 19         continue
 20       continue
c
          return
          end
c
c    &&&&&&&******************%%%%%%%%%%%%%
c
          subroutine copydiskinty(Nrmax,Nthetamax,Nradius,
     %              Ntheta,dinty,savedinty,einty,saveeinty)
c
c
c
          implicit double precision(a-h,o-z)
c
          dimension dinty(Nrmax*Nthetamax),einty(Nthetamax*11),
     &      savedinty(Nrmax*Nthetamax),saveeinty(Nthetamax*11)
c
          do 10 ir=1,Nradius
            do 9 ithet=1,Ntheta
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(ir-1)*Ntheta+ithet
c
              savedinty(iidx)=dinty(iidx)
 9          continue
 10       continue
c
          do 20 ithet=1,Ntheta
            do 19 iz=1,11
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(iz-1)*Ntheta+ithet
c
              saveeinty(iidx)=einty(iidx)
 19         continue
 20       continue
c
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c  UPDATE March 22, 2002
c
c  Remove the variable coy from the argument list of spherepot.
c
c
          subroutine spherepot(Q,omega,cox,coz,r,psi,dpsidr,bdist,
     @        tidephi,itide,ecc,thetamis,phimis,coy)
c
c   May 3, 2000
c
c   This routine will return the value of the potential and its
c   derivative at r in the direction (cox,coy,coz)
c
          implicit double precision(a-h,o-z)
c
          dimension pn(0:100),pd(0:100)
          parameter(pie=3.141592653589793d0)
c
          hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
          omegah=omega*hutfac

          X=cox
          Y=coy
          Z=coz
          if((phimis.eq.0.0d0).and.(thetamis.eq.0.0d0))then
            term1=X*X
            term2=Y*Y
            term3=0.0d0
            term4=0.0d0
            term5=0.0d0
            term6=0.0d0
          else
            cpm=dcos(phimis)
            spm=dsin(phimis)
            stm=dsin(thetamis)
            s2pm=dsin(2.0d0*phimis)
            s2tm=dsin(2.0d0*thetamis)                   
            term1=X*X*(1.0d0-cpm*cpm*stm*stm)
            term2=Y*Y*(1.0d0-spm*spm*stm*stm)
            term3=Z*Z*stm*stm
            term4=-X*Y*stm*stm*s2pm
            term5=-X*Z*cpm*s2tm
            term6=-Y*Z*spm*s2tm
          endif
          if(itide.lt.2)then
            t1=(bdist*bdist-2.0d0*cox*r*bdist+r*r)
            t2=0.5d0*omegah*omegah*(1.0d0+Q)*(term1+term2+term3+term4
     @         +term5+term6)
            psi=1.0d0/r+Q*(1.0d0/dsqrt(t1)-cox*r/(bdist*bdist))+t2*r*r 
            dpsidr=-1.0d0/(r*r)+Q*((dsqrt(t1)**3)*(cox*bdist-r)
     %         -cox/(bdist*bdist))+2.0d0*r*t2
            return
          endif
c
          coy=coz
          tider=pie*tidephi/180.0d0
          psicos=cox*dcos(tider)+coy*dsin(tider)

          call lpn(itide,psicos,pn,pd)
c
          psi=1.0d0/(r)+Q
          dpsidr=-1.0d0/(r*r)
c

          do 10 ii=2,itide
            psi=psi-Q*(r**(ii))*pn(ii)
            dpsidr=dpsidr+dble(ii)*Q*(r**(ii-1))*pn(ii)
 10       continue
c
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine acchor(Q,psi0,omega,xvis,yvis,zvis,rvis,phivis,
     $              xhid,yhid,zhid,rhid,phihid,
     %              ax,ay,az,xacc,yacc,zacc,bdist,tidephi,itide,
     &              ecc,thetamis,phimis)
c
c  May 5, 2000
c
c  This subroutine will take two points along a latitude row, where the
c  first is visible and the second is hidden, and iterate to find a
c  more accurate horizon.  We can find coz, which is kept constant.  We
c  bisect on phi, and check the visibility at each iteration.  The
c  x,y,z coordinates of the horizon are returned as xacc,yacc,zacc.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
c          if(itide.lt.2)then
c            tider=0.0d0
c          else
c            tider=pie*tidephi/180.0d0
c          endif
          do 10 i=1,25
            cozvis=zvis/rvis
            cozhid=zhid/rhid
            coz=0.5d0*(cozvis+cozhid)
c            diff=100.0d0
            theta=dacos(coz)
            sithet=dsin(theta)
c
c   Find a new phi, which is the average of the two phi values.
c   Then given theta and phi, compute cox,coy,coz, etc.
c
            diffphi=dabs(phivis-phihid)
            if(diffphi.gt.1.0d0)then
              if(phivis.gt.2.0d0)phivis=phivis-2.0d0*pie
              if(phihid.gt.2.0d0)phihid=phihid-2.0d0*pie
            endif
c            diff=phivis-phihid
            phinew=0.5d0*(phivis+phihid)
            if(phinew.lt.0.0)phinew=phinew+2.0d0*pie
            rnew=0.5d0*(rvis+rhid)
            cox=dcos(phinew)*sithet
            coy=dsin(phinew)*sithet
c
            call rad(Q,omega,cox,coy,coz,psi0,rnew,x,y,z,1,bdist,
     $        tidephi,itide,ecc,thetamis,phimis)
c
c   UPDATE March 26, 2002
c
c   Remove psixx and istar (the 1) from the argument list of fastPOT.
c
c            call POTEN(Q,omega,x,y,z,psi1,
c     $                   psix1,psixx1,psiy1,psiz1,1,bdist,cox,coy,
c     &                   tidephi,itide,ecc,thetamis,phimis)
c
            call fastPOT(Q,omega,x,y,z,psi,psix,psiy,psiz,bdist,
     $         cox,coy,tidephi,itide,ecc,thetamis,phimis)
c
            gravity=DSQRT(PSIX**2+PSIY**2+PSIZ**2)
            GX = -PSIX/gravity
            GY = -PSIY/gravity
            GZ = -PSIZ/gravity
c
            proj=ax*gx+ay*gy+az*gz
            if(proj.gt.0.0d0)then
              xvis=x
              yvis=y
              zvis=z
              rvis=rnew
              phivis=phinew
            else
              xhid=x
              yhid=y
              zhid=z
              rhid=rnew
              phihid=phinew
            endif
c            diff=phivis-phihid
 10       continue
c          write(*,*)diff,proj
c
          xacc=xvis
          yacc=yvis
          zacc=zvis
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   UPDATE March 26, 2002
c
c   Remove psixx and istar from the argument list of fastPOT.
c
          SUBROUTINE fastPOT(Q,omega,x,y,z,psi,psix,psiy,psiz,bdist,
     @      cox,coy,tidephi,itide,ecc,thetamis,phimis)
c
c   May 6, 2000
c
c   This routine computes the potential and its derivatives.
c
          implicit double precision(a-h,o-z)
          dimension pn(0:100),pd(0:100)
          parameter(pie=3.141592653589793d0)
c
c   UPDATE January 24, 2011
c
c   Add in the Hut factor to Omega
c
          hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
          omegah=omega*hutfac
          if(itide.lt.2)then
            RST = DSQRT( X**2 + Y**2 + Z**2 )     
            RX = DSQRT((X-bdist)**2 + Y**2 + Z**2 ) 
            A = ((1.0d0+Q)/2.0d0) * OMEGAH**2
            RST3 = RST*RST*RST
            RX3 = RX*RX*RX
            if((thetamis.eq.0.0d0).and.(phimis.eq.0.0d0))then
              term1=X*X
              term2=Y*Y
              term3=0.0d0
              term4=0.0d0
              term5=0.0d0
              term6=0.0d0              
              cpm=1.0d0
              spm=0.0d0
              stm=0.0d0
              s2pm=0.0d0
              s2tm=0.0d0
            else
              cpm=dcos(phimis)
              spm=dsin(phimis)
              stm=dsin(thetamis)
              s2pm=dsin(2.0d0*phimis)
              s2tm=dsin(2.0d0*thetamis)                   
              term1=X*X*(1.0d0-cpm*cpm*stm*stm)
              term2=Y*Y*(1.0d0-spm*spm*stm*stm)
              term3=Z*Z*stm*stm
              term4=-X*Y*stm*stm*s2pm
              term5=-X*Z*cpm*s2tm
              term6=-Y*Z*spm*s2tm
            endif
            PSI = 1.0d0/RST + Q/RX - Q*X/bdist/bdist
     @        + A*(term1+term2+term3+term4+term5+term6) !potential page 45 of
                                                       !Avni's paper

            dterm1=2.0d0*X*(1.0d0-cpm*cpm*stm*stm)
            dterm2=-Y*stm*stm*s2pm
            dterm3=-Z*cpm*s2tm
            PSIX = -X/RST3 - Q*(X-bdist)/RX3 -Q/bdist/bdist 
     @           + A*(dterm1+dterm2+dterm3)
            
            dterm1=2.0d0*Y*(1.0d0-spm*spm*stm*stm)
            dterm2=-X*stm*stm*s2tm
            dterm3=-Z*spm*s2tm
            PSIY = -Y/RST3 - Q*Y/RX3   + A*(dterm1+dterm2+dterm3)
c
            dterm1=2.0d0*Z*stm*stm
            dterm2=-X*cpm*s2tm
            dterm3=-Y*spm*s2tm
            PSIZ = -Z/RST3 - Q*Z/RX3 +A*(dterm1+dterm2+dterm3)

c            PSIY = -Y/RST3 - Q*Y/RX3      +2.*A*Y        !partial deriv. wrt y
c            PSIZ = -Z/RST3 - Q*Z/RX3                     !partial deriv. wrt z
c            PSIX = -X/RST3 - Q*(X-bdist)/RX3 -Q/bdist/bdist 
c     $        + 2.0d0*A*X !partial deriv. wrt x
c
            RETURN
          endif
c
c
c
          tider=pie*tidephi/180.0d0
          psicos=cox*dcos(tider)+coy*dsin(tider)

c
          rr=x*x+y*y+z*z
          w1=(dsqrt(rr))**3
          w1=1.0d0/w1
c
          psi=1.0d0/dsqrt(rr)+Q
          psix=-x*w1
          psiy=-y*w1
          psiz=-z*w1

          call lpn(itide,psicos,pn,pd)
          do 10 ii=2,itide
            t1=-Q*rr**(0.5d0*dble(ii))*pn(ii)
            psi=psi+t1
            twx=dble(ii)*x*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
            twy=dble(ii)*y*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
            twz=dble(ii)*z*Q*rr**(0.5d0*dble(ii)-1.0d0)*pn(ii)
c
            psix=psix+twx
            psiy=psiy+twy
            psiz=psiz+twz
 10       continue
c
          return
          END
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
c   UPDATE March 26, 2002
c
c   Remove the variable separ from the argument list of accphi.
c
          subroutine accphi(Q,psi0,omega,phase,fincr,istar,xvis,yvis,
     @      zvis,rvis,phivis,xhid,yhid,zhid,rhid,phihid,Nhoriz,xhoriz,
     @      yhoriz,phiacc,bdist,tidephi,itide,ecc,thetamis,phimis,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega)
c
c  May 5, 2000
c
c  This subroutine will take two points along a latitude row, where the
c  first is visible and the second is hidden, and iterate to find the
c  phi value of the horizon crossing.
c
          implicit double precision(a-h,o-z)
c
          dimension xhoriz(Nhoriz),yhoriz(Nhoriz)
c
          parameter(pie=3.14159265358979323d0)
c
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c  Take care of the case where phi1 is slightly larger than zero and
c  phi2 is near 2*pi.
c
c          if(itide.lt.2)then
c            tider=0.0d0
c          else
c            tider=pie*tidephi/180.0d0
c          endif
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
          cozvis=zvis/rvis
          cozhid=zhid/rhid
          coz=0.5d0*(cozvis+cozhid)
          theta=dacos(coz)
          sithet=dsin(theta)
c
          do 10 i=1,20
c
c   Find a new phi, which is the average of the two phi values.
c   Then given theta and phi, compute cox,coy,coz, etc.
c

            diffphi=dabs(phivis-phihid)
            if(diffphi.gt.2.0d0)then
              if(phivis.gt.2.0d0)phivis=phivis-2.0d0*pie
              if(phihid.gt.2.0d0)phihid=phihid-2.0d0*pie
            endif
            phinew=0.5d0*(phivis+phihid)
            if(phinew.lt.0.0d0)phinew=phinew+2.0d0*pie
            rnew=0.5d0*(rvis+rhid)
            cox=dcos(phinew)*sithet
            coy=dsin(phinew)*sithet
c
            call rad(overQ,omega,cox,coy,coz,psi0,rnew,x,y,z,1,bdist,
     $       tidephi,itide,ecc,thetamis,phimis)
c
            xpnew=xtran(x,y,z,phase,fincr,Q,istar,bdist)
            ypnew=ytran(x,y,z,phase,fincr,Q,istar,bdist)
            xpnew=xpnew+xxoff
            ypnew=ypnew+yyoff
            iyes=-100
            call insidecircle(Nhoriz,xhoriz,yhoriz,xpnew,ypnew,iyes,
     @       icut)
c
            if(iyes.eq.100)then
              xhid=x
              yhid=y
              zhid=z
              rhid=rnew
              phihid=phinew
            else
              xvis=x
              yvis=y
              zvis=z
              rvis=rnew
              phivis=phinew
            endif
c            diff=phivis-phihid
 10       continue
c
          phiacc=phivis
c
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
c   UPDATE March 26, 2002
c
c   Comment out this routine, since it is not being used.
c
c          subroutine acctheta(Q,psi0,omega,phase,fincr,istar,
c     %              xvis,yvis,zvis,rvis,thetavis,
c     $              xhid,yhid,zhid,rhid,thetahid,Nhoriz,xhoriz,yhoriz,
c     %              thetaacc,separ,phivis,phihid,bdist)
cc
cc  May 12, 2000
cc
cc  This subroutine will take two points along a longitude row (constant ialf),
cc   where the
cc  first is visible and the second is hidden, and iterate to find the
cc  theta value of the horizon crossing.
cc
c          implicit double precision(a-h,o-z)
cc
c          dimension xhoriz(Nhoriz),yhoriz(Nhoriz)
cc
c          pie=3.141592653589793d0
cc
cc  Take care of the case where phi1 is slightly larger than zero and
cc  phi2 is near 2*pi.
cc
c          overQ=Q
c          if(istar.eq.2)overQ=1.0d0/Q
c          phinew=0.5d0*(phivis+phihid)
c          do 10 i=1,14
cc
cc   Find a new phi, which is the average of the two phi values.
cc   Then given theta and phi, compute cox,coy,coz, etc.
cc
c
c            thetanew=0.5d0*(thetavis+thetahid)
c            rnew=0.5d0*(rvis+rhid)
c            cox=dcos(phinew)*dsin(thetanew)
c            coy=dsin(phinew)*dsin(thetanew)
c            coz=dcos(thetanew)
cc
c            call rad(overQ,omega,cox,coy,coz,psi0,rnew,x,y,z,1,bdist,thetamis,phimis)
cc
c            xpnew=xtran(x,y,z,phase,fincr,Q,istar,bdist)
c            ypnew=ytran(x,y,z,phase,fincr,Q,istar,bdist)
c            iyes=-100
c            call insidecircle(Nhoriz,xhoriz,yhoriz,xpnew,ypnew,iyes,icut)
cc
c            if(iyes.eq.100)then
c              xhid=x
c              yhid=y
c              zhid=z
c              rhid=rnew
c              thetahid=thetanew
c            else
c              xvis=x
c              yvis=y
c              zvis=z
c              rvis=rnew
c              thetavis=thetanew
c            endif
c            diff=thetavis-thetahid
c 222        format(i2,2x,3(f9.6,2x))
c 10       continue
cc
c 15       thetaacc=thetavis
cc
cc          write(46,*)separ*xpnew,separ*ypnew
cc
c          return
c          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine findfill(istar,overQ,omega,critpsi,x0,usepot,psi0,fill,
     %           bdist,tidephi,itide,ecc,thetamis,phimis)
c
c  May 16, 2000.
c
c  This routine will find the filling factor needed to achieve the
c  surface potential usepot.
c
          implicit double precision (a-h,o-z)
c
          crit=critpsi
          if(istar.eq.2)then
            crit=critpsi/overQ+0.5d0*(overQ-1.0d0)/overQ
          endif
          if(usepot.le.crit)then
            fill=1.0
            write(2,100)istar,usepot,crit,istar
            psi0=critpsi
            return
          endif
c
          xsmall=0.5d0*x0
          xbig=x0
          y=0.0d0
          z=0.0d0
c
c   UPDATE November 14, 2009
c
c   Make the modifications needed to have the tidal approximation.  
c   Initialize cox=1.0 and coy=0.0
c
          cox=1.0d0
          coy=0.0d0
c
          psi0=critpsi
          psismall=critpsi
          do 10 i=1,45
c            write(*,200)xsmall,xbig,psismall,usepot,critpsi
            call POTEN(overQ,omega,xsmall,y,z,psismall,
     $          psix,psixx,psiy,psiz,1,bdist,cox,coy,tidephi,
     &          itide,ecc,thetamis,phimis)
            psmall=psismall
            if(istar.eq.2)then
              psmall=psismall/overQ+0.5d0*(overQ-1.0d0)/overQ
            endif
            if(psmall.gt.usepot)then
              xsmall=0.5*(xbig-xsmall)+xsmall
            else
              delta=0.5*(xbig-xsmall)
              xbig=xsmall
              xsmall=xbig-delta
            endif
 10       continue
c
          psi0=psismall
          fill=xsmall/x0
          write(2,201)istar,fill

 100      format(/'Info:  The value of usepot',i1,' = ',f11.5,
     @        ' is less ',
     %         /'than the critical potential = ',f11.5,
     $        '. Setting fill',i1,'=1.0')
c
c 200      format(2(f12.9,2x),3(f13.9,2x))
 201      format(/'Info:  fill',i1,' has been set to ',f9.7)
          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getATMint(maxlines,maxmu,Nlines,atmT,atmg,atmmu,
     @      Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,
     @      atmint8,gscale,darkint,tpole,gpole,
     %      dwavex,dwavey,ilaw,iatm,istar)
c
c  May 16, 2000
c
c  This subroutine will evaluate the integral:
c
c  dint = int^1_0 (I(T,g,mu)*mu*du)
c
c  The light curves are scaled by DINT for compatability with
c  Wilson and Devinney.
c 
c  The parameter gscale is used to convert the gravities in program units
c  into cgs units.  This number is G*M/(a*a).
c
          implicit double precision(a-h,o-z)

          parameter(pie=3.14159265358979323d0)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8),
     @       darkint(8),summ(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
          dimension dwavex(8,3),dwavey(8,3)

          if(iatm.lt.1)then
            do i=1,8
              flimbx=dwavex(i,istar)
              flimby=dwavey(i,istar)
c
c   December 15, 2013:  add triangular sampling
c
              if((ilaw.eq.5).or.(ilaw.eq.15))then
                savefx=flimbx
                savefy=flimby
                flimbx=2.0d0*dsqrt(savefx)*savefy
                flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
              endif

              rdint=pie*(1.0d0-flimbx/3.0d0)
              if((ilaw.eq.2).or.(ilaw.eq.12))then
                rdint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
              endif
              if((ilaw.eq.3).or.(ilaw.eq.13))then
                rdint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
              endif
              if((ilaw.eq.4).or.(ilaw.eq.14))then
                rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
              if((ilaw.eq.5).or.(ilaw.eq.15))then
                rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
              darkint(i)=rdint
            enddo
            return
          endif
c
c   Find the rough place in the atmosphere table.
c
          Tin=tpole
          gin=dlog10(gscale*gpole)
          call locate(atmT,Nlines,Tin,indexT)
          itguess=indexT
c
          do i=1,8
            summ(i)=0.0d0
          enddo
c
          hhh=0.01d0
          do 4 i=100,0,-1
            rmuin=dble(i)/100.0d0
            if(rmuin.gt.0.0d0)then
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @          atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @          atmint6,atmint7,atmint8,outinty,icnU,icnB,icnV,icnR,
     @          icnI,icnJ,icnH,icnK,itguess,dwavex,dwavey,ilaw,
     @          iatm,istar)
            else
              outinty(1)=0.0d0
              outinty(2)=0.0d0
              outinty(3)=0.0d0
              outinty(4)=0.0d0
              outinty(5)=0.0d0
              outinty(6)=0.0d0
              outinty(7)=0.0d0
              outinty(8)=0.0d0
           endif
c
            do 88 k=1,8
              if((i.eq.100).or.(i.eq.0))then
                 summ(k)=summ(k)+1.0d0*hhh*outinty(k)*rmuin
              else
                summ(k)=summ(k)+2.0d0*hhh*outinty(k)*rmuin
              endif
 88         continue
 4        continue
c
          DO 10 i=1,8
            rmuin=1.0d0
            call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @         atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     $         atmint6,atmint7,atmint8,outinty,icnU,icnB,icnV,icnR,icnI,
     @         icnJ,icnH,icnK,itguess,dwavex,dwavey,ilaw,iatm,
     @         istar)
c
            darkint(i)=pie*summ(i)/outinty(i)
 10       continue
c
          return
          end

c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine newsortcircle(N,xcir,ycir,Nhoriz,xhoriz,yhoriz,
     @       ibetmax,xhmin,xhmax,yhmin,yhmax)
c
c   May 18, 2000
c
c   This routine will take the x,y points of the star's horizon, sort them
c   in polar coordinates, resample by interpolation, and return new arrays
c   xhoriz,yhoriz.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xcir(N),ycir(N),theta(45000),rr(45000),
     $       dumt1(45000),dumr1(45000),xhoriz(4*ibetmax),yhoriz(4*ibetmax),
     &       dumt2(45000),dumr2(45000)
c
          call getmaxvalues(N,xcir,ycir,xmin,xmax,ymin,ymax)  !get the extreme
c                                                            !values
          xcenter=(xmax+xmin)/2.0d0
          ycenter=(ymax+ymin)/2.0d0
c
c   convert to polar coordinates         
c
          do 10 i=1,N
            xxx=xcir(i)-xcenter
            yyy=ycir(i)-ycenter
            if(xxx.eq.0.0)then
              if(yyy.lt.0.0)then
                theta(i)=3.0d0*pie/2.0d0
                rr(i)=dsqrt(xxx*xxx+yyy*yyy)
                go to 10
              endif
              if(yyy.ge.0.0d0)then
                theta(i)=pie/2.0d0
                rr(i)=dsqrt(xxx*xxx+yyy*yyy)
                go to 10
              endif
            endif
            if((yyy.ge.0.0d0).and.(xxx.ge.0.0d0))then
              theta(i)=(atan2(yyy,xxx))
              rr(i)=dsqrt(xxx*xxx+yyy*yyy)
            endif
            if((yyy.ge.0.0d0).and.(xxx.lt.0.0d0))then
              theta(i)=(atan2(yyy,xxx))
              rr(i)=dsqrt(xxx*xxx+yyy*yyy)
            endif
            if((yyy.lt.0.0d0).and.(xxx.lt.0.0d0))then
              rr(i)=dsqrt(xxx*xxx+yyy*yyy)
              theta(i)=2.0d0*pie+(atan2(yyy,xxx))
            endif
            if((yyy.lt.0.0d0).and.(xxx.ge.0.0d0))then
              rr(i)=dsqrt(xxx*xxx+yyy*yyy)
              theta(i)=2.0d0*pie+atan2(yyy,xxx)
            endif
 10       continue
c
          if(N.gt.1)call sort3(N,theta,rr,ycir)  !sort by theta and swap x and y also
c
c   Now make a dummy array with theta going from -360 to 720 degrees.
c   This will ensure the interpolation is smooth near the boundaries.
c
          icount=0
          do 20 i=1,N
            icount=icount+1
            dumt1(icount)=theta(i)-2.0d0*pie
            dumr1(icount)=rr(i)
 20       continue
c
          do 30 i=1,N
            icount=icount+1
            dumt1(icount)=theta(i)
            dumr1(icount)=rr(i)
 30       continue
c
          do 40 i=1,N
            icount=icount+1
            dumt1(icount)=theta(i)+2.0d0*pie
            dumr1(icount)=rr(i)
 40       continue
c
          Ndum=icount
c
c   Remove possible repeated points.
c
          icount=0
          do 45 i=2,Ndum
            diff=dabs(dumt1(i)-dumt1(i-1))
            if(diff.gt.1.0d-10)then
              icount=icount+1
              dumt2(icount)=dumt1(i-1)
              dumr2(icount)=dumr1(i-1)
            endif
 45       continue
c
          Ndum=icount

          radcon=pie/180.0d0
c
          index=N
          m=3
          Nhoriz=360
c
c   Update May 8, 2006
c
c   Find the minimum and maximum x and y values
c
          xhmin=1.d20
          xhmax=-1.d20
          yhmin=1.d20
          yhmax=-1.d20
c
          Nhoriz=360
          do 50 i=1,360
            angle=dble(i)*radcon
            call hunt(dumt2,Ndum,angle,index)
            k=min(max(index-(m-1)/2,1),Ndum+1-m)
            call polint(dumt2(k),dumr2(k),m,angle,qqq,dy)
c
c   Now assign x,y coordinates based on the qqq (radius) and angle.
c
            xhoriz(i)=qqq*dcos(angle)+xcenter
            yhoriz(i)=qqq*dsin(angle)+ycenter
            if(xhoriz(i).lt.xhmin)xhmin=xhoriz(i)
            if(yhoriz(i).lt.yhmin)yhmin=yhoriz(i)
            if(xhoriz(i).gt.xhmax)xhmax=xhoriz(i)
            if(yhoriz(i).gt.yhmax)yhmax=yhoriz(i)
 50       continue

          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   UPDATE June 14, 2002
c
c   Comment out this subroutine for now.
c
c
c          subroutine diskrefl(ialphmax1,ibetmax1,
c     $      Nalph1,Nbet1,ibetlim1,Nalph2,Nbet2,ibetlim2,ratio1,ratio2,
c     $      xarray1,yarray1,zarray1,gradx1,grady1,gradz1,garray1,surf1,
c     $      xarray2,yarray2,zarray2,gradx2,grady2,gradz2,garray2,surf2,
c     $      temp1,temp2,tempold1,tempold2,dbolx,dboly,ilaw,alb1,alb2,teff1,
c     $      teff2,Tgrav1,Tgrav2,rLx,iidint,gpole1,gpole2,
c     %      Tpole1,Tpole2,coprat1,coprat2,Nthetamax,Nrmax,Ntheta,Nradius,
c     %      betarim,rinner,router,reff2,Rl2,separ,
c     $      tdisk,xi,dtemp,dx,dy,dz,drad,
c     $      tedge,xedge,yedge,zedge,redge,stepr,stepz,dratio,reper,
c     &      rsper,ialphmax2,ibetmax2)
cc
cc   July 27, 2000
cc
cc    This routine will alter the temperatures on the disk by
cc    means of a modified version of the 'detailed reflection' 
cc    (R. E. Wilson 1990, ApJ, 356, 613). 
cc
c          implicit double precision(a-h,o-z)
cc
c          parameter(pie=3.14159265358979323d0)
c          dimension xarray1(ialphmax1*ibetmax1),yarray1(ialphmax1*ibetmax1),
c     $      zarray1(ialphmax1*ibetmax1),surf1(ialphmax1*ibetmax1),
c     &      gradx1(ialphmax1*ibetmax1),temp1(ialphmax1*ibetmax1),
c     $      grady1(ialphmax1*ibetmax1),gradz1(ialphmax1*ibetmax1),
c     %      garray1(ialphmax1*ibetmax1),ratio1(ialphmax1*ibetmax1),
c     $      tempold1(ialphmax1*ibetmax1),ibetlim1(ialphmax1),
c     $      ibetlim2(ialphmax2),coprat1(ialphmax1*ibetmax1),
c     $      coprat2(ialphmax2*ibetmax2)
c          dimension xarray2(ialphmax2*ibetmax2),yarray2(ialphmax2*ibetmax2),
c     $      zarray2(ialphmax2*ibetmax2),surf2(ialphmax2*ibetmax2),
c     &      gradx2(ialphmax2*ibetmax2),temp2(ialphmax2*ibetmax2),
c     $      grady2(ialphmax2*ibetmax2),gradz2(ialphmax2*ibetmax2),
c     %      garray2(ialphmax2*ibetmax2),ratio2(ialphmax2*ibetmax2),
c     $      tempold2(ialphmax2*ibetmax2)
c          dimension dbolx(8,2),dboly(8,2)
c          dimension dtemp(Nrmax,Nthetamax),dx(Nrmax,Nthetamax),
c     &      dy(Nrmax,Nthetamax),dz(Nrmax,Nthetamax),dratio(Nrmax,Nthetamax),
c     &      drad(Nrmax),xedge(Nthetamax,11),yedge(Nthetamax,11),
c     &      zedge(Nthetamax,11),tedge(Nthetamax,11)
cc
cc   Start with the disk face.  It is assumed that the lower face is exactly
cc   the same as the upper face, but with a negative z-value.  In practice,
cc   however, we never see the bottom face.
cc          
c          radcon=pie/180.0d0
c          diff2max=-1234.
c          iii=1
c          if(iii.eq.0)then
c            redge=router*reff2              ! radius of outer edge in x units
c            rsmall=rinner*Rl2               ! radius of inner edge in x units
c            reper=redge
c            rsper=rsmall
c          else
c            redge=reper
c            rsmall=rsper
c          endif
cc
c          betarad=betarim*radcon       ! radians
c          steptheta=360.0d0/dble(ntheta)
c          stepr=(redge-rsmall)/dble(Nradius-1)
cc
cc   Transform r into zeta.
cc
c          zetain=2.0d0*dsqrt(rsmall)
c          zetaout=2.0d0*dsqrt(redge)
c          stepzeta=(zetaout-zetain)/dble(Nradius-1)
cc
c          theta=0.0d0
c          zeta=zetain
cc
cc   Start with star 1 and compute the flux from star 2.
cc
c          darkbolx1=dbolx(1,1)
c          darkboly1=dboly(1,1)
c          darkbolx2=dbolx(1,2)
c          darkboly2=dboly(1,2)
cc
c          dtheta1=pie/(1.0d0*nalph1)
c          dtheta2=pie/(1.0d0*nalph2)
cc
cc   Define the integrated  limb darkening coefficients.  The equation is
cc
cc   dint=2*pi*int_0^1{mu*(1-x*(1-mu))d(mu)}  for the linear law, etc.
cc
c          dint1=pie*(1.0d0-darkbolx1/3.0d0)
c          dint2=pie*(1.0d0-darkbolx2/3.0d0)
c          if(ilaw.eq.2)then
c            dint1=pie*(1.0d0-darkbolx1/3.0d0+2.0d0*darkboly1/9.0d0)
c            dint2=pie*(1.0d0-darkbolx2/3.0d0+2.0d0*darkboly2/9.0d0)
c          endif
c          if(ilaw.eq.3)then
c            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/5.0d0)
c            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/5.0d0)
c          endif
c          if(teff2.gt.0.0d0)then
c            C1=(Tpole2/Tpole1)**(4)*(dint1/dint2)
c            C1=C1*alb1/dint1
c          endif
c          nalf12=nalph1/2
c          nalf22=nalph2/2
c          DIV1 = gpole1    ! gravity at the pole
c          DIV2 = gpole2    ! gravity at the pole
ccc
cc
c 11       continue
cc
c          do 2 ir=1,Nradius
c            do 1 ithet=1,Ntheta
c              dratio(ir,ithet)=1.0d0
c 1          continue
c 2        continue
cc
c          dint2=1.0
c          T4g1=4.0d0*Tgrav1
c          T4g2=4.0d0*Tgrav2
c          sbet=dsin(betarad)
c          cbet=dcos(betarad)
c          do 20 ir=1,Nradius
c            zeta=zetain+dble(ir-1)*stepzeta
c            r=0.25d0*zeta*zeta
c            do 19 ithet=1,Ntheta ! theta goes from zero to 360-step
c              theta=dble(ithet)*steptheta-0.5*steptheta  ! degrees
c              thetar=theta*radcon            ! radians
c              cthet=dcos(thetar)
c              sthet=dsin(thetar)
c              summ=0.0d0
c              C2=(Tpole1/dtemp(ir,ithet))**(4)*(dint2/dint1)
c              C2=C2*alb2/dint2
cc
c              do 18 i=1,Nalph1/2
c                do 17 j=1,ibetlim1(i)*4
c                  xflip1=xarray1(i,j)     
c                  yflip1=yarray1(i,j)     
c                  zflip1=zarray1(i,j)
c                  dist1=(xflip1-dx(ir,ithet))**2 +
c     %                  (yflip1-dy(ir,ithet))**2 +
c     $                  (zflip1-dz(ir,ithet))**2
c                  dist1=dsqrt(dist1)
c                  term1=(xflip1-dx(ir,ithet))*sbet*cthet+
c     $                  (yflip1-dy(ir,ithet))*(-sthet*sbet)+
c     @                  (zflip1-dz(ir,ithet))*cbet
c                  foreshort1=(term1/(dist1))    
cc
c                  if(foreshort1.le.0.0d0)go to 17
cc
c                  dist2=dist1  
cc                  
c                  xflip2=dx(ir,ithet)
c                  yflip2=dy(ir,ithet)
c                  zflip2=dz(ir,ithet)
cc
c                  term2=(-xflip2+xarray1(i,j))*gradx1(i,j)+
c     $                  (-yflip2+yarray1(i,j))*grady1(i,j)+
c     @                  (-zflip2+zarray1(i,j))*gradz1(i,j)
c                  foreshort2=(term2/(dist2)) 
c                  if(foreshort2.le.0.0d0)go to 17
cc
cc                  term3=(garray1(i,j)/div1)**(T4g1)
cc                  term3=term3*surf1(i,j)*coprat1(i,j)
cc                  term3=term3*foreshort1*foreshort2/(dist2*dist2)
c                  term3=(garray1(i,j)/div1)**(T4g1)*
c     &      surf1(i,j)*coprat1(i,j)*foreshort1*foreshort2/(dist2*dist2)
c                  if(ilaw.eq.1)then
c                    term3=term3*(1.0d0-darkbolx1+darkbolx1*foreshort2)
c                  endif
c                  if(ilaw.eq.2)then
c                    if(foreshort2.gt.0.0d0)then
c                      ttt=darkboly1*foreshort2*dlog(foreshort2)
c                    else
c                      ttt=0.0d0
c                    endif
c                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
c                  endif
c                  if(ilaw.eq.3)then
c                    if(foreshort2.gt.0.0d0)then
c                      ttt=darkboly1*(1.0d0-dsqrt(foreshort2))
c                    else
c                      ttt=darkboly1
c                    endif
c                    term3=term3*(1.0d0-darkbolx1*(1.0d0-foreshort2)-ttt)
c                  endif
c                  summ=summ+term3
c 17             continue
c 18           continue
cc
cc   Check to see if the point on star 2 can actually see any point on
cc   the disk.  If not, then the summ will be zero.
cc
c              if(summ.eq.0.0d0)go to 19
cc
c              FpAoverFB=C2*summ
c              dratio(ir,ithet)=1.0d0+FpAoverFB
c              tnew=dtemp(ir,ithet)*dratio(ir,ithet)**0.25d0
c              diff=tnew-dtemp(ir,ithet)
c              if(diff.gt.diff2max)diff2max=diff
c              dtemp(ir,ithet)=tnew
cc              write(*,6969)ir,ithet,theta,dx(ir,ithet),
cc     &           dy(ir,ithet),dz(ir,ithet),dtemp(ir,ithet)
c 19         continue
c 20       continue
c 6969     format(2(i3,1x),f7.3,3x,3(f8.5,2x),f7.1)
cc
cc   Now use symmetry to fill in the other quadrants on the star.  
cc
c 50       continue
cc
c          do 2000 iz=-5,5
c            z=dble(iz)*stepz
c            do 1900 ithet=1,Ntheta        !theta goes from zero to 360-step
c              theta=dble(ithet)*steptheta-0.5*steptheta   ! degrees
c              thetar=theta*radcon         ! radians
cc              xedge(ithet,iz+6)=bdist-redge*dcos(thetar)
cc              yedge(ithet,iz+6)=redge*dsin(thetar)
cc              zedge(ithet,iz+6)=z
c              tedge(ithet,iz+6)=dtemp(Nradius,ithet)
cc
c              if(theta.gt.300.0d0.and.theta.lt.320.0d0)tedge(ithet,iz+6)=
c     %          30.0d0*diff2max+tedge(ithet,iz+6)
cc
c 1900       continue
c 2000     continue
cc
c          if(diff2max.lt.0.0d0)diff2max=0.0
c          if(diff1max.lt.0.0d0)diff1max=0.0
cc
c          write(2,72)diff2max
c 999      continue
cc          write(2,71)diff1max
cc
c 71       format(/'maximum temperature change for star 1 = ',f13.5)
c 72       format('maximum temperature change for the disk = ',f13.5)
c
c          return
c          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine writetempgrav(ialphmax,ibetmax,Nalph,Nbet,ibetlim,
     %        tarray,garray,gscale,istar,xx,yy,zz,mmdx,phistart,separ)
c
c   October 6, 2000
c
c   This subroutine will output the values of the temperature and
c   gravity in physical units [i.e. log(g) in cgs] for each array element.
c   It will also output the angles for use in simple contouring programs.
c
c
c   UPDATE June 7, 2002
c
c   Add the x, y, and z coordinate arrays to the argument of writetempgrab
c
          implicit double precision (a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension garray(ialphmax*ibetmax),tarray(ialphmax*ibetmax),
     %       ibetlim(ialphmax),xx(ialphmax*ibetmax),
     &       yy(ialphmax*ibetmax),zz(ialphmax*ibetmax),
     @       mmdx(ialphmax,ibetmax),phistart(ialphmax)
c
          dtheta=pie/dble(Nalph)
c
          if(istar.eq.1)then
            open(unit=27,file='star1tempgrav.dat',status='unknown')
          else
            open(unit=27,file='star2tempgrav.dat',status='unknown')
          endif
c
c          isquare=1
          do 10 ialf=1,Nalph
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
c            ibetlim(ialf)=idnint(dsin(theta)*4*Nbet)
c            if(isquare.ge.1)ibetlim(ialf)=4*Nbet
            dphi=2.0d0*pie/dble(ibetlim(ialf))
            DO 9 ibet=1,ibetlim(ialf)          !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              phi=-0.5d0*dphi+dphi*dble(ibet)
              phi=phi+phistart(ialf)
c
c            if(dble(ialf/2).eq.(dble(ialf)*0.5d0))phi=phi+0.25d0*dphi   !DPHI
c
              grav=dlog10(gscale*garray(iidx))
              conphi=phi
              if(phi.gt.pie)conphi=phi-2.0d0*pie
              contheta=theta-0.5d0*pie
              if(ibet.le.2*Nbet)then
                iconbet=ibet+2*Nbet
              else
                iconbet=ibet-2*Nbet
              endif
c
c   UPDATE June 7, 2002
c
c   Add the x, y, and z coordinates to the write statement.  Modify
c   format statement 100 below (add 3(f7.4,1x) to the end).
c
              RRR=dsqrt(xx(iidx)**2+yy(iidx)**2+zz(iidx)**2)
              RRR=RRR*separ
              write(27,100)tarray(iidx),grav,theta,phi,ialf,ibet,
     %         contheta,conphi,ialf,iconbet,
     %         xx(iidx),yy(iidx),zz(iidx),RRR
 9          continue
 10       continue
          close(27)
c
 100      format(f12.5,1x,f8.5,1x,2(f8.6,1x),1x,
     @          2(i3,1x),1x,f8.5,2x,f8.5,2x,2(i3,1x),3(f7.4,1x),1x,f12.6)
c
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c  UPDATE March 26, 2002
c
c  Remove the variables icount and dphase from the argument list of
c  shiftlc (they are not used).
c
          subroutine shiftlc(Nmaxphase,Nphase,xxx,yyy,pshift,
     %       ilast)
c
c   February 5, 2001
c
c   This routine will apply a phase shift to a light or velocity curve

c   
          implicit double precision(a-h,o-z)
c
          parameter(NNdum=1000001)
          dimension xxx(Nmaxphase),yyy(Nmaxphase),ydum(NNdum),xdum(NNdum)
c
          do 5 i=1,Nphase
            xdum(i)=xxx(i)
 5        continue
c
          do 10 i=1,Nphase
            xdum(i)=xdum(i)+pshift
            xdum(i)=dmod(xdum(i),1.0d0)
            ydum(i)=yyy(i)
 10       continue
c
c   April 19, 2001
c
c   Add the loop below to ensure that the final x-values are always between
c   0.0 and 1.0.  In some cases where the eccentricity is large, the 
c   first pass above might not be enough.
c
          xmax=-999.d0
          xmin=999.d0
 99       do 11 i=1,Nphase
            if(xdum(i).gt.xmax)xmax=xdum(i)
            if(xdum(i).lt.xmin)xmin=xdum(i)
            if(xdum(i).ge.1.0d0)xdum(i)=xdum(i)-1.0d0
            if(xdum(i).lt.0.0d0)xdum(i)=xdum(i)+1.0d0
 11       continue
c
          if(xmax.ge.2.0d0)go to 99
          if(xmin.lt.-1.0d0)go to 99
c
c 
c
          if(Nphase.gt.1)call sort3(Nphase,xdum,yyy,ydum)
c
          if(ilast.eq.1)then
            do 15 i=1,Nphase
              xxx(i)=xdum(i)
 15         continue
          endif
c
c 101      format(f6.2)
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getE(em,ecc,bigE)
c
c    Solve for bigE in  em = bigE - ecc*sin(bigE)  (i.e. Kepler's Eq.)
c
          implicit double precision (a-h,o-z)
          Eold=em
c
          do 10 i=1,20
            top=Eold-ecc*dsin(Eold)-em
            bottom=1.0d0-ecc*dcos(Eold)
            Enew=Eold-top/bottom
            diff=dabs(Enew-Eold)
            if(diff.lt.1.0d-14)go to 15
            Eold=Enew
 10       continue
c
 15       bigE=Eold
c
          return
c
          end
c
c  *************************************************************************
c
c  UPDATE March 26, 2002
c
c  Get rid of the variables phiar, jj, istar from the argument list
c  of getBBsimp.
c
c  UPDATE June 22, 2002
c
c  Add separ to the argument list.
c
c
c          subroutine getBBsimp(ialphmax,ibetmax,Nalf,Nbet,ibetlim,
c     $      wave,visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,
c     &      flum,flux,delphi,delphiedge,iedgestar,iedgehor,rldint,
c     %      isimp,separ,mmdx)
c
c  October 11, 1999
c
c  This routine will compute the intensities of each element, given the
c  temperatures (temp(ialf,ibet)) and the input wavelength.  It will then
c  integrate the flux given the visibilities (visib) and surface elements
c  (surf).   
c
c  The projarray contains the cosine mu terms for each element.  The visib
c  array contains the cosine mu terms for each element, except if the point
c  is eclipsed in which case the visib=0
c
c  April 2, 2001
c
c  This version will integrate the flux along latitude rows using a
c  Simpson's rule summation. 
c 
c          implicit double precision(a-h,o-z)
cc
c          parameter(pie=3.14159265358979323d0)
c          dimension visib(ialphmax*ibetmax),delphi(ialphmax*ibetmax),
c     $        surf(ialphmax*ibetmax),ibetlim(ialphmax),
c     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
c     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
c     %        iedgehor(ialphmax*ibetmax),iedgestar(ialphmax*ibetmax),
c     $        delphiedge(ialphmax*ibetmax),saveflum(1000*1000),
c     @        iflag(1000*1000),mmdx(ialphmax,ibetmax)
c          dimension yflux(1000),xflux(1000),icase(1000),mark(2,1000),
c     @        yend(2),xend(2),yvalue(2)
cc
cc   UPDATE March 26, 2002.
cc
cc   Remove the variable flagx1 from the list of the declaration statement.
cc
c          logical x1assign,x2assign
cc
cc   UPDATE June 22, 2002
cc
c   Declare flag as a logical variable.
c
c          logical flag
c
c
c  The array icase(ialf) contains information about the arrangement of
c  the horizons:
c
c  icase=1 : all phi points for a given ialf are visible 
c
c  icase=2 : phi(1)<phi(2)  and all points inbetween are visible
c
c  icase=3 : phi(1)<phi(2)  points between phi(2),2*pi and 0,phi(1)
c            are visible
c
c  The variables yend(1) and yend(2) contain the corrections for the end 
c  points:
c
c      icase=1  yend(1)=0.5*yflux(1)     yend(2)=0.5*y(N)
c      etc.
c
c   UPDATE June 17, 2002
c
c   Add this dummy assignment for separ to supress compiler warning
c   about unused variable.
c
C
C   UPDATE June 11, 2003
c
c   Comment out the routine from here on.
C
c          stop
c
c          ddd1=separ
cc
c          do 111 i=1,1000
c            xflux(i)=0.0d0
c            yflux(i)=0.0d0
c            icase(i)=0
c            mark(1,i)=0
c            mark(2,i)=0
c 111      continue
cc
c          dint=pie*(1.0d0-flimbx/3.0d0)
c          if(ilaw.eq.2)then
c            dint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
c          endif
c          if(ilaw.eq.3)then
c            dint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
c          endif
cc
c          itotal=0
c          igood=0
c          flux=0.0d0
c          C2 = 1.4384d8          ! 1.4384 * 10.**8      ! hc/(k*1e-8)
c          C1 = 1.191044d35       ! 2hc^2/((1e-8)**5)
cc
cc   Initialize the flum matrix.
cc
cc
c          do 2 ialf=1,nalf
c            do 1 ibet=1,4*Nbet
c              iidx=(ialf-1)*4*Nbet+ibet
c              flum(iidx)=0.0d0
c              rinty(iidx)=0.0d0
c              saveflum(iidx)=0.0d0
c              iflag(iidx)=-99
c 1          continue
c 2        continue
cc
cc   Compute the intensity values of pixels just behind the edge or the
cc   eclipsing horizon for use in fractional eclipse corrections.
cc
c          wavemu=wave/10000.0d0
c          c1=3.74185
c          c2=14.3883
c          do 4 ialf=1,nalf
c            flag=.true.
c            imark=0
c            do 3 ibet=1,ibetlim(ialf)
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              if(projarray(iidx).lt.0.0d0)flag=.false.
c              if(iedgestar(iidx).ge.10)then
c                imark=imark+1
c                mark(imark,ialf)=ibet
c              endif
c              if((iedgehor(ialf,ibet).eq.-10).or.(iedgehor(ialf,ibet).gt.
c     @             5).or.(iedgestar(ialf,ibet).eq.-10).or.(iedgestar(ialf,ibet)
c     $             .gt.5).or.(delphi(ialf,ibet).gt.-10.0d0))then
c                C3 = C2/(WAVE*TEMP(IALF,IBET))
c
c                tkkelv=temp(ialf,ibet)/1000.0d0
c                C3 = C2/(wavemu*tkkelv)
c                saveflum(ialf,ibet)=C1/(dexp(c3)-1.0d0)/wavemu**5
c                dark=(1.0d0-flimbx+flimbx*dabs(projarray(ialf,ibet)))
c                if(ilaw.eq.2)dark=dark-flimby*dabs(projarray(ialf,ibet))*
c     %                dlog(dabs(projarray(ialf,ibet)))
c                if(ilaw.eq.3)dark=dark-flimby*(1.0d0-
c     &            dsqrt(dabs(projarray(ialf,ibet))))
c                saveflum(ialf,ibet)=saveflum(ialf,ibet)*dark
c                saveflum(ialf,ibet)=surf(ialf,ibet)*saveflum(ialf,ibet)*
c     $            dabs(projarray(ialf,ibet))
c              endif
c 3          continue
c            if(flag.eqv..true.)icase(ialf)=1
c 4        continue
cc
c          do 44 ialf=1,nalf
c            if(icase(ialf).eq.1)go to 44
c            flag=.true.
c            do 33 ibet=mark(1,ialf),mark(2,ialf)
c              if(projarray(ialf,ibet).lt.0.0d0)flag=.false.              
c 33         continue
c            if(flag.eqv..true.)icase(ialf)=2
c 44       continue
cc
c          do 444 ialf=1,nalf
c            if(icase(ialf).eq.1)go to 444
c            if(icase(ialf).eq.2)go to 444
c            flag=.true.
c            do 333 ibet=mark(2,ialf),ibetlim(ialf)
c              if(projarray(ialf,ibet).lt.0.0d0)flag=.false.              
c 333         continue
c            do 334 ibet=1,mark(1,ialf)
c              if(projarray(ialf,ibet).lt.0.0d0)flag=.false.              
c 334        continue
c            if(flag.eqv..true.)icase(ialf)=3
c 444      continue
cc
c          do 555 ialf=1,nalf
c            if(icase(ialf).eq.0)write(*,*)'icase=0 ',icase(ialf)
c 555      continue
cc
c          sumcor1=0.0d0
c          sumcor2=0.0d0
c          totalsum=0.0d0
c          dtheta=0.5d0*pie/dble(Nalf)
cc
c          flag=.false.
c          icount=0
c          phisum=0.0d0
c          DO 10 ialf=1,nalf
c            theta=-dtheta+2.0d0*dtheta*dble(ialf)
c            sitheta=dsin(theta)
cc
cc   Caution!  The dphi defined here is exactly half the dphi in the
cc   subroutine setupgeo!
cc
c            dphi=pie/dble(ibetlim(ialf))
c            if(flag.eqv..true.)then
c              if(isimp.eq.2)then
c                call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                totalsum=totalsum+rowsum  
c              else
c                call simpson(icount,yflux,rowsum,dphi)
c                totalsum=totalsum+rowsum+yend(1)+yend(2)
c              endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c
cc              if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 1',ialf,ibet
cc              if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 1',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c              itotal=itotal+icount
c              icount=0
c              rowsum=0.0d0
c              yend(1)=0.0d0
c              yend(2)=0.0d0
c              flag=.false.
c            endif
cc
cc   Initialize the flag which indicates that we are going along a
cc   visible row.
cc
c            flag=.false.
c            icount=0
c            rowsum=0.0d0
c            yend(1)=0.0d0
c            yend(2)=0.0d0
c            phisum=0.0d0
c            x1assign=.false.
c            x2assign=.false.
c            if(icase(ialf).eq.1)then
c              DO 9 ibet = 1,ibetlim(ialf)              !4*nbet
c                phiabs=dabs(delphi(ialf,ibet))
c                edgeabs=dabs(delphiedge(ialf,ibet))
c                if((projarray(ialf,ibet).le.0.0d0))then
cc
cc   We have gone over the horizon.  If previous ibet values were visible,
cc   then call the Simpson routine.  Otherwise, go on to the next ibet.
cc
c                  if(flag.eqv..false.)go to 9
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 2',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 2',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  phisum=0.0d0
c                  go to 9
c                endif
c                tkkelv=temp(ialf,ibet)/1000.0d0
c                C3 = C2/(wavemu*tkkelv)
c                flum(ialf,ibet)=C1/(dexp(c3)-1.0d0)/wavemu**5
c                dark=(1.0d0-flimbx+flimbx*projarray(ialf,ibet))
c                if(ilaw.eq.2)dark=dark-flimby*projarray(ialf,ibet)*
c     %               dlog(projarray(ialf,ibet))
c                if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(ialf,ibet)))
c                flum(ialf,ibet)=flum(ialf,ibet)*dark
c                rinty(ialf,ibet)=flum(ialf,ibet) ! save intys for plotting
c                saveflum(ialf,ibet)=surf(ialf,ibet)*flum(ialf,ibet)*
c     $            projarray(ialf,ibet)
c                flum(ialf,ibet)=surf(ialf,ibet)
c     @             *flum(ialf,ibet)*visib(ialf,ibet)
cc
c                if((visib(ialf,ibet).le.0.0d0))then
cc
cc   We have a point that would have been visible (proj>0), but it is eclipsed.
cc   Call the Simpson routine using the current string of points.
cc
c                  if(flag.eqv..false.)go to 9
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 3',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 3',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  rowsum=0.0d0
c                  yend(1)=0.0d0
c                  yend(2)=0.0d0
c                  phisum=0.0d0
c                endif
c                if((visib(ialf,ibet).gt.0.0d0))then
cc
cc   We have a point that is visible.  Add it to the current string of
cc   points.
cc
c                  flag=.true.
c                  icount=icount+1
c                  yflux(icount)=flum(ialf,ibet)
c                  xflux(icount)=phisum
c                  phisum=phisum+2.0d0*dphi
cc
cc   In case 1 xend(1) might not necessairly be assigned since it may not
cc   be next to an eclipsing horizon or the edge horizon.
cc
c                  xend(1)=-2.0d0*dphi              
c                  yend(1)=0.5d0*yflux(1)/dabs(xend(1))
c                  x1assign=.true.
c                  if(icount.eq.1)then
c                    if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   If this point is the first in the string and at the horizon, then
cc   the connecting end piece is a triangle.  The area is 0.5 times the
cc   y-value times the phi distance.  
cc
c                      yvalue(1)=0.0d0
c                      yend(1)=0.25d0*yflux(1)/dphi*edgeabs 
c                      xend(1)=xflux(1)-edgeabs
c                      x1assign=.true.
c                    else 
c                      if(iedgehor(ialf,ibet).eq.10)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.lt.ibetlim(ialf))then    
c                          y1=saveflum(ialf,ibet+1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y1=saveflum(ialf,1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                      if(iedgehor(ialf,ibet).eq.20)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.gt.1)then    
c                          y0=saveflum(ialf,ibet-1)
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y0=saveflum(ialf,ibetlim(ialf))
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                    endif  ! end if iedgehor > 10
c                  endif ! end if icount=1
c                  if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   The point in the string (not the first) is at the horizon.  The
cc   second end piece is a triangle.
c
c                    yvalue(2)=0.0d0
c                    yend(2)=0.25d0*yflux(icount)/dphi*edgeabs 
c                    xend(2)=xflux(icount)+edgeabs
c                    x2assign=.true.
c                  else
cc
cc   Otherwise, check to see if it near an eclipsing horizon.
cc
c                    if(iedgehor(ialf,ibet).eq.10)then
c                      if(ibet.lt.ibetlim(ialf))then    
c                        y1=saveflum(ialf,ibet+1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y1=saveflum(ialf,1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        yvalue(2)=yinterp
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                    if(iedgehor(ialf,ibet).eq.20)then
c                      if(ibet.gt.1)then    
c                        y0=saveflum(ialf,ibet-1)
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y0=saveflum(ialf,ibetlim(ialf))
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        yvalue(2)=yinterp
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif  ! end if ibet > 1
c                    endif    ! end if iedgehor > 20 
c                  endif      ! end if iedgestar > 10
c                endif        ! end if visib > 0
cc
c                flux=flux+flum(ialf,ibet)   
c                flum(ialf,ibet)=flum(ialf,ibet)
c                igood=igood+1
c 9            continue
c            endif            ! end if icase=1
cc
c            if(icase(ialf).eq.2)then
c              DO 79 ibet = mark(1,ialf),mark(2,ialf)              !4*nbet
c                phiabs=dabs(delphi(ialf,ibet))
c                edgeabs=dabs(delphiedge(ialf,ibet))
c                if((projarray(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 79
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 4',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 4',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  phisum=0.0d0
c                  go to 79
c                endif
c                tkkelv=temp(ialf,ibet)/1000.0d0
c                C3 = C2/(wavemu*tkkelv)
c                flum(ialf,ibet)=C1/(dexp(c3)-1.0d0)/wavemu**5
c                dark=(1.0d0-flimbx+flimbx*projarray(ialf,ibet))
c                if(ilaw.eq.2)dark=dark-flimby*projarray(ialf,ibet)*
c     %               dlog(projarray(ialf,ibet))
c                if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(ialf,ibet)))
c                flum(ialf,ibet)=flum(ialf,ibet)*dark
c                rinty(ialf,ibet)=flum(ialf,ibet) ! save intys for plotting
c                saveflum(ialf,ibet)=surf(ialf,ibet)*flum(ialf,ibet)*
c     $            projarray(ialf,ibet)
c                flum(ialf,ibet)=surf(ialf,ibet)
c     @             *flum(ialf,ibet)*visib(ialf,ibet)
cc
c                if((visib(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 79
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
cc
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 4',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 4',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  rowsum=0.0d0
c                  yend(1)=0.0d0
c                  yend(2)=0.0d0
c                  phisum=0.0d0
c                endif
c                if((visib(ialf,ibet).gt.0.0d0))then
c                  flag=.true.
c                  icount=icount+1
c                  yflux(icount)=flum(ialf,ibet)
c                  xflux(icount)=phisum
c                  phisum=phisum+2.0d0*dphi
c                  if(icount.eq.1)then
c                    if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   If this point is the first in the string and at the horizon, then
cc   the connecting end piece is a triangle.  The area is 0.5 times the
cc   y-value times the phi distance.  
cc
c                      yvalue(1)=0.0d0
c                      yend(1)=0.25d0*yflux(1)/dphi*edgeabs
c                      xend(1)=xflux(1)-edgeabs 
c                      x1assign=.true.
c                    else
c                      if(iedgehor(ialf,ibet).eq.10)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.lt.ibetlim(ialf))then    
c                          y1=saveflum(ialf,ibet+1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs 
c                      x1assign=.true.
c                        else
c                          y1=saveflum(ialf,1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                      if(iedgehor(ialf,ibet).eq.20)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.gt.1)then    
c                          y0=saveflum(ialf,ibet-1)
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y0=saveflum(ialf,ibetlim(ialf))
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                    endif
c                  endif ! end if icount=1
c                  if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   The point in the string (not the first) is at the horizon.  The
cc   second end piece is a triangle.
cc
c                    yvalue(2)=0.0d0
c                    yend(2)=0.25d0*yflux(icount)/dphi*edgeabs
c                    xend(2)=xflux(icount)+edgeabs 
c                    x2assign=.true.
c                  else
cc
cc   Otherwise, check to see if it near an eclipsing horizon.
cc
c                    if(iedgehor(ialf,ibet).eq.10)then
c                      if(ibet.lt.ibetlim(ialf))then    
c                        y1=saveflum(ialf,ibet+1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+delphi(ialf,ibet) 
c                    x2assign=.true.
c                      else
c                        y1=saveflum(ialf,1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                    if(iedgehor(ialf,ibet).eq.20)then
c                      if(ibet.gt.1)then    
c                        y0=saveflum(ialf,ibet-1)
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y0=saveflum(ialf,ibetlim(ialf))
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                  endif   
c                endif            ! end if visib > 0
cc
c                flux=flux+flum(ialf,ibet)    
c                flum(ialf,ibet)=flum(ialf,ibet)
c                igood=igood+1
c 79           continue
c            endif
cc
c            if(icase(ialf).eq.3)then
c              DO 89 ibet = mark(2,ialf),ibetlim(ialf)
c                phiabs=dabs(delphi(ialf,ibet))
c                edgeabs=dabs(delphiedge(ialf,ibet))
c                if((projarray(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 89
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
cc
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 5',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 5',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  phisum=0.0d0
c                  go to 89
c                endif
c                tkkelv=temp(ialf,ibet)/1000.0d0
c                C3 = C2/(wavemu*tkkelv)
c                flum(ialf,ibet)=C1/(dexp(c3)-1.0d0)/wavemu**5
c                dark=(1.0d0-flimbx+flimbx*projarray(ialf,ibet))
c                if(ilaw.eq.2)dark=dark-flimby*projarray(ialf,ibet)*
c     %               dlog(projarray(ialf,ibet))
c                if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(ialf,ibet)))
c                flum(ialf,ibet)=flum(ialf,ibet)*dark
c                rinty(ialf,ibet)=flum(ialf,ibet) ! save intys for plotting
c                saveflum(ialf,ibet)=surf(ialf,ibet)*flum(ialf,ibet)*
c     $            projarray(ialf,ibet)
c                flum(ialf,ibet)=surf(ialf,ibet)
c     @             *flum(ialf,ibet)*visib(ialf,ibet)
cc
c                if((visib(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 89
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                rite(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
cc
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 6',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 6',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  rowsum=0.0d0
c                  yend(1)=0.0d0
c                  yend(2)=0.0d0
c                  phisum=0.0d0
c                endif
c                if((visib(ialf,ibet).gt.0.0d0))then
c                  flag=.true.
c                  icount=icount+1
c                  yflux(icount)=flum(ialf,ibet)
c                  xflux(icount)=phisum
c                  phisum=phisum+2.0d0*dphi
c                  if(icount.eq.1)then
c                    if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   If this point is the first in the string and at the horizon, then
cc   the connecting end piece is a triangle.  The area is 0.5 times the
cc   y-value times the phi distance.  
cc
c                      yvalue(1)=0.0d0
c                      yend(1)=0.25d0*yflux(1)/dphi*edgeabs
c                      xend(1)=xflux(1)-edgeabs 
c                      x1assign=.true.
c                    else
c                      if(iedgehor(ialf,ibet).eq.10)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.lt.ibetlim(ialf))then    
c                          y1=saveflum(ialf,ibet+1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y1=saveflum(ialf,1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                        endif
c                      endif
c                      if(iedgehor(ialf,ibet).eq.20)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.gt.1)then    
c                          y0=saveflum(ialf,ibet-1)
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y0=saveflum(ialf,ibetlim(ialf))
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                        endif
c                      endif
c                    endif   ! end if iedgehor > 10
c                  endif ! end if icount=1
c                  if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   The point in the string (not the first) is at the horizon.  The
cc   second end piece is a triangle.
cc
c                    yvalue(2)=0.0d0
c                    yend(2)=0.25d0*yflux(icount)/dphi*edgeabs
c                    xend(2)=xflux(icount)+edgeabs
c                    x2assign=.true.
c                  else
cc
cc   Otherwise, check to see if it near an eclipsing horizon.
cc
c                    if(iedgehor(ialf,ibet).eq.10)then
c                      if(ibet.lt.ibetlim(ialf))then    
c                        y1=saveflum(ialf,ibet+1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y1=saveflum(ialf,1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                    if(iedgehor(ialf,ibet).eq.20)then
c                      if(ibet.gt.1)then    
c                        y0=saveflum(ialf,ibet-1)
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y0=saveflum(ialf,ibetlim(ialf))
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif    ! end if iedgehor > 20
c                  endif      ! end if iedgestar > 10
c                endif        ! end if visib > 1
cc
c                flux=flux+flum(ialf,ibet)    
c                flum(ialf,ibet)=flum(ialf,ibet)
c                igood=igood+1
c 89           continue
cc
cc   Continue with the string accross the break in the coordinates.
cc
c              DO 90 ibet = 1,mark(1,ialf)
c                phiabs=dabs(delphi(ialf,ibet))
c                edgeabs=dabs(delphiedge(ialf,ibet))
c                if((projarray(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 90
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 7',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 7',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  phisum=0.0d0
c                  go to 90
c                endif
c                tkkelv=temp(ialf,ibet)/1000.0d0
c                C3 = C2/(wavemu*tkkelv)
c                flum(ialf,ibet)=C1/(dexp(c3)-1.0d0)/wavemu**5
c                dark=(1.0d0-flimbx+flimbx*projarray(ialf,ibet))
c                if(ilaw.eq.2)dark=dark-flimby*projarray(ialf,ibet)*
c     %               dlog(projarray(ialf,ibet))
c                if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(ialf,ibet)))
c                flum(ialf,ibet)=flum(ialf,ibet)*dark
c                rinty(ialf,ibet)=flum(ialf,ibet) ! save intys for plotting
c                saveflum(ialf,ibet)=surf(ialf,ibet)*flum(ialf,ibet)*
c     $            projarray(ialf,ibet)
c                flum(ialf,ibet)=surf(ialf,ibet)
c     @             *flum(ialf,ibet)*visib(ialf,ibet)
cc
c                if((visib(ialf,ibet).le.0.0d0))then
c                  if(flag.eqv..false.)go to 90
c                  if(isimp.eq.2)then
c                    call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                    totalsum=totalsum+rowsum  
c                  else
c                    call simpson(icount,yflux,rowsum,dphi)
c                    totalsum=totalsum+rowsum+yend(1)+yend(2)
c                  endif
cc
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
cc
c
c                  if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 8',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 8',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c                  itotal=itotal+icount
c                  icount=0
c                  flag=.false.
c                  rowsum=0.0d0
c                  yend(1)=0.0d0
c                  yend(2)=0.0d0
c                  phisum=0.0d0
c                endif
c                if((visib(ialf,ibet).gt.0.0d0))then
c                  flag=.true.
c                  icount=icount+1
c                  yflux(icount)=flum(ialf,ibet)
c                  xflux(icount)=phisum
c                  phisum=phisum+2.0d0*dphi
c                  if(icount.eq.1)then
c                    if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   If this point is the first in the string and at the horizon, then
cc   the connecting end piece is a triangle.  The area is 0.5 times the
cc   y-value times the phi distance.  
cc
c                      yvalue(1)=0.0d0
c                      yend(1)=0.25d0*yflux(1)/dphi*edgeabs
c                      xend(1)=xflux(1)-edgeabs
c                      x1assign=.true.
c                    else
c                      if(iedgehor(ialf,ibet).eq.10)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.lt.ibetlim(ialf))then    
c                          y1=saveflum(ialf,ibet+1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y1=saveflum(ialf,1)
c                          y0=yflux(icount)
c                          slope=0.5d0*phiabs/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y0+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                      if(iedgehor(ialf,ibet).eq.20)then
cc
cc   If the first point is next to an eclipsing horizon, then the end
cc   piece will be a trapizoid.  Use interpolation to find the y-value
cc   at the horizon.
cc
c                        if(ibet.gt.1)then    
c                          y0=saveflum(ialf,ibet-1)
c                          y1=yflux(icount)
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        else
c                          y0=saveflum(ialf,ibetlim(ialf))
c                          y1=yflux(icount)
cc                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                          yinterp=y0+slope*(y1-y0)
c                          yvalue(1)=yinterp
c                          yend(1)=0.5d0*(y1+yinterp)*slope
c                          xend(1)=xflux(icount)-phiabs
c                      x1assign=.true.
c                        endif
c                      endif
c                    endif
c                  endif ! end if icount=1
c                  if(iedgestar(ialf,ibet).ge.10)then 
cc
cc   The point in the string (not the first) is at the horizon.  The
cc   second end piece is a triangle.
cc
c                    yvalue(2)=0.0d0
c                    yend(2)=0.25d0*yflux(icount)/dphi*edgeabs
c                    xend(2)=xflux(icount)+edgeabs
c                    x2assign=.true.
c                  else
cc
cc   Otherwise, check to see if it near an eclipsing horizon.
cc
c                    if(iedgehor(ialf,ibet).eq.10)then
c                      if(ibet.lt.ibetlim(ialf))then    
c                        y1=saveflum(ialf,ibet+1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y1=saveflum(ialf,1)
c                        y0=yflux(icount)
c                        slope=0.5d0*phiabs/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y0+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                    if(iedgehor(ialf,ibet).eq.20)then
c                      if(ibet.gt.1)then    
c                        y0=saveflum(ialf,ibet-1)
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      else
c                        y0=saveflum(ialf,ibetlim(ialf))
c                        y1=yflux(icount)
c                        slope=0.5d0*dabs(phiabs-2.0d0*dphi)/dphi
c                        yinterp=y0+slope*(y1-y0)
c                        yvalue(2)=yinterp
c                        yend(2)=0.5d0*(y1+yinterp)*slope
c                        xend(2)=xflux(icount)+phiabs
c                    x2assign=.true.
c                      endif
c                    endif
c                  endif
c                endif    ! endif visib > 0
cc
c                flux=flux+flum(ialf,ibet)   
c                flum(ialf,ibet)=flum(ialf,ibet)
c                igood=igood+1
c 90           continue
c            endif
c 10       continue
cc
c            if(flag.eqv..true.)then
c              if(isimp.eq.2)then
c                call simpson1(icount,xflux,yflux,xend,yvalue,rowsum,dphi) 
c                totalsum=totalsum+rowsum  
c              else
c                call simpson(icount,yflux,rowsum,dphi)
c                totalsum=totalsum+rowsum+yend(1)+yend(2)
c              endif
cc              if(jj.eq.3.and.ialf.eq.5)then
cc                call dump(33,icount,xflux,yflux)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc                call dump(34,2,xend,yvalue)
ccc                write(*,*)rowsum,dphi,rowsum+yend(1)+yend(2)
cc              endif
c 
c                 if(x1assign.eqv..false.)write(*,*)'xend(1) not assigned spot 9',ialf,ibet
c                  if(x2assign.eqv..false.)write(*,*)'xend(2) not assigned spot 9',ialf,ibet
c                  x1assign=.false.
c                  x2assign=.false.
c
c
c
c              itotal=itotal+icount
c              icount=0
c              rowsum=0.0d0
c              yend(1)=0.0d0
c              yend(2)=0.0d0
c              flag=.false.
c              phisum=0.0d0
c            endif
cc
cc   Scale the light curve by the integral of the limb darkening law
cc   for compatibility with Wilson-Devinney.
cc        
c          totalsum=pie*totalsum/dint
c          flux=totalsum
cc
c          rldint=dint
cc
cc
c 666      format(a6,2x,i2,2x,f9.7,2x,2(i3,1x))
c 667      format(3(i2,2x),2x,f8.6,2x,f11.6,3x,i4)
c
c          return
c          end
c
c   ************************
c
c   December 22, 2012
c
c   comment out
c
c          subroutine simpson(N,y,total,dphi)
cc
cc   April 2, 2001
cc
cc   This routine will sum the y-values in y(1:N) using Simpson's rule.
cc
c          implicit double precision (a-h,o-z)
c          dimension y(N)
cc
cc   UPDATE March 26, 2002
cc
cc   Assign a variable fake the value of dphi to supress compiler
cc   warning about an unusued variable.
cc
c          fake=dphi
cc
c          over3=1.0d0/3.0d0
c          over8=3.0d0/8.0d0
c          over6=7.0d0/6.0d0
c          over24=23.0d0/24.0d0
cc
c          total=0.0d0
cc
c          if(N.eq.1)then
c            total=y(1)
cc     $          +0.5*y(1)
c            return
c          endif
cc
c          if(N.eq.2)then
c            total=0.5d0*(y(1)+y(2))
cc     $          +0.5d0*(y(1)+y(2))
c            return
c          endif
cc
c          if(N.eq.3)then
c            total=(over3*y(1)+4.0d0*over3*y(2)+over3*y(3))
cc     &           +0.5d0*(y(1)+y(3))
c            return
c          endif
cc
c          if(N.eq.4)then
c            total=(over8*y(1)+3.0d0*over8*y(2)+3.0d0*over8*y(3)
c     $            +over8*y(4))
cc     $            +0.5d0*(y(1)+y(4))
c            return
c          endif
cc
c          if(N.eq.5)then
c            total=(over3*y(1)+4.0d0*over3*y(2)+2.0*over3*y(3)
c     $            +4.0d0*over3*y(4)+over3*y(5))
cc     %            +0.5d0*(y(1)+y(5))
c            return
c          endif
cc
c          if(N.gt.5)then
c            do 30 i=1,N
c              weight=1.0d0
c              if(i.eq.1)weight=over8
c              if(i.eq.N)weight=over8
c              if(i.eq.2)weight=over6
c              if(i.eq.N-1)weight=over6
c              if(i.eq.3)weight=over24
c              if(i.eq.N-2)weight=over24
c              total=total+weight*y(i)
c 30         continue
cc              total=total+0.25d0*(y(1)+y(N))
c            return
c          endif
cc
c          return
c          end
cc
cc  &&&&&&&&&&&&&&&&&
c
c
c  Move spline and splint from optimizesubs.for to here:
c
         subroutine spline(x,y,n,yp1,ypn,y2)
c
c   November 12, 1999
c
c   This is a spline interpolation routine taken from NUMERICAL RECIPES.
c
         implicit double precision (a-h,o-z)
c
         integer n,NMAX
c         REAL*8 yp1,ypn,x(n),y(n),y2(n)
         dimension x(n),y(n),y2(n)
         parameter(NMAX=10000000)
         integer i,k
c         REAL*8 p,qn,sig,un,u(NMAX)
         dimension u(NMAX)
         if(yp1.gt.0.99d30)then
           y2(1)=0.0
           u(1)=0.0
         else
           y2(1)=-0.5
           u(1)=(3.0/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
         endif
         do 11 i=2,n-1
           sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))
           p=sig*y2(i-1)+2.0
           y2(i)=(sig-1.0)/p
           u(i)=(6.0*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))
     @       /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*u(i-1))/p
 11      continue
         if(ypn.gt..99e30)then
           qn=0.0
           un=0.0
         else
           qn=0.5
           un=(3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
         endif
         y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.0)
         do 12 k=n-1,1,-1
           y2(k)=y2(k)*y2(k+1)+u(k)
 12      continue
         return
         end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
         subroutine splint(xa,ya,y2a,n,x,y)
c
c   November 12, 1999
c
c   This is a spline interpolation routine taken from Numerical Recipes.
c
         implicit double precision (a-h,o-z)
c
         integer n
c         real*8 x,y,xa(n),y2a(n),ya(n)
         dimension xa(n),y2a(n),ya(n)
         integer k,khi,klo
c         real*8 a,b,h
         klo=1
         khi=n
 1       if(khi-klo.gt.1)then
           k=(khi+klo)/2
           if(xa(k).gt.x)then
             khi=k
           else
             klo=k
           endif
           go to 1
         endif
         h=xa(khi)-xa(klo)
         if(h.eq.0.0)then
           write(*,*)'bad xa input in splint'
           stop
         endif
         a=(xa(khi)-x)/h
         b=(x-xa(klo))/h
         y=a*ya(klo)+b*ya(khi)+
     $     ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.0
         return
         end
c
c     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
         subroutine fastsplint(xa,ya,y2a,n,x,y,klo,khi)
c
c   November 12, 1999
c
c   This is a spline interpolation routine taken from Numerical Recipes.
c
         implicit double precision (a-h,o-z)
c
         integer n
         dimension xa(n),y2a(n),ya(n)
         integer k,khi,klo
c
 1       if(khi-klo.gt.1)then
           k=(khi+klo)/2
           if(xa(k).gt.x)then
             khi=k
           else
             klo=k
           endif
           go to 1
         endif
         h=xa(khi)-xa(klo)
         if(h.eq.0.0d0)then
           write(*,*)klo,khi,n
           write(*,*) 'bad xa input in fastsplint'
           stop
         endif
         a=(xa(khi)-x)/h
         b=(x-xa(klo))/h
         y=a*ya(klo)+b*ya(khi)+
     $     ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.0d0
         return
         end
c
c   &&&&&&&&&&&&&&&&&
c
c   UPDATE December 24, 2012
c
c   comment out for now
c
c          subroutine simpson1(N,x,y,xend,yend,total,dphi)
cc
cc    April 2, 2001
cc
cc   This routine will sum the y-values in y(1:N) using splines.
cc
c          implicit double precision (a-h,o-z)
c          dimension y(N),x(N),xend(2),yend(2),y2(1000)
c          dimension xdummy(1000),ydummy(1000),w(8),wx(8)
cc
cc
c          xdummy(1)=xend(1)
c          ydummy(1)=yend(1)
cc
c          do 10 i=1,N
c            xdummy(i+1)=x(i)
c            ydummy(i+1)=y(i)
c 10       continue
cc
c          xdummy(N+2)=xend(2)
c          ydummy(N+2)=yend(2)
cc
c          newN=N+2
cc
c          yp1=1.0d31
c
c          call spline(xdummy,ydummy,newN,yp1,yp1,y2)
cc
c          m=8*newN+1
cc
cc
c          total=0.0d0
cc
c          wx(1)=0.9602898565d0
c          wx(2)=-0.9602898565d0
c          w(1)=0.1012285363d0
c          w(2)=0.1012285363d0
cc
c          wx(3)=0.7966664774d0
c          wx(4)=-0.7966664774d0
c          w(3)=0.2223810345d0
c          w(4)=0.2223810345d0
cc
c          wx(5)=0.5255324099d0
c          wx(6)=-0.5255324099d0
c          w(5)=0.3137066459d0
c          w(6)=0.3137066459d0
cc
c          wx(7)=0.1834346425d0
c          wx(8)=-0.1834346425d0
c          w(7)=0.3626837834
c          w(8)=0.3626837834
cc
c          a=xdummy(1)
c          b=xdummy(newN)
cc
c          do 30 i=1,8
c            xxx=0.5d0*(b+a+wx(i)*(b-a))
c            call splint(xdummy,ydummy,y2,newN,xxx,yout)
c            total=total+w(i)*yout
c 30       continue
c          total=total*0.5d0*(b-a)
c          total=0.5d0*total/dphi
cc
c          return
c          end
cc
cc &&&&&&&&&&&&&&&&&&&&
cc
c
          double precision function diskxtran(xx,yy,zz,phase,
     &                fincr,Q,istar,bdist)
c
c   will return the coordinate of a point (xx,yy,zz) projected on the sky
c
c   (xx,yy,zz) refers to the coordinates in the rotating system
c
c   UPDATE March 26, 2002
c
c   The variables zz and fincr are not used in diskxtran (they are in
c   diskytran).  To suppress compiler warnings, define two fake variables
c   and assign their values to fincr and zz.  This is simpler than
c   changing the argument list of calls to diskxtran.
c
c   Also, get rid of historical text (comment out code).
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians

          qphaser=phaser
c
          diskxtran=-(xx*dsin(qphaser)+yy*dcos(qphaser))+
     $      bdist*(overQ/(1.0d0+overQ))*dsin(qphaser)
c
          return
          end
c
c  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          double precision function diskytran(xx,yy,
     &        zz,phase,fincr,Q,istar,bdist)
c
c   will return the coordinate of a point (xx,yy,zz) projected on the sky
c
c   (xx,yy,zz) refers to the coordinates in the rotating system
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians

          qphaser=phaser
c
          diskytran=-(-xx*dcos(fincr)*dcos(qphaser)+
     @      yy*dcos(fincr)*dsin(qphaser)
     $      -zz*dsin(fincr))+
     $     bdist*(-(overQ/(1.0d0+overQ))*dcos(fincr)*dcos(qphaser))
c
c          if(phaser.gt.180.0d0)ytran=-ytran
c
c   Added February 8, 2001
c
c          ytran=ytran*bdist
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   UPDATE March 26, 2002
c
c   Get rid of this unused routine.
c
c          subroutine loadspot(Ns1,Ns2,Nd,spot1parm,spot2parm,
c     %       spotdparm,ispot)
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine addstarspot(istar,ialphmax,ibetmax,
     $       Nalph,ibetlim,tmatrix,spotparm,ave1,ave2,
     %       phiar,mmdx,ispotprof)
c
c   This routine will assign the temperatures of the grid points
c   of the stars that are covered by spots.  The underlying temperatures
c   are simply scaled by the temperature spot factor.  
c   
c   UPDATE March 26, 2002
c
c   Get rid of Nbet from the argument list of addstarspot.  Its value
c   is contained within ibetlim.
c
c    UPDATE June 17, 2002
c
c    Add these dummy assignments for phase and omega to supress
c    compiler warnings about unused variables.
c
c    UPDATE October 13, 2008
c
c    Add ispotprof flag:
c
c    ispotprof=0    temperature factor same as before
c    ispotprof=1    linear profile for the temperature factor
c    ispotprof=2    Gaussian profile for temperature factor
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0)
          dimension tmatrix(ialphmax*ibetmax),phiar(ialphmax*ibetmax),
     %       ibetlim(ialphmax),spotparm(2,4),mmdx(ialphmax,ibetmax)
c
c
c    UPDATE June 17, 2002
c
c    Add these dummy assignments for phase and omega to supress
c    compiler warnings about unused variables.
c
          radcon=pie/180.0d0
          halfpie=0.5*pie
c
          fac1=spotparm(1,1)
          fac2=spotparm(2,1)
          rlat1=radcon*spotparm(1,2)-halfpie
          rlat2=radcon*spotparm(2,2)-halfpie
          rlong1=radcon*spotparm(1,3)
          rlong2=radcon*spotparm(2,3)
          if(rlong1.gt.pie)rlong1=rlong1-2.0d0*pie
          if(rlong2.gt.pie)rlong2=rlong2-2.0d0*pie
          rad1=radcon*spotparm(1,4)
          rad2=radcon*spotparm(2,4)
c
          if((fac1.lt.0.0d0).and.(fac2.lt.0.0d0))return !no valid factors
c
          dtheta=pie/dble(Nalph)
          summ1=0.0d0
          summ2=0.0d0
          icount1=0
          icount2=0
          icount3=0
          DO 10 IALF = 1, nalph
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            rlat=theta-halfpie
            DO 9 IBET = 1, ibetlim(ialf)    !4*NBET
c
              icount3=icount3+1
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              rlong=phiar(iidx)
              if(rlong.gt.pie)rlong=rlong-2.0d0*pie
c
              sepang1=dsin(rlat)*dsin(rlat1)+dcos(rlat)*dcos(rlat1)*
     %           dcos(rlong-rlong1)
              sepang1=dabs(dacos(sepang1))
              if((sepang1.le.rad1).and.(fac1.gt.0.0d0))then
                if(ispotprof.eq.0)then
                  icount1=icount1+1
                  tmatrix(iidx)=tmatrix(iidx)*fac1
                  summ1=summ1+tmatrix(iidx)
                endif
                if(ispotprof.eq.1)then
                  if(rad1.le.0.0d0)then
                    go to 9
                  else
                    icount1=icount1+1
                    slope=(1.0d0-fac1)/rad1
                    fff=slope*(sepang1-rad1)+1.0d0
                    tmatrix(iidx)=tmatrix(iidx)*fff
                    summ1=summ1+tmatrix(iidx)
                  endif
                endif
                if(ispotprof.eq.2)then
                  if(rad1.le.0.0d0)then
                    go to 9
                  else
                    icount1=icount1+1
                    fff=(fac1-1.0d0)*dexp(-4.5d0*(sepang1/rad1)**2)+1.0d0
                    tmatrix(iidx)=tmatrix(iidx)*fff
                    summ1=summ1+tmatrix(iidx)
                  endif
                endif
              endif
c
              sepang2=dsin(rlat)*dsin(rlat2)+dcos(rlat)*dcos(rlat2)*
     %           dcos(rlong-rlong2)
              sepang2=dabs(dacos(sepang2))
              if((sepang2.le.rad2).and.(fac2.gt.0.0d0))then
                if(ispotprof.eq.0)then
                  icount2=icount2+1
                  tmatrix(iidx)=tmatrix(iidx)*fac2
                  summ2=summ2+tmatrix(iidx)
                endif
                if(ispotprof.eq.1)then
                  if(rad2.le.0.0d0)then
                    go to 9
                  else
                    icount2=icount2+1
                    slope=(sepang2-fac2)/rad2
                    fff=slope*(1.0d0-rad2)+1.0d0
                    tmatrix(iidx)=tmatrix(iidx)*fff
                    summ2=summ2+tmatrix(iidx)
                  endif
                endif
                if(ispotprof.eq.2)then
                  if(rad2.le.0.0d0)then
                    go to 9
                  else
                    icount2=icount2+1
                    fff=(fac2-1.0d0)*dexp(-4.5d0*(sepang2/rad2)**2)+1.0d0
                    tmatrix(iidx)=tmatrix(iidx)*fff
                    summ2=summ2+tmatrix(iidx)
                  endif
                endif
              endif

 9          continue
 10       continue
c
          ave1=0.0d0
          ave2=0.0d0
          if(icount1.gt.0)ave1=summ1/dble(icount1)
          if(icount2.gt.0)ave2=summ2/dble(icount2)

          if(ave1.gt.0.0d0)write(2,100)istar,ave1,icount1,icount3
          if(ave2.gt.0.0d0)write(2,101)istar,ave2,icount2,icount3

c
 100      format(/'star ',i1,', spot 1:    average temperature ',
     &       f9.3,',',/19x,'number of grid points = ',i6,' out of ',i6)
 101      format(/'star ',i1,', spot 2:    average temperature ',
     &       f9.3,',',/19x,'number of grid points = ',i6,' out of ',i6)
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   UPDATE March 26, 2002
c
c   Remove betarim, separ, tdisk, xi, dx, dy, dz, drad, 
c   xedge, yedge, zedge, stepr, stepz, bdist, omega, phase
c   from the argument list, and from the appropriate dimension
c   statements below.
c
          subroutine adddiskspot(Nthetamax,Nrmax,Ntheta,Nradius,
     %       rinner,router,reff2,Rl2,dtemp,tedge,redge,ivrt,reper,rsper,
     @       spotparm,ave1,ave2)
c
c   May 8, 2001
c
c   This routine will modify the temperatures on the disk that are
c   within spots.
c
          implicit double precision(a-h,o-z)
c
          parameter (pie=3.14159265358979323d0)
          dimension dtemp(Nrmax*Nthetamax),tedge(Nthetamax*11)
          dimension spotparm(2,4)
c
c   Start with the disk face.  It is assumed that the lower face is exactly
c   the same as the upper face, but with a negative z-value.  In practice,
c   however, we never see the bottom face.
c          
          radcon=pie/180.0d0
c
          if(ivrt.eq.0)then
            redge=router*reff2              ! radius of outer edge in x units
            rsmall=rinner*Rl2               ! radius of inner edge in x units
            reper=redge
            rsper=rsmall
          else
            redge=reper
            rsmall=rsper
          endif
c
          fac1=spotparm(1,1)
          az1=radcon*spotparm(1,2)
          cut1=spotparm(1,3)
          width1=radcon*spotparm(1,4)
c
          fac2=spotparm(2,1)
          az2=radcon*spotparm(2,2)
          cut2=spotparm(2,3)
          width2=radcon*spotparm(2,4)
c

          steptheta=360.0d0/dble(ntheta)
c
c   Transform r into zeta.
c
          zetain=2.0d0*dsqrt(rsmall)
          zetaout=2.0d0*dsqrt(redge)
          stepzeta=(zetaout-zetain)/dble(Nradius-1)
c
          theta=0.0d0
          zeta=zetain
          icount1=0
          icount2=0
          summ1=0.0d0
          summ2=0.0d0
c
          if((cut1.ge.1.0d0).and.(cut2.ge.1.0d0))go to 99
          if((cut1.ge.1.0d0).and.(fac2.le.0.0d0))go to 99
          if((cut2.ge.1.0d0).and.(fac1.le.0.0d0))go to 99
c
          do 10 ir=1,Nradius
            zeta=zetain+dble(ir-1)*stepzeta
            r=0.25d0*zeta*zeta
            ratt=r/redge
            do 9 ithet=1,Ntheta              ! theta goes from zero to 360-step
              theta=dble(ithet)*steptheta -0.5*steptheta  ! degrees
              thetar=theta*radcon            ! radians
              angdiff1=dacos(dcos(thetar-az1))
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(ir-1)*Ntheta+ithet
c

              if((angdiff1.le.width1).and.(fac1.gt.0.0d0).and.
     @            (ratt.ge.cut1))then
                dtemp(iidx)=dtemp(iidx)*fac1
                icount1=icount1+1
                summ1=summ1+dtemp(iidx)
              endif
              angdiff2=dacos(dcos(thetar-az2))
              if((angdiff2.le.width2).and.(fac2.gt.0.0d0).and.
     @            (ratt.ge.cut2))then
                dtemp(iidx)=dtemp(iidx)*fac2
                icount2=icount2+1
                summ2=summ2+dtemp(iidx)
              endif
 9          continue
 10       continue
c
 99       do 20 iz=-5,5
            do 19 ithet=1,Ntheta             ! theta goes from zero to 360-step
              theta=dble(ithet)*steptheta-0.5*steptheta   ! degrees
              thetar=theta*radcon         ! radians
              angdiff1=dacos(dcos(thetar-az1))
c
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=(iz+6-1)*Ntheta+ithet
c
              if((angdiff1.le.width1).and.(fac1.gt.0.0d0))then
                tedge(iidx)=tedge(iidx)*fac1
                icount1=icount1+1
                summ1=summ1+tedge(iidx)
              endif
              angdiff2=dacos(dcos(thetar-az2))
              if((angdiff2.le.width2).and.(fac2.gt.0.0d0))then
                tedge(iidx)=tedge(iidx)*fac2
                icount2=icount2+1
                summ2=summ2+tedge(iidx)
              endif
 19         continue
 20       continue
c
          ave1=0.0d0
          ave2=0.0d0
          if(icount1.gt.0)ave1=summ1/dble(icount1)
          if(icount2.gt.0)ave2=summ2/dble(icount2)

          if(ave1.gt.0.0d0)write(2,100)ave1,icount1
          if(ave2.gt.0.0d0)write(2,101)ave2,icount2
c
 100      format(/'disk spot 1:    average temperature ',
     &       f9.3,',  number of grid points = ',i4)
 101      format(/'disk spot 2:    average temperature ',
     &       f9.3,',  number of grid points = ',i4)
c
          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine gravexp(teff,tgrav,istar)
c 
c   May 16, 2001
c
c   This routine will return a value of the gravity darkening exponent
c   Tgrav based on the input effective temperature teff.
c
c   Reference:  A. Claret, 2000, A&A, 359, 289
c
          implicit double precision (a-h,o-z)
c
          dimension xarray(45),yarray(45),y2(45)
c
c   xarray = log(t),  yarray = beta_1, where Tgrav=beta_1/4.0
c

          data xarray/3.3010,3.3640,3.4217,3.4490,3.4849,3.5097,3.5180,3.5361,
     $     3.5470,3.5640,3.5920,3.6280,3.6633,3.7031,3.7424,3.7557,
     $     3.7707,3.7844,3.7964,3.8116,3.8251,3.8458,3.8553,3.8648,
     $     3.8736,3.8802,3.8868,3.8912,3.8956,3.9022,3.9088,3.9491,
     $     4.0249,4.0960,4.1630,4.2285,4.2891,4.3468,4.4008,4.4551,
     $     4.4966,4.5376,4.5749,4.6072,4.6350/
c
          data yarray/0.2150,0.2200,0.2150,0.2000,0.1900,0.1800,0.1700,0.1800,
     $     0.1800,0.1900,0.2300,0.3400,0.4100,0.4345,0.4048,0.3888,
     $     0.3675,0.3463,0.3239,0.3004,0.2753,0.2499,0.2047,0.1599,
     $     0.1731,0.3150,0.5862,0.7292,0.8160,0.9350,0.9435,0.9857,
     $     0.9985,0.9962,1.0000,1.0000,1.0000,1.0000,1.0000,1.0000,
     $     1.0000,1.0000,1.0000,1.0000,1.0000/
c
          tlog=dlog10(teff)
c
          if(tlog.lt.3.301d0)then
            tgrav=0.25d0*0.2150
            write(2,100)istar,tgrav
            return
          endif
c
          if(tlog.gt.4.2d0)then
            tgrav=0.25d0
            write(2,100)istar,tgrav
            return
          endif
c
c   Set up the splines.
c
          yp1=1.0d31
          call spline(xarray,yarray,45,yp1,yp1,y2)
          call splint(xarray,yarray,y2,45,tlog,yout)
c
          tgrav=0.25d0*yout
          write(2,100)istar,tgrav
c
 100      format('Info:  The gravity darkening exponent for star',i1,
     $      ' has been set to ',f9.7)
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c
c   UPDATE March 26, 2002
c
c   Remove rpole1,rpole2,fill1,fill2 from the argument list.
c
          subroutine lineparms1(Teff2,Q,
     %        finc,separ,period,reff1,reff2,
     $        vrot1,vrot2,omega1,omega2,
     $        bdist,ecc,SA3,ave11,ave12,ave21,ave22,ave1,ave2,parmstring,
     $        pot1,pot2,rdepth,tertQ,argper)
c
c   July 13, 2001
c
c   This subroutine is similar to parms1, except that it writes the
c   computed physical quantities on a single line.
c
c
c   UPDATE September 11, 2001
c
c   Change the dimension of obsparm to 9.
c
c   UPDATE January 16, 2001
c
c   add pot1,pot2 to the end of the list
c
          implicit double precision(a-h,o-z)
c
c   UPDATE March 26, 2002
c
c   obsparm is not used here, so comment out its declaration.
c
c          dimension obsparm(9)
c
c   UPDATE November 28, 2001
c
c   Change parmstring from character*199 to character*201
c
c
c   UPDATE January 16, 2002
c
c   parmstring was character*201, now should be character*227
c
c   UPDATE June 7, 2002
c
c   Make the length of parmstring 237
c
c
c   UPDATE October 28, 2002
c
c   Make the length of parmstring character*249
c
c   UPDATE October 22, 2008
c
c   Make the length of parmstring character*259
c
c   UPDATE March 15, 2011
c
c   Make obsparm dimension 18
c
          character*1000 parmstring
c
          parameter(pie=3.14159265358979323d0)
c
           fincr=finc*3.141592653589879d0/180.0d0        ! radians
c           ppp=period*24.0d0               ! period in hours
           sifinc=dsin(fincr)
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
c           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
c
c   Use the value of GM_sun found from the solar system.
c
           gmsun=1.32712440018d20  !mks units
           solarrad=6.9598d8
           p=period*86400.0d0
           rM1=(separ*solarrad)**(3)*4.0d0*pie*pie
           rM1=rM1/(gmsun*p*p*(1.0d0+Q))
           rM2=Q*rM1
c 
           R1=reff1*separ
           if(Teff2.gt.0.0d0)then
             R2=reff2*separ
           else
             R2=0.00d0
           endif
c
           gsun=2.739910d4
           gpole1=gsun*rM1/(R1*R1)  
           if(Teff2.gt.0.0d0)then
             gpole2=gsun*rM2/(R2*R2)  
           else
             gpole2=1.0d0
           endif
c
c           gscale1=27397.726d0*rM1/(separ*separ*bdist*bdist)
c           gscale2=27397.726d0*rM2/(separ*separ*bdist*bdist)
c
           fact=solarrad*2.0d0*pie/86400.0d0/1.0d3  !50.613093d0
c
           vrot1=fact*R1/period*sifinc
           vrot2=fact*R2/period*sifinc
c
           a2=separ/(1.0d0+Q)*bdist
c
c   UPDATE September 12, 2001
c 
c   Bug fix, change a1=(separ-a2)*bdist  to  a1=separ(1.0d0-bdist/(1.0d0+Q))
c

           a1=separ*(1.0d0-bdist/(1.0d0+Q))
c
c   UPDATE MARCH 4, 2005
c
c   Change a2 and a1 below.
c
           a2=separ/(1.0d0+Q)
           a1=separ-a2
           efact=1.0d0/dsqrt(1.0-ecc*ecc)
           velK1=fact*a1/period*sifinc*efact
           velK2=fact*a2/period*sifinc*efact
c
           ttt=SA3
           if(ttt.lt.0.0d0)ttt=0.0d0
           R3=R1*dsqrt(ttt)

c
c   NEW BUG August 10, 2001
c
c   Add a correction factor to the rotational velocities in the
c   case of eccentric orbits.
c
           hutfac=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
     @          0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
     $          3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
c
c   UPDATE January 16, 2001
c
c   add pot1,pot2 to the end of the list
c
c   UPDATE OCTOBER 21, 2005
C
C   Modify pot2 for consistency with ELC.out.
c
c  UPDATE DECEMBER 10, 2010
c
c  Add the impact parameter
c
           rimpact1=dcos(fincr)*separ/R1
           if(rimpact1.lt.1.0d0)then
             term1=sqrt((1.0d0+R2/R1)**2-
     @           rimpact1**2)
           else
             term1=0.0d0
           endif
           term2=period*R1/(pie*separ
     @         *sqrt(1.0d0-ecc*ecc))
           term3=(1.0d0-ecc*ecc)/(1.0d0-ecc*dcos(argper*pie/180.0d0))
           duration=term1*term2*term3*24.0d0

           term1=1.0d0-rimpact1**2
           term2=1.0d0-(dcos(fincr))**2
           term3=dsqrt(term1/term2)*R1/separ

           if(dabs(term3).le.1.0d0)then
             duration1=period/3.141592653589793d0*dasin(term3)
           else
             duration1=0.0d0
           endif

           overQ=1.0d0/Q
           pppp=pot2/overQ+0.5d0*(overQ-1.0d0)/overQ
c
           if(tertQ.ne.0.0d0)then
             rM3=(rM1+rM2)/tertQ
           else
             rM3=0.0d0
           endif
c
           write(parmstring,5000)rM1,rM2,R1,R2,R3,
     $        dlog10(gpole1),dlog10(gpole2),
     @        a1,a2,separ,velk1,velk2,vrot1,vrot2,
     $        vrot1*omega1*hutfac,vrot2*omega2*hutfac,
     $        ave11,ave12,ave21,ave22,ave1,ave2,pot1,pppp,
     @        rimpact1,duration,rdepth,duration1,rM3
c
c  UPDATE November 28, 2001
c
c  Change the format statement below.  The first field was 2(f7.4,1x)
c  and now should be 2(f8.4,1x)
c
c  UPDATE January 16, 2001
c
c  Add 2(f12.6,1x) to the end
c
c  UPDATE October 28, 2002
c 
c  Change the first two format statements to f11.8
c  Also change 2(f8.3,1x) at the end (velK) to 2(f10.5,1x)
c
 5000      format(2(f14.8,1x),3(f12.6,1x),2(f7.3,1x),3(f11.6,1x),
     @       2(f10.5,1x),4(f7.3,1x),6(f7.1,1x),2(f12.6,1x),(f9.6,1x),
     @       f9.6,1x,f9.7,1x,f9.6,2x,f14.8)
c
           return
           end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getXecl(Nhoriz,xhoriz,yhoriz,ixecl,Q,finc,bdist,
     @      phase,tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,
     @      isw7,tertOmega)
c
c   UPDATE September 10, 2001
c
c   This routine will check to see if the center of star 2 is eclipsed
c   by star 1.  ixecl=100 if eclipsed, zero otherwise.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xhoriz(Nhoriz),yhoriz(Nhoriz)
c
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c
          xp=xtran(bdist,0.0d0,0.0d0,phase,fincr,Q,istar,bdist) 
          yp=ytran(bdist,0.0d0,0.0d0,phase,fincr,Q,istar,bdist)
          xp=xp+xxoff
          yp=yp+yyoff
c
c   If we are looking at star 2 and there is a disk, then check to see if
c   the points are *inside* the top horizon of the disk.
c
          ixecl=-100
          iyes=-100
          call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
          if(iyes.eq.100)ixecl=100
c
          return
          end
c
c
c============================================================
c
          SUBROUTINE SORT2(N,RA,RB)
c
c   UPDATE September 10, 2001
c
c   This is a new subroutine, similar to sort3.
c
c   Taken from Numerical Recipes.
c
          implicit double precision(a-h,o-z)

          DIMENSION RA(N),RB(N)
c
          L=N/2+1
          IR=N
10        CONTINUE
          IF(L.GT.1)THEN
            L=L-1
            RRA=RA(L)
            RRB=RB(L)
c            rrc=rc(L)
          ELSE
            RRA=RA(IR)
            RRB=RB(IR)
c            rrc=rc(IR)
            RA(IR)=RA(1)
            RB(IR)=RB(1)
c            rc(IR)=RC(1)
            IR=IR-1
            IF(IR.EQ.1)THEN
              RA(1)=RRA
              RB(1)=RRB
c              rc(1)=rrc
              RETURN
            ENDIF
          ENDIF
          I=L
          J=L+L
20        IF(J.LE.IR)THEN
            IF(J.LT.IR)THEN
              IF(RA(J).LT.RA(J+1))J=J+1
            ENDIF
            IF(RRA.LT.RA(J))THEN
              RA(I)=RA(J)
              RB(I)=RB(J)
c              rc(i)=rc(j)
              I=J
              J=J+J
            ELSE
              J=IR+1
            ENDIF
            GO TO 20
          ENDIF
          RA(I)=RRA
          RB(I)=RRB
c          rc(i)=rrc
          GO TO 10
          END
c
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine simplerefl(ialphmax1,ibetmax1,Nalph1,ibetlim1,
     @      Nalph2,ibetlim2,xarray1,yarray1,zarray1,gradx1,grady1,
     @      gradz1,garray1,xarray2,yarray2,zarray2,gradx2,grady2,gradz2,
     @      garray2,temp1,temp2,dbolx,dboly,ilaw,alb1,alb2,teff1,teff2,
     @      Tgrav1,Tgrav2,rLx,iidint,redge,betarim,gpole1,gpole2,Tpole1,
     @      Tpole2,bdist,SA1,SA2,rad1,rad2,separ,mmdx1,mmdx2,ialphmax2,
     @      ibetmax2,isw25)
c
c    UPDATE March 22, 2002
c
c    This routine is a simplified and faster version of the detailed
c    reflection, valid for nearly spherical stars.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xarray1(ialphmax1*ibetmax1),yarray1(ialphmax1*ibetmax1),
     $      zarray1(ialphmax1*ibetmax1),
     &      gradx1(ialphmax1*ibetmax1),temp1(ialphmax1*ibetmax1),
     $      grady1(ialphmax1*ibetmax1),gradz1(ialphmax1*ibetmax1),
     %      garray1(ialphmax1*ibetmax1),
     $      ibetlim1(ialphmax1),rad2(ialphmax2*ibetmax2),
     $      ibetlim2(ialphmax2),rad1(ialphmax1*ibetmax1)
          dimension xarray2(ialphmax2*ibetmax2),yarray2(ialphmax2*ibetmax2),
     $      zarray2(ialphmax2*ibetmax2),
     &      gradx2(ialphmax2*ibetmax2),temp2(ialphmax2*ibetmax2),
     $      grady2(ialphmax2*ibetmax2),gradz2(ialphmax2*ibetmax2),
     %      garray2(ialphmax2*ibetmax2),mmdx1(ialphmax1,ibetmax1)
          dimension dbolx(8,2),dboly(8,2),mmdx2(ialphmax2,ibetmax2)
c
c
c   Start with star 1 and compute the flux from star 2.
c
          darkbolx1=dbolx(1,1)
          darkboly1=dboly(1,1)
          darkbolx2=dbolx(1,2)
          darkboly2=dboly(1,2)
          c1=0.5d0
c
c   Define the integrated  limb darkening coefficients.  The equation is
c
c   dint=2*pi*int_0^1{mu*(1-x*(1-mu))d(mu)}  for the linear law, etc.
c
          dint1=pie*(1.0d0-darkbolx1/3.0d0)
          dint2=pie*(1.0d0-darkbolx2/3.0d0)
          if((ilaw.eq.2).or.(ilaw.eq.12))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0+2.0d0*darkboly1/9.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0+2.0d0*darkboly2/9.0d0)
          endif
          if((ilaw.eq.3).or.(ilaw.eq.13))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/5.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/5.0d0)
          endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
          if((ilaw.eq.4).or.(ilaw.eq.14))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/6.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/6.0d0)
          endif
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            dint1=pie*(1.0d0-darkbolx1/3.0d0-darkboly1/6.0d0)
            dint2=pie*(1.0d0-darkbolx2/3.0d0-darkboly2/6.0d0)
          endif
c
          if(teff2.gt.0.0d0)then
            C1=(Tpole2/Tpole1)**(4)*(dint1/dint2)
            C1=C1*alb1/dint1
          endif
          DIV1 = gpole1    ! gravity at the pole
          DIV2 = gpole2    ! gravity at the pole
c
c   If teff2 < 0, we are in X-ray binary mode.  The parameter rLx is the
c   log10 of the X-ray luminosity.  Compute the bolometric luminosity
c   of star 1, and compute what surface area it would need to have a
c   luminosity equal to that of Lx.   Put this fake surface area as
c   the area of star 2
c
          if(teff2.le.0.0d0)then
            sigma=5.675d-5
            rbol=SA1*(separ*6.9598d10)**2*sigma*teff1**4
            SA2=SA1*10.0d0**(rLx)/rbol
c            SA2=SA1*rLx
            C1=alb1/dint2
          endif
          diff1max=-1.0d0
          diff2max=-1.0d0
c
          T4g2=4.0d0*Tgrav2
          T4g1=4.0d0*Tgrav1

          do 10 ialf=1,Nalph1/2  !Nalph1/2,1,-1
            do 9 ibet=1,ibetlim1(ialf)/2  !4*Nbet1
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim1(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim1)+ibet
              iidx=mmdx1(ialf,ibet)
c
              summ=0.0d0
              term1=(bdist-xarray1(iidx))*gradx1(iidx)
     $                   -(yarray1(iidx))*grady1(iidx)
     @                   -(zarray1(iidx))*gradz1(iidx)
              if(term1.le.0.0d0)go to 10
c
              dist1=dsqrt(rad1(iidx)**2+
     $              bdist*(bdist-2.0d0*xarray1(iidx)))
              foreshort1=(term1/(dist1)) 
c
              summ=foreshort1*(0.25d0*SA2)*(dint2/pie)/(dist1*dist1)
c
c   UPDATE August 7, 2008
c
c   If the flag isw25 is 0, then
c   Add a foreshortening correction for the X-ray heating (the disk
c   is assumed to be a thin disk in the plane, not a point source).
c
c   If isw25 = 1, then assume a point source.
c
              if((teff2.lt.0.0d0).and.(isw25.eq.0))then
                xA=xarray1(iidx)
                yA=yarray1(iidx)
                zA=zarray1(iidx)
                xB=bdist
                yB=0.0d0
                zB=0.0d0
                dist=dsqrt(xA*xA+yA*yA+(zA-bdist)*(zA-bdist))
                xshort=dabs(zA)/dist
                summ=summ*xshort
              endif
c
              if((iidint.ge.1))then
                zrim=redge*dtan(betarim*0.017453293d0)
                xA=xarray1(iidx)
                yA=yarray1(iidx)
                zA=zarray1(iidx)
                xB=bdist
                yB=0.0d0
                zB=0.0d0
                call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                if(summ.lt.0.0d0)summ=0.0d0
                if((zA.ge.0.0d0).and.(zcross.lt.zrim))summ=0.0d0
                if((zA.lt.0.0d0).and.(zcross.gt.-zrim))summ=0.0d0
              endif
c                           
              FpBoverFA=C1/((garray1(iidx)/div1)**(T4g1))*summ
              tnew=temp1(iidx)*(1.0d0+FpBoverFA)**0.25d0
              diff=tnew-temp1(iidx)
              if(diff.gt.diff1max)diff1max=diff
              temp1(iidx)=tnew
 9          continue
 10       continue
c
c   Now go to star 2 and compute the irradation from star 1
c
          if(teff2.le.0.0d0)go to 50
          C2=(Tpole1/Tpole2)**(4)*(dint2/dint1)
          C2=C2*alb2/dint2
c
          do 20 ialf=1,Nalph2/2  !Nalph2/2,1,-1
            do 19 ibet=1,ibetlim2(ialf)/2   !Nbet2
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim2(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim2)+ibet
c
              iidx=mmdx2(ialf,ibet)
              summ=0.0d0
              term1=(bdist-xarray2(iidx))*gradx2(iidx)
     $                   -(yarray2(iidx))*grady2(iidx)
     @                   -(zarray2(iidx))*gradz2(iidx)
              if(term1.le.0.0d0)go to 20
c
              dist1=dsqrt(rad2(iidx)**2+
     $          bdist*(bdist-2.0d0*xarray2(iidx)))

              foreshort1=(term1/(dist1))    

              summ=foreshort1*(0.25d0*SA1)*(dint1/pie)/(dist1*dist1)
c
              if((iidint.ge.1))then
                zrim=redge*dtan(betarim*0.017453293d0)
                xA=xarray2(iidx)
                yA=yarray2(iidx)
                zA=zarray2(iidx)
                xB=bdist
                yB=0.0d0
                zB=0.0d0
                call zheight(xA,yA,zA,xB,yB,zB,redge,zcross)
                if(summ.lt.0.0d0)summ=0.0d0
                if((zA.ge.0.0d0).and.(zcross.lt.zrim))summ=0.0d0
                if((zA.lt.0.0d0).and.(zcross.gt.-zrim))summ=0.0d0
              endif
c                           
              FpAoverFB=C2/((garray2(iidx)/div2)**(T4g2))*summ
              tnew=temp2(iidx)*(1.0d0+FpAoverFB)**0.25d0
              diff=tnew-temp2(iidx)
              if(diff.gt.diff2max)diff2max=diff
              temp2(iidx)=tnew
c
 19         continue
 20       continue
c
c   Now use symmetry to fill in the other quadrants on the star.  
c
 50       continue
c
          DO 401 IALF = 1, nalph1/2
            DO 400 IBET = 1, ibetlim1(ialf)/2
              I1=nalph1-(ialf-1)
              J2=ibetlim1(ialf)-(ibet-1)
              izz=ialf
              jzz=ibet
c              iidx=(izz-1)*ibetlim1(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim1)+jzz
              iidx=mmdx1(izz,jzz)
c
              izz=ialf
              jzz=j2
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              temp1(jjdx)=temp1(iidx)

              izz=I1
              jzz=ibet
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              temp1(jjdx)=temp1(iidx)
c
              izz=I1
              jzz=j2
c              jjdx=(izz-1)*ibetlim1(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim1)+jzz
              jjdx=mmdx1(izz,jzz)
              temp1(jjdx)=temp1(iidx)
 400        continue
401       CONTINUE
c
          if(teff2.le.0.0)go to 999
          DO 501 IALF = 1, nalph2/2
            DO 500 IBET = 1, ibetlim2(ialf)/2
              I1=nalph2-(ialf-1)
              J2=ibetlim2(ialf)-(ibet-1)
              izz=ialf
              jzz=ibet
c              iidx=(izz-1)*ibetlim2(ialf)+jzz
c              iidx=kount(ialphmax,izz,ibetlim2)+jzz
              iidx=mmdx2(izz,jzz)

              izz=ialf
              jzz=j2
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              temp2(jjdx)=temp2(iidx)

              izz=I1
              jzz=ibet
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              temp2(jjdx)=temp2(iidx)

              izz=I1
              jzz=j2
c              jjdx=(izz-1)*ibetlim2(ialf)+jzz
c              jjdx=kount(ialphmax,izz,ibetlim2)+jzz
              jjdx=mmdx2(izz,jzz)
              temp2(jjdx)=temp2(iidx)
 500        continue
501       CONTINUE
c
          if(diff2max.lt.0.0d0)diff2max=0.0d0
          if(diff1max.lt.0.0d0)diff1max=0.0d0

          write(2,72)diff2max
 999      write(2,71)diff1max
c
 71       format(/'maximum temperature change for star 1 = ',f13.5)
 72       format('maximum temperature change for star 2 = ',f13.5)

          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine rotkern(ialphmax,ibetmax,Nalf,ibetlim,istar,omega,
     @      phase,finc,Q,flum,xcoords,ycoords,flux,separ,period,gamma,
     $      ecc,argrad,visib,extension,mmdx)
c
c    UPDATE May 22, 2002
c
c    This routine will compute a rotational broadening kernel for
c    star istar.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)    
          dimension flum(ialphmax*ibetmax),xcoords(ialphmax*ibetmax),
     &      ycoords(ialphmax*ibetmax),ibetlim(ialphmax),
     &      visib(ialphmax*ibetmax),mmdx(ialphmax,ibetmax)
c
          dimension binx(1001),biny(1001),xscratch(10000)
          dimension yscratch(10000)
c
          character*9 extension
c
c
c    Check to see if the star has any flux before going further!
c        
          if(flux.le.0.0d0)return
c
          if(istar.eq.1)open(unit=98,file='star1rotkern.'//extension,
     %               status='unknown')
          if(istar.eq.2)open(unit=98,file='star2rotkern.'//extension,
     %               status='unknown')

          argfac=ecc*dcos(argrad)
          efact=1.0d0/dsqrt(1.0d0-ecc*ecc)
c          dint=rldint/pie
          vel=0.0d0
c          delvel=0.0d0
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
          siphase=dsin(phaser)
          cophase=dcos(phaser)
          sifinc=dsin(fincr)
c
c   Compute the expected K velocity, which is the circular velocity times 
c   dsin(finc).
c
c    
          a=separ*6.9598d5            !separation in km
          p=period*24.00d0*3600.00d0       !period in seconds
          velamp=2.0d0*pie*a/p*efact
c
c    First, find the limits of the minimum and maximum rotational
c    velocity on the star.
c
          rmin=123456.
          rmax=-123456.
          do 60 ialf=1,Nalf
            do 59 ibet=1,ibetlim(ialf)        !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              iidx=mmdx(ialf,ibet)
c
              v1=omega*(-xcoords(iidx)*siphase*sifinc-
     %            ycoords(iidx)*cophase*sifinc)
              if(v1*velamp.gt.rmax)rmax=v1*velamp
              if(v1*velamp.lt.rmin)rmin=v1*velamp
 59          continue
 60       continue
c
c   Next, define equal bins in velocity.
c
          nbin=501
          binsize=(rmax-rmin)/dble(nbin-1)
c
          do 1120 i=1,nbin
            binx(i)=dble(i-1)*binsize+rmin
            biny(i)=0.0d0
1120      continue
c
c   Finally, loop over the bins.
c   In the inner loop, loop over Nalph (go along latitude
c   rows) and save up curves of velocity and intensity.  In
c   general, these curves will either intersect the velocity
c   of the bin twice or not at all.  If there are intersections,
c   interpolate the intensities to the velocity of the bin velocity
c   and accumulate the sums.
c
            do 199 ialf=1,Nalf 
              do 190 ibet=1,ibetlim(ialf)
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c                iidx=(ialf-1)*ibetlim(ialf)+ibet
c                iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
                iidx=mmdx(ialf,ibet)
                v1=omega*(-xcoords(iidx)*siphase*sifinc-
     %             ycoords(iidx)*cophase*sifinc)
                xscratch(ibet)=velamp*v1
                if(visib(iidx).ne.0.0d0)then
                  yscratch(ibet)=flum(iidx)/visib(iidx)
                else
                  yscratch(ibet)=0.0d0
                endif
 190          continue
c
              xscratch(ibetlim(ialf)+1)=xscratch(1)
              yscratch(ibetlim(ialf)+1)=yscratch(1)
c
              icount=0

             do 200 i=1,nbin

              do 191 ibet=1,ibetlim(ialf)
                if(((binx(i).gt.xscratch(ibet)).and.
     $              (binx(i).le.xscratch(ibet+1))).or.
     &              ((binx(i).le.xscratch(ibet)).and.
     $              (binx(i).gt.xscratch(ibet+1))))then
                  x0=xscratch(ibet)
                  x1=xscratch(ibet+1)
                  y0=yscratch(ibet)
                  y1=yscratch(ibet+1)
                  xx=binx(i)
c
                  yy=((x1-xx)*y0+(xx-x0)*y1)/(x1-x0)
                  weight=0.666666666666666666
                  if(mod(ialf,2).eq.0)weight=1.3333333333333333
                  if((ialf.eq.1).or.(ialf.eq.Nalf))weight=0.333333333333
                  biny(i)=biny(i)+weight*yy
                  icount=icount+1
                  jcount=jcount+1
                endif
 191          continue

 200          continue
 199        continue
c
          area=0.0d0
          do 300 i=1,nbin
            area=area+binsize*biny(i)
 300      continue
c
          solarrad=6.9598d10
          vel=overQ/(1.0d0+overQ)*(siphase+argfac)*sifinc
          vel=velamp*vel+gamma
          do 301 i=1,nbin
            biny(i)=biny(i)/flux*(separ*solarrad)**2
            write(98,500)binx(i),biny(i),vel
 301      continue
c
          close(98)
c
 500      format(f12.6,2x,1pe16.9,0pf12.6)
          return
          end
c
c  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
c
c
          integer function kount(ialphmax,ialf,ibetlim)
c
c   June 11, 2003
c
c   this little function will keep track of the
c   index for the new 1D arrays.
c
          dimension ibetlim(ialphmax)
c
          kount=0
          if(ialf.le.1)then
            kount=0
            return
          endif
c
          kount=0
          do 10 i=2,ialf
            kount=kount+ibetlim(i-1)
 10       continue
c          
          return
          end
c
c @#$%*&%$@^@(*@&@(^@%@$%@!#@%&%^&*@$@#@
c
          subroutine getrefvisib(ialphmax,ibetmax,Nalf,ibetlim,phase,
     @      finc,gradx,grady,gradz,visib,projarray,mmdx)
c
c   June 16, 2003
c
c   This routine will return the 'reference visibilities' for use
c   in the EBOP mode.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension visib(ialphmax*ibetmax),
     $        gradx(ialphmax*ibetmax),grady(ialphmax*ibetmax),
     $        gradz(ialphmax*ibetmax),
     $        projarray(ialphmax*ibetmax),ibetlim(ialphmax),
     $        mmdx(ialphmax,ibetmax)
c
c  initialize the visibities!
c
          do 1 i=1,nalf
            do 2 j=1,ibetlim(i)  !4*nbet
c              iidx=(i-1)*ibetlim(i)+j
              iidx=mmdx(i,j)
              visib(iidx)=0.0d0
              projarray(iidx)=-1.0d0
 2          continue
 1        continue
c
c
c   RVG BUG ALERT   May 2, 2001
c
c   Change the definition of phaser to the simplified form below (i.e.
c   phaser is simply the phase in radians.
c
c          if(phase.gt.180.0d0)then
c            phaser=-(phase)*pie/180.0d0
c          else
            PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
c          endif
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
c
c   Check to see of the star in question is in front.  If so, then simply
c   find the projection factors.
c
c
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)      !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              PROJ = AX * GRADX(iidx) + AY*GRADY(iidx) + 
     @           AZ*GRADZ(iidx)
              projarray(iidx)=proj
              visib(iidx)=proj
c              write(*,*)istar,ialf,ibet,proj
c
 502        continue
 501      continue
          return
          end
c
c  *************************************************************************
c
c  *************************************************************************
c
          subroutine getrefBBflux(ialphmax,ibetmax,Nalf,ibetlim,
     $      wave,visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,
     &      flum,flux,rldint,
     &      separ,mmdx)
c
c     June 16, 2003
c 
c     This routine will return the 'reference BB flux' for use in
c     the EBOP mode.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension visib(ialphmax*ibetmax),
     $        surf(ialphmax*ibetmax),ibetlim(ialphmax),
     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     %        mmdx(ialphmax,ibetmax)
c

c
c   December 15, 2013:  add triangular sampling
c
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            savefx=flimbx
            savefy=flimby
            flimbx=2.0d0*dsqrt(savefx)*savefy
            flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
          endif
c
          rdint=pie*(1.0d0-flimbx/3.0d0)
          if((ilaw.eq.2).or.(ilaw.eq.12))then
            rdint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
          endif
          if((ilaw.eq.3).or.(ilaw.eq.13))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
          endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
          if((ilaw.eq.4).or.(ilaw.eq.14))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)
          endif
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            rdint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)
          endif

          wavemu=wave/10000.0d0
          C2 = 1.4384d8          ! 1.4384 * 10.**8      ! hc/(k*1e-8)
          C1 = 1.191044d35       ! 2hc^2/((1e-8)**5)
c
c   Initialize the flum matrix.
c
c
          c1=3.74185
          c2=14.3883

          flux=0.0d0
          do 2 ialf=1,nalf
            do 1 ibet=1,ibetlim(ialf)        !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              flum(iidx)=0.0d0
              rinty(iidx)=0.0d0
 1          continue
 2        continue
c
          DO 10 ialf=1,nalf
c            dphi=pie/dble(ibetlim(ialf))
            DO 9 ibet = 1,ibetlim(ialf)               !4*nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c 
              iidx=mmdx(ialf,ibet)
              if((projarray(iidx).le.0.0d0))go to 9
              tkkelv=temp(iidx)/1000.0d0
              C3 = C2/(wavemu*tkkelv)
              flum(iidx)=C1/(dexp(c3)-1.0d0)/wavemu**5
              dark=(1.0d0-flimbx+flimbx*projarray(iidx))
              if(ilaw.eq.2)dark=dark-flimby*projarray(iidx)*
     %               dlog(projarray(iidx))
              if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(iidx)))
              if(ilaw.eq.12)dark=dark-flimby*projarray(iidx)*
     %               dlog(projarray(iidx))
              if(ilaw.eq.13)dark=dark-flimby*(1.0-dsqrt(projarray(iidx)))
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
              if(ilaw.eq.4)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.14)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.5)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.15)dark=dark-flimby*(1.0-(projarray(iidx)))**2
c
              flum(iidx)=flum(iidx)*dark
              rinty(iidx)=flum(iidx) ! save intensities for plotting
              flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
              flux=flux+flum(iidx)
 9          continue
 10       continue
c
c   Scale the light curve by the integral of the limb darkening law
c   for compatibility with Wilson-Devinney.
c        
c   Scale the light curve by the integral of the limb darkening law
c   for compatibility with Wilson-Devinney.
c        
          flux=pie*flux/rdint
c
c
c   UPDATE April 3, 2002
c
c   Scale the fluxes.
c
          solarrad=6.9598d10
          flux=flux*(separ*solarrad)**2
c
          rldint=rdint
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
c
          subroutine getrefvel(istar,phase,finc,Q,separ,period,
     @       gamma,vel,ecc,argrad,isw12,gimvel,iRVfilt)
c
c    November 12, 1999
c
c    This routine will compute the flux-weighted radial velocity of the
c    star in question.
c
c
          implicit double precision(a-h,o-z)
c
          dimension gimvel(8)

          parameter(pie=3.14159265358979323d0)    
c
          argfac=ecc*dcos(argrad)
          efact=1.0d0/dsqrt(1.0d0-ecc*ecc)
c          dint=rldint/pie
          vel=0.0d0
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c
          siphase=dsin(phaser)
          sifinc=dsin(fincr)
c
c   Compute the expected K velocity, which is the circular velocity times 
c   dsin(finc).
c
c    
          a=separ*6.9598d5            !separation in km
          p=period*24.00d0*3600.00d0       !period in seconds
          velamp=2.0d0*pie*a/p*efact
          ppp = (PHASE/180.0d0)*pie    
          siphase=dsin(ppp)
          vel=overQ/(1.0d0+overQ)*(siphase+argfac)*sifinc
          if(isw12.gt.0)then
            vel=vel+gimvel(iRVfilt)
          endif
          vel=vel*velamp+gamma
          return
          end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&
c  &&&&&&&&&&&&&&&&&
c
          subroutine getrefATMflux(ialphmax,ibetmax,Nalf,ibetlim,visib,
     @      projarray,temp,surf,garray,rinty,flum,maxlines,maxmu,Nlines,
     &      atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @      atmint6,atmint7,atmint8,gscale,fluxU,fluxB,fluxV,fluxR,
     @      fluxI,fluxJ,fluxH,fluxK,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,
     @      icnK,iRVfilt,separ,mmdx,dwavex,dwavey,ilaw,iatm,istar)
c
c
c     June 16, 2003
c 
c     This routine will return the 'reference ATM flux' for use in
c     the EBOP mode.
c
          implicit double precision(a-h,o-z)

          parameter(pie=3.141592653589793d0)
c
c   Set these to the value of ialphmax,ibetmax
c
          integer tempalf,tempbet
          parameter(tempalf=3000,tempbet=3000,itab=tempalf*tempbet)

          dimension visib(ialphmax*ibetmax),ibetlim(ialphmax),
     $        surf(ialphmax*ibetmax),garray(ialphmax*ibetmax),
     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     &        mmdx(ialphmax,ibetmax)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8),
     @       corr1(8),corr2(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
          dimension dwavex(8,3),dwavey(8,3)
c  
c
          if(tempalf.lt.ialphmax)then
            write(*,*)'dimension error in getATMflux'
            stop
          endif
          if(tempbet.lt.ibetmax)then
            write(*,*)'dimension error in getATMflux'
            stop
          endif
c
          fluxU=0.0d0
          fluxB=0.0d0
          fluxV=0.0d0
          fluxR=0.0d0
          fluxI=0.0d0
          fluxJ=0.0d0
          fluxH=0.0d0
          fluxK=0.0d0
          corr1(1)=0.0d0
          corr1(2)=0.0d0
          corr1(3)=0.0d0
          corr1(4)=0.0d0
          corr1(5)=0.0d0
          corr1(6)=0.0d0
          corr1(7)=0.0d0
          corr1(8)=0.0d0
          corr2(1)=0.0d0
          corr2(2)=0.0d0
          corr2(3)=0.0d0
          corr2(4)=0.0d0
          corr2(5)=0.0d0
          corr2(6)=0.0d0
          corr2(7)=0.0d0
          corr2(8)=0.0d0
c
c   Initialize the flum matrix.
c
          do 2 ialf=1,nalf
            do 1 ibet=1,ibetlim(ialf)       !4*Nbet
c              iidx=(ialf-1)*4*Nbet+ibet
              iidx=mmdx(ialf,ibet)
              flum(iidx)=0.0d0
              rinty(iidx)=0.0d0
c              saveflum(iidx,1)=0.0d0
c              saveflum(iidx,2)=0.0d0
c              saveflum(iidx,3)=0.0d0
c              saveflum(iidx,4)=0.0d0
c              saveflum(iidx,5)=0.0d0
c              saveflum(iidx,6)=0.0d0
c              saveflum(iidx,7)=0.0d0
c              saveflum(iidx,8)=0.0d0
 1          continue
 2        continue
c
c   Find the rough place in the atmosphere table.
c
          Tin=temp(1)
          call locate(atmT,Nlines,Tin,indexT)
          itguess=indexT
c
c
          DO 10 ialf=1,nalf
            DO 9 ibet = 1,ibetlim(ialf)      !4*nbet
              iidx=mmdx(ialf,ibet)
c              dphi=pie/dble(ibetlim(ialf))
              if(projarray(iidx).le.0.0d0)go to 9
              Tin=temp(iidx)
              gin=dlog10(gscale*garray(iidx))
              rmuin=projarray(iidx)
              call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,atmT,
     @          atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,
     @          atmint6,atmint7,atmint8,outinty,
     &          icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,itguess,
     @          dwavex,dwavey,ilaw,iatm,istar)
c
              rinty(iidx)=outinty(iRVfilt) ! save intensities for plotting
c
              do 8 k=1,8
c                saveflum(iidx,k)=
c     @             outinty(k)*surf(iidx)*projarray(iidx)
                outinty(k)=outinty(k)*surf(iidx)*visib(iidx)
 8            continue
c
              fluxU=fluxU+outinty(1)
              fluxB=fluxB+outinty(2)
              fluxV=fluxV+outinty(3)
              fluxR=fluxR+outinty(4)
              fluxI=fluxI+outinty(5)
              fluxJ=fluxJ+outinty(6)
              fluxH=fluxH+outinty(7)
              fluxK=fluxK+outinty(8)
              izz=ialf
              jzz=ibet
              iidx=mmdx(izz,jzz)
              flum(iidx)=outinty(iRVfilt)+corr1(iRVfilt)+corr2(iRVfilt) 
 9          continue
 10       continue
c
c          if(darkint(1).ne.0.0d0)fluxU=pie*fluxU!/darkint(1)
c          if(darkint(2).ne.0.0d0)fluxB=pie*fluxB!/darkint(2)
c          if(darkint(3).ne.0.0d0)fluxV=pie*fluxV!/darkint(3)
c          if(darkint(4).ne.0.0d0)fluxR=pie*fluxR!/darkint(4)
c          if(darkint(5).ne.0.0d0)fluxI=pie*fluxI!/darkint(5)
c          if(darkint(6).ne.0.0d0)fluxJ=pie*fluxJ!/darkint(6)
c          if(darkint(7).ne.0.0d0)fluxH=pie*fluxH!/darkint(7)
c          if(darkint(8).ne.0.0d0)fluxK=pie*fluxK!/darkint(8)
c
c  UPDATE April 3, 2002
c
c  Scale the fluxes.
c
          solarrad=6.9598d10
          fluxU=fluxU*(separ*solarrad)**2
          fluxB=fluxB*(separ*solarrad)**2
          fluxV=fluxV*(separ*solarrad)**2
          fluxR=fluxR*(separ*solarrad)**2
          fluxI=fluxI*(separ*solarrad)**2
          fluxJ=fluxJ*(separ*solarrad)**2
          fluxH=fluxH*(separ*solarrad)**2
          fluxK=fluxK*(separ*solarrad)**2
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine overlaphoriz(Nhoriz1,xhoriz1,yhoriz1,
     $            Nhoriz2,xhoriz2,yhoriz2,ioverlap)
c
c   UPDATE May 26, 2004
c
c   This routine will take the horizons for star 1 and star 2 and
c   see if there is an overlap on the sky.  If so, then ioverlap=999
c         
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension xhoriz1(Nhoriz1),yhoriz1(Nhoriz1)
          dimension xhoriz2(Nhoriz2),yhoriz2(Nhoriz2)
c
          do 10 i=1,Nhoriz1
            iyes=-1
            xp=xhoriz1(i)
            yp=yhoriz1(i)
            call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,icut)
            if(iyes.eq.100)ioverlap=999
 10       continue
c
          do 20 i=1,Nhoriz2
            iyes=-1
            xp=xhoriz2(i)
            yp=yhoriz2(i)
            call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
            if(iyes.eq.100)ioverlap=999
 20       continue
c        
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c
c
      FUNCTION ran9(idum)
      INTEGER idum,IA,IM,IQ,IR,NTAB,NDIV
      double precision ran9,AM,EPS,RNMX
      PARAMETER (IA=16807,IM=2147483647,AM=1./IM,IQ=127773,IR=2836,
     $     NTAB=32,NDIV=1+(IM-1)/NTAB,EPS=3.e-16,RNMX=1.-EPS)
      INTEGER j,k,iv(NTAB),iy
      SAVE iv,iy
      DATA iv /NTAB*0/, iy /0/
      if (idum.le.0.or.iy.eq.0) then
         idum=max(-idum,1)
         do j=NTAB+8,1,-1
            k=idum/IQ
            idum=IA*(idum-k*IQ)-IR*k
            if (idum.lt.0) idum=idum+IM
            if (j.le.NTAB) iv(j)=idum
         enddo
         iy=iv(1)
      endif
      k=idum/IQ
      idum=IA*(idum-k*IQ)-IR*k
      if (idum.lt.0) idum=idum+IM
      j=1+iy/NDIV
      iy=iv(j)
      iv(j)=idum
      ran9=min(AM*iy,RNMX)
      return
      END
c
c  *****************************************
c
          subroutine sobseq(n,x)
          integer n,MAXBIT,MAXDIM
          double precision x
          dimension x(*)
          parameter(MAXBIT=30,MAXDIM=6)
          integer i,im,in,ipp,j,k,l,ip(MAXDIM),iu(MAXDIM,MAXBIT),
     $       iv(MAXBIT*MAXDIM),ix(MAXDIM),mdeg(MAXDIM)
          double precision fac
          SAVE ip,mdeg,ix,iv,in,fac
          equivalence (iv,iu)
          data ip /0,1,1,2,1,4/, mdeg/1,2,3,3,4,4/, ix/6*0/
          data iv /6*1,3,1,3,3,1,1,5,7,7,3,3,5,15,11,5,15,13,9,156*0/
c
c
          if(n.eq.-1)then
            in=0
c
            do 55 ll=1,MAXDIM
              do 54 mm=1,MAXBIT
                iu(ll,mm)=0
 54           continue
 55         continue
c
            do 99 kkk=1,6
              ix(kkk)=0
              iv(kkk)=1
 99         continue

            iv(7)=3
            iv(8)=1
            iv(9)=3
            iv(10)=3
            iv(11)=1
            iv(12)=1
            iv(13)=5
            iv(14)=7
            iv(15)=7
            iv(16)=3
            iv(17)=3
            iv(18)=5
            iv(19)=15
            iv(20)=11
            iv(21)=5
            iv(22)=15
            iv(23)=13
            iv(24)=9
c
            do 66 kkk=0,155
              iv(kkk+25)=0
 66         continue
c
          endif
c
          if(n.lt.0)then
            do 14  k=1,MAXDIM
              do 11 j=1,mdeg(k) 
                iu(k,j)=iu(k,j)*2**(MAXBIT-j)
 11           continue
              do 13 j=mdeg(k)+1,MAXBIT
                ipp=ip(k) 
                i=iu(k,j-mdeg(k))
                i=ieor(i,i/2**mdeg(k))
                do 12 l=mdeg(k)-1,1,-1
                  if(iand(ipp,1).ne.0)i=ieor(i,iu(k,j-l))
                  ipp=ipp/2
 12             continue
                iu(k,j)=i
 13           continue
 14         continue
            fac=1.0d0/2.0d0**MAXBIT
            in=0
          else
            im=in
            do 15 j=1,MAXBIT 
              if(iand(im,1).eq.0)go to 1
              im=im/2
 15         continue
            write(*,*) 'MAXBIT too small in sobseq'
            stop
 1          im=(j-1)*MAXDIM
            do 16 k=1,min(n,MAXDIM)
              ix(k)=ieor(ix(k),iv(im+k))
              x(k)=ix(k)*fac
 16         continue
            in=in+1
          endif
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine setscale(Q,finc,Teff2,Period,separ,
     &       primmass,primK,primrad,sw5,ecc)
c
c   August 10, 2004
c
c   This a new subroutine to set constraints specified by the
c   new variables primmass, primK, etc.
c
          implicit double precision (a-h,o-z)  

c   We can set most of the constraints specified by primmas, primK,
c   primrad here.  ratrad needs to be dealt with in getinput.
c
c   There are various combinations of parameters that one can adjust,
c   and depending on which constraints are specified, different
c   ways are used:
c
c   if sw5 > 0, then bail out (MSP mode).
c
c   primmass > 0 only:  set the separation.
c   primK > 0 only:     compute f(M), use getradius() to set separation.
c   primrad > 0 only:   scale the separation
c
c
c
          parameter(pie=3.14159265358979323d0)
c
           solarmass=1.9889d33
c           smmks=1.9889d30    !solar mass in kg
           solarrad=6.9598d10
           Gcgs=6.67259d-8     !G in cgs
c           Gmks=6.67259d-11   !G in mks
           p=period*24.0d0*3600.0d0
           gmsun=1.32712440018d20  !mks units
c
c 
c   MSP mode:
c
c   Add the variable sw5 to the argument list.  If teff2 < 0 and
c   sw5 > 0, then the separation will be set as follows:
c
c   rkns = 2*pie*sw5*c/Period   ! K-velocity of pulsar, if sw5 is
c                                  projected semimajor axis in seconds
c
           if((teff2.le.0.0d0).and.(sw5.gt.0.0d0))then
             speedlight=2.997924548d5
             rkns=2.0d0*pie*sw5*speedlight/Period
             efact=dsqrt(1.0d0-ecc*ecc)
c
c   UPDATE November 14, 2008
c
c   If primK >0, set the mass ratio
c
             if(primK.gt.0.0d0)Q=primK*86400.0d0/(rkns*efact)
             vkcgs=primK*100000.0d0*efact
             fincr=finc*pie/180.0d0
c             write(*,*)p,q
             separ=vkcgs*p*(1.0d0+Q)/(2.0*pie*dsin(fincr)*Q)/solarrad
             separ=(Q+1.0d0)*sw5*speedlight/(dsin(fincr))/solarrad
             separ=separ*1.0d5
             write(2,199)separ
             if(primK.gt.0.0d0)write(2,1999)primK,Q
c             write(*,*)separ,vkcgs,finc,fincr
             return
           endif
c
  199      format('Info:  MSP mode:  separation has been set to ',
     %         f13.7,7x,' solar radii')
 1999      format('Info:  MSP mode:  primK = ',f13.7,
     @         ' the mass ratio has'/,
     @         6x,' been set to',f13.7)
c
c   primmass > 0 only
c
           if((primmass.gt.0.0d0).and.(primK.le.0.0d0).and.
     $       (primrad.le.0.0d0))then
             rmass=primmass*solarmass
             separ=(Gcgs*p*p*(1.0d0+Q)*rmass
     $          /(4.0d0*pie*pie))**(1.d0/3.0d0)/solarrad
c
             separ=(gmsun*p*p*primmass*(1.0d0+Q)/(4.0d0*pie*pie))
     @           **(1.0d0/3.0d0)
             separ=separ/solarrad*100.0d0
             write(2,1199)primmass,separ
             return
           endif
c
c   primmass > 0 and primrad > 0
c
           if((primmass.gt.0.0d0).and.(primK.le.0.0d0).and.
     $       (primrad.gt.0.0d0))then
             rmass=primmass*solarmass
             separ=(Gcgs*p*p*(1.0d0+Q)*rmass
     $          /(4.0d0*pie*pie))**(1.d0/3.0d0)/solarrad
c
             separ=(gmsun*p*p*primmass*(1.0d0+Q)/(4.0d0*pie*pie))
     @          **(1.0d0/3.0d0)
             separ=separ/solarrad*100.0d0
             write(2,1199)primmass,separ
             return
           endif
c
c   primK > 0 only
c
           if((primmass.le.0.0d0).and.(primK.gt.0.0d0).and.
     $       (primrad.le.0.0d0))then
c
c   UPDATE NOVEMBER 1
c
c   add the efact  =  dsqrt(1-e*e)
c
             efact=dsqrt(1.0d0-ecc*ecc)
             vkcgs=primK*100000.0d0*efact
             fincr=finc*pie/180.0d0
             separ=vkcgs*p*(1.0d0+Q)/(2.0*pie*dsin(fincr)*Q)/solarrad
c             fm=p*(vkmks**3.0)/(2.0d0*pie*Gmks)/smmks
c             call getradius(Q,finc,rad_in_cm,fm,period,ecc)
c             separ=rad_in_cm/solarrad
             write(2,1188)primK,separ
             return
           endif
c
c
c   primK > 0 and primrad > 0
c
           if((primmass.le.0.0d0).and.(primK.gt.0.0d0).and.
     $       (primrad.gt.0.0d0))then
c
c   UPDATE NOVEMBER 1
c
c   add the efact  =  dsqrt(1-e*e)
c
             efact=dsqrt(1.0d0-ecc*ecc)
             vkcgs=primK*100000.0d0*efact
             fincr=finc*pie/180.0d0
             separ=vkcgs*p*(1.0d0+Q)/(2.0*pie*dsin(fincr)*Q)/solarrad
c             fm=p*(vkmks**3.0)/(2.0d0*pie*Gmks)/smmks
c             call getradius(Q,finc,rad_in_cm,fm,period,ecc)
c             separ=rad_in_cm/solarrad
             write(2,1188)primK,separ
             return
           endif
c

c   primrad > 0 only
c
c           if((primmass.le.0.0d0).and.(primK.le.0.0d0).and.
c     $       (primrad.gt.0.0d0))then
c               separ=primrad/reff1
c               return
c           endif
c
c   primmass > 0 and primK > 0.  Solve for Q and separ
c
           if((primmass.gt.0.0d0).and.(primK.gt.0.0d0))then
             rmass=primmass*solarmass
c
c
c   UPDATE NOVEMBER 1
c
c   add the efact  =  dsqrt(1-e*e)
c
             efact=dsqrt(1.0d0-ecc*ecc)
c
             dqhi=7.
             dqlo=-7.
             do 555 kk=1,35
               Qhigh=10.0d0**dqhi
               Qlow=10.0d0**dqlo
               Qmid=10.0**((dqhi+dqlo)*0.5d0)
               aa=vfcn(Qlow,period,finc,primmass,primK,ecc)
c               bb=vfcn(Qhigh,period,finc,primmass,primK,ecc)
               cc=vfcn(Qmid,period,finc,primmass,primK,ecc)
               if(aa*cc.lt.0.0d0)then
                 dqhi=(dqhi+dqlo)*0.5d0
               else
                 dqlo=(dqhi+dqlo)*0.50
               endif
 555           continue
c
             do 556 kk=1,25
               Qmid=(Qhigh+Qlow)*0.5d0
               aa=vfcn(Qlow,period,finc,primmass,primK,ecc)
c               bb=vfcn(Qhigh,period,finc,primmass,primK,ecc)
               cc=vfcn(Qmid,period,finc,primmass,primK,ecc)
               if(aa*cc.lt.0.0d0)then
                 Qhigh=(Qhigh+Qlow)*0.5d0
               else
                 Qlow=(Qhigh+Qlow)*0.50
               endif
 556          continue

              Q=Qmid
c              separ=(Gcgs*p*p*(1.0d0+Q)*rmass/(4.0d0*pie*pie))
c              separ1=separ**(1.0d0/3.0d0)/solarrad
              separ=(gmsun*p*p*primmass*
     &              (1.0d0+Q)/(4.0d0*pie*pie))**(1.0d0/3.0d0)
              separ=separ/solarrad*100.0d0              
c
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
c              total_mass=primmass*(1.0d0+Q)
c
c              ppp=period*24.0d0
c              separ1=(total_mass*ppp*ppp/7.737294491d0)**(1.0d0/3.0d0)
c
c           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
c
             write(2,1177)primmass,primK,Q,separ

             return
           endif
c
 1177      format(/'Info:  M_1 fixed at ',f9.6,' solar masses and ',
     &        'K_1 fixed at ',f11.6,' km/sec.',/
     &        'Q is set to ',f12.7,' and the separation is ',f13.7,
     &        ' solar radii')
1199       format(/'Info:  M_1 fixed at ',f9.6,' solar masses.  The',  
     %        ' separation',/ '       has been set to ',f13.7,
     $         ' solar radii')
 1188      format(/'Info:  K_1 fixed at ',f14.8,' km/sec.  The',  
     %        ' separation',/ '       has been set to ',f13.7,
     $         ' solar radii')  
c
            return
            end
c
c   *******&%$#@#$%$#@$%$#@&&$#@$%$#@&&$#@$%$#@&&$#@$%$#@&&*******
c
            function vfcn(Q,period,finc,primmass,primK,ecc)
c
c   UPDATE NOVEMBER 1
c
c   add the efact  =  dsqrt(1-e*e)
c
            implicit double precision (a-h,o-z)
c
           parameter(pie=3.14159265358979323d0)
c
             efact=dsqrt(1.0d0-ecc*ecc)
c
c           solarmass=1.9889d33
c           solarrad=6.9598d10
c           Gcgs=6.67259d-8     !G in cgs
c           Gmks=6.67259d-11   !G in mks
           p=period*24.0d0*3600.0d0
           fincr=finc*pie/180.0d0
c
           gmsun=1.32712440018d20  !mks units
c
           tt1=2.0d0*pie*dsin(fincr)/p*(Q/(Q+1.0d0))
           tt2=gmsun*p*p*(1.0d0+Q)*primmass/(4.0d0*pie*pie)
c
c           total_mass=primmass*(1.0d0+Q)
c
c           ppp=period*24.0d0
c           separ=(total_mass*ppp*ppp/7.737294491d0)**(1.0d0/3.0d0)
c     @         *solarrad
           tt2=tt2**(1.0d0/3.0d0)*100.0d0
c
           vfcn=tt1*tt2-primK*100000.0d0*efact
c
           return
           end
c
c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
c
           subroutine findradius(overQ,omega,psi0,x0,bdist,reff,
     @        tidephi,itide,ecc,thetamis,phimis)
c
c   This will find the effective radius.
c
           implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
c
           twopie=2.0d0*pie
           Na=120
           Nb=40
           dtheta=pie/dble(Na)
           vol=0.0d0
c           sarea=0.0d0
c           potsum=0.0d0
c
           if(itide.lt.2)then
           do 104 ialf=1,Na/2
c
c   UPDATE MARCH 17, 2004
c
c   make the initial value of r smaller here.
c
             r=1.0d-15
             x=x0
             y=0.0d0
             z=0.0d0
c
             call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,
     @          bdist,tidephi,itide,ecc,thetamis,phimis)
             theta=-0.5d0*dtheta+dtheta*dble(ialf)
             dphi=twopie/dble(4*Nb)
             snth=dsin(theta)
             snth3=snth*(1.0d0/3.0d0)
             cnth=dcos(theta)
             DO 105 ibet=1,Nb*2         !4*Nbet
               phi=-0.5d0*dphi+dphi*dble(ibet)
c
c              if(dble(ialf/2).eq.(dble(ialf)*0.5d0))phi=phi+0.25d0*dphi  !DPHI
c
               cox=dcos(phi)*snth             !*dsin(theta)
               coy=dsin(phi)*snth             !*dsin(theta)
               coz=cnth                       !dcos(theta)
               CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $            tidephi,itide,ecc,thetamis,phimis)
               VOL = VOL + 4.0d0*R*R*R*dphi*dtheta*snth3
c               write(*,*)'ialf = ',ialf,' ibet = ',ibet,'  ',r
105          CONTINUE    ! continue ibet loop
104        CONTINUE                   ! continue over ialf
c
           endif   !end if itide < 2
c
           if(itide.ge.2)then
           do 304 ialf=1,Na
c
c   UPDATE MARCH 17, 2004
c
c   make the initial value of r smaller here.
c
             r=1.0d-15
             x=x0
             y=0.0d0
             z=0.0d0
             call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,
     @          bdist,tidephi,itide,ecc,thetamis,phimis)
             theta=-0.5d0*dtheta+dtheta*dble(ialf)
             dphi=twopie/dble(4*Nb)
             snth=dsin(theta)
             snth3=snth*(1.0d0/3.0d0)
             cnth=dcos(theta)
             DO 305 ibet=1,Nb*4         !4*Nbet
               phi=-0.5d0*dphi+dphi*dble(ibet)
c
c              if(dble(ialf/2).eq.(dble(ialf)*0.5d0))phi=phi+0.25d0*dphi  !DPHI
c
               cox=dcos(phi)*snth             !*dsin(theta)
               coy=dsin(phi)*snth             !*dsin(theta)
               coz=cnth                       !dcos(theta)
               CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $            tidephi,itide,ecc,thetamis,phimis)
               VOL = VOL + 1.0d0*R*R*R*dphi*dtheta*snth3
c               write(*,*)'ialf = ',ialf,' ibet = ',ibet,'  ',r
305          CONTINUE    ! continue ibet loop
304        CONTINUE                   ! continue over ialf
c
           endif   !end if itide >= 2
c
c           REFF = (0.248732415d0*VOL) **(1.0d0/3.0d0) 
c
           REFF = (0.75d0*VOL/pie) **(1.0d0/3.0d0) 
c
           return
           end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
           subroutine filltime(ntime,timearray,tstart,tstop,tstep)
c
           implicit double precision (a-h,o-z)
c
           dimension timearray(9000000)
c
           ntime=0
           do 10 i=1,9000000
             tt=tstart+dble(i-1)*tstep
             if(tt.gt.tstop) go to 15
             ntime=ntime+1
             timearray(ntime)=tt
 10        continue
 15        timearray(ntime+1)=timearray(ntime)+tstep
           ntime=ntime+1
c
           return
c
           end
c
c  &&&&&&&&&&&&&&&&#@&^(*%@$&*&^$&@$%@(***(!@#$%^~~
c
          subroutine addmovespot(ialphmax,ibetmax,Nalph,ibetlim,
     @      tmatrix,spotparm,ave1,ave2,omega,phiar,mmdx,period,t0,ttime)
c
c   This routine will assign the temperatures of the grid points
c   of the stars that are covered by spots.  The underlying temperatures
c   are simply scaled by the temperature spot factor.  
c   
c   UPDATE March 26, 2002
c
c   Get rid of Nbet from the argument list of addstarspot.  Its value
c   is contained within ibetlim.
c
c    UPDATE June 17, 2002
c
c    Add these dummy assignments for phase and omega to supress
c    compiler warnings about unused variables.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0)
          dimension tmatrix(ialphmax*ibetmax),phiar(ialphmax*ibetmax),
     %       ibetlim(ialphmax),spotparm(2,4),mmdx(ialphmax,ibetmax)
c
          radcon=pie/180.0d0
          halfpie=0.5*pie
c
          poff=(ttime-T0)/period*(omega-1.0d0)*2.0d0*pie
          fac1=spotparm(1,1)
          fac2=spotparm(2,1)
          rlat1=radcon*spotparm(1,2)-halfpie
          rlat2=radcon*spotparm(2,2)-halfpie
          rlong1=dmod(radcon*spotparm(1,3)+poff,2.0d0*pie)
          rlong2=dmod(radcon*spotparm(2,3)+poff,2.0d0*pie)
          if(rlong1.gt.pie)rlong1=rlong1-2.0d0*pie
          if(rlong2.gt.pie)rlong2=rlong2-2.0d0*pie
          rad1=radcon*spotparm(1,4)
          rad2=radcon*spotparm(2,4)
c
          if((fac1.lt.0.0d0).and.(fac2.lt.0.0d0))return !no valid factors
c
          dtheta=pie/dble(Nalph)
          summ1=0.0d0
          summ2=0.0d0
          icount1=0
          icount2=0
          DO 10 IALF = 1, nalph
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            rlat=theta-halfpie
            DO 9 IBET = 1, ibetlim(ialf)    !4*NBET
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=(ialf-1)*ibetlim(ialf)+ibet
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              rlong=phiar(iidx)
              if(rlong.gt.pie)rlong=rlong-2.0d0*pie
c
              sepang1=dsin(rlat)*dsin(rlat1)+dcos(rlat)*dcos(rlat1)*
     %           dcos(rlong-rlong1)
              sepang1=dabs(dacos(sepang1))
              if((sepang1.le.rad1).and.(fac1.gt.0.0d0))then
                icount1=icount1+1
                tmatrix(iidx)=tmatrix(iidx)*fac1
                summ1=summ1+tmatrix(iidx)
              endif
c
              sepang2=dsin(rlat)*dsin(rlat2)+dcos(rlat)*dcos(rlat2)*
     %           dcos(rlong-rlong2)
              sepang2=dabs(dacos(sepang2))
              if((sepang2.le.rad2).and.(fac2.gt.0.0d0))then
                icount2=icount2+1
                tmatrix(iidx)=tmatrix(iidx)*fac2
                summ2=summ2+tmatrix(iidx)
              endif

 9          continue
 10       continue
c
          ave1=0.0d0
          ave2=0.0d0
          if(icount1.gt.0)ave1=summ1/dble(icount1)
          if(icount2.gt.0)ave2=summ2/dble(icount2)
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getom(ecc,ecosw,argper)
c
c   July 29, 2005
c
c   This routine will return the value of omega when given the eccentricity
c   and the phase difference between secondary and primary eclipse.
c
c   It is assumed ecosw is in phase units, so multiply by 2pi to get radians
c   The value of omega will be returned in degrees.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0)
c
          if(ecosw.eq.0.0d0)return
          if(ecc.le.0.0d0)return
          if(ecc.ge.1.0d0)return
c
          ppp=ecosw*2.0d0*pie
          call getX(ppp,xxx)
c
          ttt=dtan((xxx-pie)*0.5d0)
          www=ttt*dsqrt(1.0d0-ecc*ecc)/ecc
          if(www.lt.-1.0d0)www=-1.0d0
          if(www.gt.1.0d0)www=1.0d0
          argrad=dacos(www)
          argper=argrad*180.0d0/pie
          return
          end
c
c
c
          subroutine getX(em,bigE)
c
c    Solve for bigE in  em = bigE - sin(bigE)
c
          implicit double precision (a-h,o-z)
          Eold=em
c
          do 10 i=1,20
            top=Eold-dsin(Eold)-em
            bottom=1.0d0-dcos(Eold)
            Enew=Eold-top/bottom
            diff=dabs(Enew-Eold)
            if(diff.lt.1.0d-15)go to 15
            Eold=Enew
 10       continue
c
 15       bigE=Eold
c
          return
c
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine cliplc(Nmaxphase,icount,Nphase,xmod,ymodU,ymodB,
     @       ymodV,ymodR,ymodI,ymodJ,ymodH,ymodK,ymods1,ymods2,ymods3,
     @       ymodd)

c
          implicit double precision(a-h,o-z)
c
          dimension xmod(Nmaxphase),ymodU(Nmaxphase)
          dimension ymodB(Nmaxphase),ymodV(Nmaxphase)
          dimension ymodR(Nmaxphase),ymodI(Nmaxphase)
          dimension ymodJ(Nmaxphase),ymodH(Nmaxphase)
          dimension ymodK(Nmaxphase),ymods1(Nmaxphase)
          dimension ymods2(Nmaxphase),ymods3(Nmaxphase)
          dimension ymodd(Nmaxphase)
c
          jcount=0
          do 10 i=1,icount
            if(ymods1(i).ge.0.0d0)then
              jcount=jcount+1
              xmod(jcount)=xmod(i)
              ymodU(jcount)=ymodU(i)
              ymodB(jcount)=ymodB(i)
              ymodV(jcount)=ymodV(i)
              ymodR(jcount)=ymodR(i)
              ymodI(jcount)=ymodI(i)
              ymodJ(jcount)=ymodJ(i)
              ymodH(jcount)=ymodH(i)
              ymodK(jcount)=ymodK(i)
              ymods1(jcount)=ymods1(i)
              ymods2(jcount)=ymods2(i)
              ymods3(jcount)=ymods3(i)
              ymodd(jcount)=ymodd(i)
            endif
10        continue
c
          Nphase=jcount
c
          return
          end
c 
c   Add subroutines to interpolate limb darkening coefficients for the disk.
c
          double precision function rlambdae(pee,zee)
c
c     April 24, 2006
c
c     Gives light curve of the transit of a uniform disk across a uniform
c     star.  pee is the size ratio (radius of planet divided by radius of
c     star). zee is the normalized separation of centers (d/radius of star)
c

          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0)
c
          rlambdae=0.0d0
c
          if((1.0d0+pee).lt.zee)then
            rlambdae=0.0d0
            return
          endif
c
          z1=dabs(1.0d0-pee)
          z2=1.0d0+pee
          if((z1.lt.zee).and.(zee.le.z2))then
            rappa1=dacos(min((1.0-pee*pee+zee*zee)/(2.0d0*zee),1.0d0))
            rappa0=dacos(min((pee*pee+zee*zee-1.0d0)/(2.0d0*zee*pee),
     @         1.0d0))
            t1=0.5d0*dsqrt((4.0d0*zee*zee-(1.0d0+zee*zee-pee*pee)**2))
            rlambdae=(pee*pee*rappa0+rappa1-t1)/pie
            return
          endif
c
          if(zee.le.(1.0d0-pee))then
            rlambdae=pee*pee
            return
          endif
c
          if(zee.le.(pee-1.0d0))then
            rlambdae=1.0d0
            return
          endif
c
          return
          end
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c          subroutine analytic(isw12,ilaw,dwavex,dwavey,pee,zee,
c     @       refflux1,refflux2)
cc
cc   April 24, 2006
cc
cc   Will compute analytic transits (Mandel & Agol)
cc
cc 
c          implicit double precision(a-h,o-z)
cc 
c          dimension dwavex(8,3),dwavey(8,3),refflux1(8),refflux2(8)
cc
c          rlam=rlambdae(pee,zee)
cc
c          do 10 i=1,8
c            refflux2(i)=-refflux1(i)*(rlam)
c10        continue
cc
c          return
c          end
c
c  @#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!
c
          subroutine analyticg(isw12,ilaw,dwavex,dwavey,delta,reff1,
     @      ratrad,refflux1,refflux2,phaser,pconj,pconj2,gimvel,fincr,
     @      vrot,omega,period,separ,Q,ecc,bigI,bigbeta,Neclipse,istar,
     @      corr1,corr2,mandel,inback,Nbody)
c
c   April 24, 2006
c
c   Will compute analytic transits according to Gimenez.  The number isw12 is
c   the number of terms in the summation.
c
c 
          implicit double precision(a-h,o-z)
c 
          parameter(isize=1000)
          dimension dwavex(8,3),dwavey(8,3),refflux1(8),refflux2(8)
          dimension corr1(8),corr2(8),cx1(isize)
          dimension cx2(isize),c(10),alpha(10),cv1(isize),cv2(isize)
          dimension gimvel(8),alfone(10)
c
          parameter(pie=3.14159265359879323d0)
c
          if(isw12.gt.isize)then
            write(*,*)'Error:  The maximum size of Nterms is 1000'
            stop
          endif
c 
c   Add a new flag inback.  If this is not zero, then bail right away
c 
          if(inback.ge.1)then
            do i=1,8
              if((istar.eq.2).or.(istar.eq.3))corr2(i)=0.0d0
              if(istar.eq.1)corr1(i)=0.0d0
              gimvel(i)=0.0d0
            enddo
            Neclipse=0
            return
          endif

          rstar=1.0d0
          rplanet=1.0d0
          Neclipse=99
          solarrad=6.9598d8
          fact=solarrad*2.0d0*pie/86400.0d0/1.0d3  !50.613093d0
          a2=(separ/(1.0d0+Q))
c          a1=separ-a2
          efact=1.0d0/dsqrt(1.0-ecc*ecc)
          sifinc=dsin(fincr)
          velK2=fact*a2/period*sifinc*efact
c
c   add rotational velocity corrections
c           
          sI=dsin(bigI*pie/180.0d0)
          sB=dsin(bigbeta*pie/180.0d0)
          cB=dcos(bigbeta*pie/180.0d0)
          vstar=-vrot*sI*(sB*dcos(fincr)*dcos(phaser)-cB*dsin(phaser))
     @        *omega
c
c   Do the case for linear first (ilaw=1)
c
          alpha(1)=0.0d0
          alpha(2)=0.0d0
          alpha(3)=0.0d0
          if(istar.eq.1)then
            rstar=reff1
            rplanet=rstar/ratrad
          endif
          if((istar.eq.2).or.(istar.eq.3))then
            rplanet=reff1
            rstar=rplanet/ratrad
            rstar=reff1
            rplanet=rstar/ratrad
          endif
          bee=rplanet/(rstar+rplanet)
          cee=delta/(rplanet+rstar)
          if(delta.gt.(rstar+rplanet))then
            do 99 i=1,8
c              refflux2(i)=0.0d0
              corr1(i)=0.0d0
              corr2(i)=0.0d0
              gimvel(i)=0.0d0
99          continue
            Neclipse=0
            return
          endif

c   October 17, 2010
c
c   Update to make sure the nearest conjunction phase is found
c
          tt1=dabs(phaser-2.0d0*pie*pconj)
          tt2=dabs(phaser-2.0d0*pie*(pconj+1.0d0))
          tt3=dabs(phaser-2.0d0*pie*(pconj-1.0d0))
c
          small=123456789.0d0
          if(tt1.le.small)small=tt1
          if(tt2.le.small)small=tt2
          if(tt3.le.small)small=tt3
          diff1=small
c
c          tt1=dabs(phaser-2.0d0*pie*pconj)
c          tt2=dabs(phaser-2.0d0*pie*(pconj+1.0d0))
c          if(tt1.le.tt2)then
c            diff1=tt1
c          else
c            diff1=tt2
c          endif

          tt1=dabs(phaser-2.0d0*pie*pconj2)
          tt2=dabs(phaser-2.0d0*pie*(pconj2+1.0d0))
          tt3=dabs(phaser-2.0d0*pie*(pconj2-1.0d0))
c
          small=123456789.0d0
          if(tt1.le.small)small=tt1
          if(tt2.le.small)small=tt2
          if(tt3.le.small)small=tt3
          diff2=small
c
          if((istar.eq.1).and.(Nbody.eq.0))then
            if(diff1.lt.diff2)then
              do 999 i=1,8
                corr1(i)=0.0d0   !was refflux2
                gimvel(i)=0.0d0
999            continue
              return
            endif
          endif

          if(((istar.eq.2).or.(istar.eq.3)).and.(Nbody.eq.0))then
            if(diff2.lt.diff1)then
              do 9999 i=1,8
c                refflux2(i)=0.0d0    !was commented out
                corr2(i)=0.0d0    
                gimvel(i)=0.0d0
9999           continue
              return
            endif
          endif
c
c  UPDATE September 4, 2012
c
c  If ilaw=11, this is linear with the coefficients for star 2
c  forced to be equal for those of star 1
c
c

          if((ilaw.eq.1).or.(ilaw.eq.11))then
c
            do 2 n=0,1
              rnu=dble(n+2)*0.5d0
c
              pee=rnu+2.0d0
              cue=rnu+1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
c
              call jacobi_poly(isw12,beta,alf,xx,cx1)
              cue=1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-2.0d0*cee*cee
c
              call jacobi_poly(isw12,beta,alf,xx,cx2)
c
              pee=rnu+3.0d0
              cue=2.0d0
              alf=pee-cue
              beta1=cue-1.0d0
              xx=1.0d0-(2.0d0*(cee*cee))
              call jacobi_poly(isw12,beta1,alf,xx,cv2)

              pee=rnu+3.0d0
              cue=rnu+2.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
              call jacobi_poly(isw12,beta,alf,xx,cv1)

              t1=bee*bee*((1.0d0-cee*cee)**(rnu+1.0d0))
     &             /(rnu*dexp(gamma_log(rnu+1.0d0)))
c
              v1=dexp(gamma_log(rnu)-2.0d0*gamma_log(rnu+2.0d0))
              v1=v1*cee*bee*bee*(1.0d0-bee)*(1.0d0-cee*cee)**(rnu+1.0d0)

              summ=0.0d0
              summv=0.0d0
              do 3 j=0,isw12
                dj=dble(j)

                t3=(gamma_log(dj+1.0d0)+gamma_log(rnu+1.0d0)-
     %              gamma_log(dj+rnu+1.0d0))
                t3=exp(t3)

                t2=dexp(gamma_log(rnu+dble(j+1))-gamma_log(dble(j+2)))
                summ=summ+(-1.0d0)**j*(2.0d0*dble(j)+rnu+2.0d0)*t2*
     @              cx1(j+1)**2*cx2(j+1)*t3*t3
c
                v3=dexp(gamma_log(rnu+dj+3.0d0)-gamma_log(dj+1.0d0))
                v4=dexp(gamma_log(dj+1.0d0)+gamma_log(beta+1.0d0)-
     @              gamma_log(dj+1.0d0+beta))
                v5=dexp(gamma_log(dj+1.0d0)+gamma_log(beta1+1.0d0)-
     @              gamma_log(dj+1.0d0+beta1))

                v4=v4*v4*v5

                summv=summv+
     $             v3*v4*cv1(j+1)*cv1(j+1)*cv2(j+1)*
     @             (-1.0d0)**j*(2.0d0*dj+rnu+3.0d0)
c

 3            continue
              alpha(n+1)=t1*summ
              alfone(n+1)=v1*summv
 2          continue

            do 1 i=1,8
              you1=dwavex(i,istar)   
              if((ilaw.eq.11).and.(istar.eq.2))you1=dwavex(i,1)
              c(1)=(1.0d0-you1)/(1.0d0-you1/3.0D0)
              c(2)=you1/(1.0d0-you1/3.0D0)      
              atot=alpha(1)*c(1)+alpha(2)*c(2)

c              if(istar.eq.1)refflux2(i)=-refflux1(i)*(atot)
c              if(istar.eq.2)refflux1(i)=-refflux2(i)*(atot)

              if(istar.eq.1)corr1(i)=-refflux1(i)*(atot)
              if(istar.eq.2)corr2(i)=-refflux2(i)*(atot)
              if(istar.eq.3)corr2(i)=-refflux2(i)*(atot)
c
              vtot=alfone(1)*c(1)+alfone(2)*c(2)
              if(delta.ne.0.0d0)then
                delvel=vstar/delta*(vtot/(1.0d0-atot))
              else
                delvel=0.0d0
              endif
              if(velK2.ne.0.0d0)then
                gimvel(i)=delvel/velK2
              else
                gimvel(i)=0.0d0
              endif
1           continue
          endif  ! end if ilaw=1
c
c  UPDATE September 4, 2012
c
c  If ilaw=14, quad law with coefficients of star 2 forced to be
c  equal to the coefficients of star 1.
c
          if((ilaw.eq.4).or.(ilaw.eq.14).or.(ilaw.eq.5).or.(ilaw.eq.15))then   !quadratic
c
            if(mandel.eq.0)then
              do 200 n=0,2
                rnu=dble(n+2)*0.5d0
c
                rnp=gamma_log(rnu)
                rnp1=gamma_log(rnu+1.0d0)

                pee=rnu+2.0d0
                cue=rnu+1.0d0
                alf=pee-cue
                beta=cue-1.0d0
                xx=1.0d0-(2.0d0*(1.0d0-bee))
                call jacobi_poly(isw12,beta,alf,xx,cx1)
                cue=1.0d0
                alf=pee-cue
                beta=cue-1.0d0
                xx=1.0d0-2.0d0*cee*cee
                call jacobi_poly(isw12,beta,alf,xx,cx2)
c                t1=bee*bee*((1.0d0-cee*cee)**(rnu+1.0d0))
c     &             /(rnu*dexp(gamma_log(rnu+1.0d0)))
c
                t1=bee*bee*((1.0d0-cee*cee)**(rnu+1.0d0))
     &               /(rnu*dexp(rnp1))
                pee=rnu+3.0d0
                cue=2.0d0
                alf=pee-cue
                beta1=cue-1.0d0
                xx=1.0d0-(2.0d0*(cee*cee))
                call jacobi_poly(isw12,beta1,alf,xx,cv2)

                pee=rnu+3.0d0
                cue=rnu+2.0d0
                alf=pee-cue
                beta=cue-1.0d0
                xx=1.0d0-(2.0d0*(1.0d0-bee))
                call jacobi_poly(isw12,beta,alf,xx,cv1)
c
c                v1=dexp(gamma_log(rnu)-2.0d0*gamma_log(rnu+2.0d0))
c
                v1=dexp(rnp-2.0d0*gamma_log(rnu+2.0d0))
                v1=v1*cee*bee*bee*(1.0d0-bee)*(1.0d0-cee*cee)**(rnu+1.0d0)

                summ=0.0d0
                summv=0.0d0
                summ=0.0d0
                do 300 j=0,isw12
                  dj=dble(j)

                  djp1=gamma_log(dj+1.0d0)
                  djpbeta=gamma_log(dj+1.0d0+beta)
                  djpbeta1=gamma_log(dj+1.0d0+beta1)
                  bp1=gamma_log(beta+1.0d0)
                  b1p1=gamma_log(beta1+1.0d0)
c                  t3=(gamma_log(dj+1.0d0)+gamma_log(rnu+1.0d0)-
c     %                gamma_log(dj+rnu+1.0d0))
c
                  t3=(djp1+rnp1-gamma_log(dj+rnu+1.0d0))
                  t3=exp(t3)
c
                  t2=dexp(gamma_log(rnu+dble(j+1))-gamma_log(dble(j+2)))
                    summ=summ+(-1.0d0)**j*(2.0d0*dble(j)+rnu+2.0d0)*t2*
     @               cx1(j+1)**2*cx2(j+1)*t3*t3
c
c                  v3=dexp(gamma_log(rnu+dj+3.0d0)-gamma_log(dj+1.0d0))
c
                  v3=dexp(gamma_log(rnu+dj+3.0d0)-djp1)

c                  v4=dexp(gamma_log(dj+1.0d0)+gamma_log(beta+1.0d0)-
c     @                gamma_log(dj+1.0d0+beta))
c
                  v4=dexp(djp1+bp1-djpbeta)
c
c                  v5=dexp(gamma_log(dj+1.0d0)+gamma_log(beta1+1.0d0)-
c     @                gamma_log(dj+1.0d0+beta1))
c
                  v5=dexp(djp1+b1p1-djpbeta1)
c
                  v4=v4*v4*v5
c
                  summv=summv+
     $               v3*v4*cv1(j+1)*cv1(j+1)*cv2(j+1)*
     @               (-1.0d0)**j*(2.0d0*dj+rnu+3.0d0)
c
300             continue
                alpha(n+1)=t1*summ
                alfone(n+1)=v1*summv
200           continue
            endif
c
            do 100 i=1,8
              flimbx=dwavex(i,istar)
              flimby=dwavey(i,istar)
c
c   December 15, 2013:  add triangular sampling
c
              if((ilaw.eq.5).or.(ilaw.eq.15))then
                savefx=flimbx
                savefy=flimby
                flimbx=2.0d0*dsqrt(savefx)*savefy
                flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
              endif
c
              you1=flimbx+2.0d0*flimby
              you2=-1.0d0*flimby
              if((ilaw.eq.14).and.(istar.eq.2))then
                flimbx=dwavex(i,1)
                flimby=dwavey(i,1)
                you1=flimbx+2.0d0*flimby
                you2=-1.0d0*flimby
              endif
              if((ilaw.eq.15).and.(istar.eq.2))then
                flimbx=dwavex(i,1)
                flimby=dwavey(i,1)
                savefx=flimbx
                savefy=flimby
                flimbx=2.0d0*dsqrt(savefx)*savefy
                flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
                you1=flimbx+2.0d0*flimby
                you2=-1.0d0*flimby
              endif
              if(mandel.gt.0)then
                you1=dwavex(i,istar)
                you2=dwavey(i,istar)

                if((ilaw.eq.5).or.(ilaw.eq.15))then
                  savefx=you1
                  savefy=you2
                  you1=2.0d0*dsqrt(savefx)*savefy
                  you2=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
                endif
                if((ilaw.eq.14).and.(istar.eq.2))you2=you1
                if((ilaw.eq.15).and.(istar.eq.2))you2=you1
                call occultquad(delta/reff1,you1,you2,1.0d0/ratrad,
     @             agol1,agol2,1)
                atot=1.0d0-agol1
                if(atot.lt.0.0d0)atot=0.0d0
              else
                c(1)=(1.0d0-you1-you2)/(1.0d0-you1/3.0d0-you2/2.0d0)
                c(2)=you1/(1.0d0-you1/3.0d0-you2/2.0d0)      
                c(3)=you2/(1.0d0-you1/3.0d0-you2/2.0d0)      
                atot=alpha(1)*c(1)+alpha(2)*c(2)+alpha(3)*c(3)
              endif
c
              if(istar.eq.1)corr1(i)=-refflux1(i)*(atot)
              if(istar.eq.2)corr2(i)=-refflux2(i)*(atot)
              if(istar.eq.3)corr2(i)=-refflux2(i)*(atot)
c
              vtot=alfone(1)*c(1)+alfone(2)*c(2)+alfone(3)*c(3)
              if(delta.ne.0.0d0)then
                delvel=vstar/delta*(vtot/(1.0d0-atot))
              else
                delvel=0.0d0
              endif
              if(velK2.ne.0.0d0)then
                gimvel(i)=delvel/velK2
              else
                gimvel(i)=0.0d0
              endif
              if(istar.eq.2)then
                gimvel(i)=-gimvel(i)
              endif
100         continue
          endif  ! end if ilaw=4
c
          return
          end
c
cc   %$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$%$
cc
cc
c          double precision function oldgamma_log(x)
cc
c          implicit double precision(a-h,o-z)
cc
c          dimension cof(6)
c          save cof,stp
cc
c          data cof,stp/76.18009172947146d0,-86.50532032941677d0,
c     @     24.01409824083091d0,-1.231739572450155d0,.120865097386617d-2,
c     @     -0.5395239384953d-5,2.5066282746310005d0/
cc
c          x=xx
c          y=x
c          tmp=x+5.5d0
c          tmp=(x+0.5d0)*dlog(tmp)-tmp
c          ser=1.000000000190015d0
c          do j=1,6
c            y=y+1.0d0
c            ser=ser+cof(j)/y
c          enddo
c          gamma_log=tmp+dlog(stp*ser/x)
c          return
c          end
cc
cc
cc
          double precision function gamma_log ( x )
c
c  April 24, 2006
c
c  Routine to compute the natural log of the gamma function.  Received by way
c  of A. Gimenez.  Converted to FORTRAN 77 by Orosz.
c
c****************************************************************************
c
c! GAMMA_LOG calculates the natural logarithm of GAMMA ( X ) for positive X.
c
c  Discussion:
c
c    Computation is based on an algorithm outlined in references 1 and 2.
c    The program uses rational functions that theoretically approximate
c    log ( GAMMA(X) ) to at least 18 significant decimal digits.  The
c    approximation for 12 < X is from reference 3, while approximations
c    for X < 12.0 are similar to those in reference 1, but are unpublished.
c    The accuracy achieved depends on the arithmetic system, the compiler,
c    intrinsic functions, and proper selection of the machine-dependent
c    constants.
c
c  Modified:
c
c    16 June 1999
c
c  Authors:
c
c    W. J. Cody and L. Stoltz
c    Argonne National Laboratory
c
c  Reference:
c
c    @ 1)
c    W. J. Cody and K. E. Hillstrom,
c    Chebyshev Approximations for the Natural Logarithm of the Gamma Function,
c    Mathematics of Computation,
c    Volume 21, 1967, pages 198-203.
c
c    @ 2)
c    K. E. Hillstrom,
c    ANL/AMD Program ANLC366S, DGAMMA/DLGAMA,
c    May 1969.
c
c    @ 3)
c    Hart, Cheney, Lawson, Maehly, Mesztenyi, Rice, Thacher, Witzgall,
c    Computer Approximations,
c    Wiley, 1968.
c
c  Parameters:
c
c    Input, real ( kind = 8 ) X, the argument of the Gamma function. 
c    X must be positive.
c
c    Output, real ( kind = 8 ) GAMMA_LOG, the logarithm of the Gamma 
c    function of X.  If X <= 0.0, or if overflow would occur, the
c    program returns the value HUGE().
c
c  Machine-dependent constants:
c
c       - radix for the floating-point representation.
c
c    MAXEXP - the smallest positive power of BETA that overflows.
c
c    XBIG   - largest argument for which LN(GAMMA(X)) is representable
c             in the machine, i.e., the solution to the equation
c             LN(GAMMA(XBIG)) = BETA**MAXEXP.
c
c    XINF   - largest machine representable floating-point number;
c             approximately BETA**MAXEXP.
c
c    FRTBIG - Rough estimate of the fourth root of XBIG
c
c
c    Approximate values for some important machines are:
c
c                              BETA      MAXEXP         XBIG
c
c    CRAY-1        (S.P.)        2        8191       9.62D+2461
c    Cyber 180/855
c      under NOS   (S.P.)        2        1070       1.72D+319
c    IEEE (IBM/XT,
c      SUN, etc.)  (S.P.)        2         128       4.08D+36
c    IEEE (IBM/XT,
c    SUN, etc.)  (D.P.)        2        1024       2.55D+305
c    IBM 3033      (D.P.)       16          63       4.29D+73
c    VAX D-Format  (D.P.)        2         127       2.05D+36
c    VAX G-Format  (D.P.)        2        1023       1.28D+305
c
c
c                            FRTBIG
c
c    CRAY-1        (S.P.)   3.13D+615
c    Cyber 180/855
c      under NOS   (S.P.)   6.44D+79
c    IEEE (IBM/XT,
c      SUN, etc.)  (S.P.)   1.42D+9
c    IEEE (IBM/XT,
c      SUN, etc.)  (D.P.)   2.25D+76
c    IBM 3033      (D.P.)   2.56D+18
c    VAX D-Format  (D.P.)   1.20D+9
c    VAX G-Format  (D.P.)   1.89D+76
c
         implicit none
         double precision c,corr,d1,d2,d4,eps,frtbig,p1,p2,p4,xm4
         double precision pnt68,q1,q2,q4,res,sqrtpi,x,xbig,xden,xm1,xm2
         double precision xnum,xsq
c
         integer i
c
         dimension c(7),p1(8),p2(8),p4(8),q1(8),q2(8),q4(8)
c         
         parameter(d1=-5.772156649015328605195174D-01)
         parameter(d2=4.227843350984671393993777D-01,pnt68=0.6796875d+00)
         parameter(d4=1.791759469228055000094023D+00,frtbig=1.42d+09)
         parameter(sqrtpi = 0.9189385332046727417803297D+00,xbig=4.08d+36)
c
         data c/-1.910444077728D-03, 8.4171387781295D-04, -5.952379913043012D-04, 
     @            7.93650793500350248D-04, -2.777777777777681622553D-03, 
     @            8.333333333333333331554247D-02, 5.7083835261D-03/
c          
         data p1/4.945235359296727046734888D+00,2.018112620856775083915565D+02, 
     %          2.290838373831346393026739D+03,1.131967205903380828685045D+04, 
     @          2.855724635671635335736389D+04,3.848496228443793359990269D+04,
     @          2.637748787624195437963534D+04,7.225813979700288197698961D+03/
c
         data p2/4.974607845568932035012064D+00,5.424138599891070494101986D+02, 
     @           1.550693864978364947665077D+04,1.847932904445632425417223D+05,
     @           1.088204769468828767498470D+06,3.338152967987029735917223D+06, 
     @           5.106661678927352456275255D+06,3.074109054850539556250927D+06/
c
         data p4/1.474502166059939948905062D+04,2.426813369486704502836312D+06, 
     @           1.214755574045093227939592D+08,2.663432449630976949898078D+09,
     @           2.940378956634553899906876D+10,1.702665737765398868392998D+11,
     @           4.926125793377430887588120D+11,5.606251856223951465078242D+11/
c
         data q1/6.748212550303777196073036D+01,1.113332393857199323513008D+03, 
     @           7.738757056935398733233834D+03,2.763987074403340708898585D+04,
     @           5.499310206226157329794414D+04,6.161122180066002127833352D+04,
     @           3.635127591501940507276287D+04,8.785536302431013170870835D+03/
c
         data q2/1.830328399370592604055942D+02,7.765049321445005871323047D+03,
     @           1.331903827966074194402448D+05,1.136705821321969608938755D+06,
     @           5.267964117437946917577538D+06,1.346701454311101692290052D+07,
     @           1.782736530353274213975932D+07,9.533095591844353613395747D+06/
c
         data q4/2.690530175870899333379843D+03,6.393885654300092398984238D+05, 
     @           4.135599930241388052042842D+07,1.120872109616147941376570D+09, 
     @           1.488613728678813811542398D+10,1.016803586272438228077304D+11,
     @           3.417476345507377132798597D+11,4.463158187419713286462081D+11 /
c
c  Return immediately if the argument is out of range.
c
         if ((x.le.0.0D+00).or.(xbig.lt.x)) then
           gamma_log = 2.55d+305
           return
         end if
         eps = 1.d-36  !epsilon ( eps )
         if (x.le.eps) then
           res = -dlog ( x )
         else if (x.le.1.5D+00) then
           if (x.lt.pnt68) then
             corr = - dlog(x)
             xm1 = x
           else
            corr = 0.0D+00
            xm1 = (x - 0.5D+00) - 0.5D+00
           end if
           if ((x.le.0.5D+00).or.(pnt68.le.x)) then
             xden = 1.0D+00
             xnum = 0.0D+00
             do i = 1, 8
               xnum = xnum * xm1 + p1(i)
               xden = xden * xm1 + q1(i)
             end do
             res = corr+(xm1*(d1+xm1*(xnum/xden)))
           else
             xm2=(x-0.5D+00) - 0.5D+00
             xden = 1.0D+00
             xnum = 0.0D+00
             do i = 1, 8
               xnum = xnum * xm2 + p2(i)
               xden = xden * xm2 + q2(i)
             end do
             res=corr+xm2*(d2+xm2*(xnum/xden))
           end if
         else if (x.le.4.0D+00) then
           xm2 = x - 2.0D+00
           xden = 1.0D+00
           xnum = 0.0D+00
           do i = 1, 8
             xnum = xnum * xm2 + p2(i)
             xden = xden * xm2 + q2(i)
           end do
           res=xm2*(d2+xm2*(xnum/xden))
         else if (x.le.12.0D+00) then
           xm4 = x - 4.0D+00
           xden = - 1.0D+00
           xnum = 0.0D+00
           do i = 1, 8
             xnum = xnum * xm4 + p4(i)
             xden = xden * xm4 + q4(i)
           end do
           res=d4+xm4*(xnum/xden)
         else
           res = 0.0D+00
           if(x.le.frtbig) then
             res = c(7)
             xsq = x * x
             do i = 1, 6
               res=res/xsq + c(i)
             end do
           end if
           res=res/x
           corr=dlog( x)
           res = res + sqrtpi - 0.5D+00 * corr
           res = res + x * ( corr - 1.0D+00 )
         end if
         gamma_log = res
         return
         end
c
c
c
         subroutine jacobi_poly(n,alpha,beta,x,cx)
c
c   April 24, 2006
c
c   Subroutine to evaluate the Jacobi polynomials at x.  Routine received
c   from A. Gimenez and converted to FORTRAN 77 by Orosz.
c
c*******************************************************************************
c
c! JACOBI_POLY evaluates the Jacobi polynomials at X.
c
c  Differential equation:
c
c    (1-X*X) Y'' + (BETA-ALPHA-(ALPHA+BETA+2) X) Y' + N (N+ALPHA+BETA+1) Y = 0
c
c  Recursion:
c
c    P(0,ALPHA,BETA,X) = 1,
c
c    P(1,ALPHA,BETA,X) = ( (2+ALPHA+BETA)*X + (ALPHA-BETA) ) / 2
c
c    P(N,ALPHA,BETA,X)  = 
c      ( 
c        (2*N+ALPHA+BETA-1) 
c        * ((ALPHA**2-BETA**2)+(2*N+ALPHA+BETA)*(2*N+ALPHA+BETA-2)*X) 
c        * P(N-1,ALPHA,BETA,X)
c        -2*(N-1+ALPHA)*(N-1+BETA)*(2*N+ALPHA+BETA) * P(N-2,ALPHA,BETA,X)
c      ) / 2*N*(N+ALPHA+BETA)*(2*N-2+ALPHA+BETA)
c
c  Restrictions:
c
c    -1 < ALPHA
c    -1 < BETA
c
c  Norm:
c
c    Integral ( -1 <= X <= 1 ) ( 1 - X )**ALPHA * ( 1 + X )**BETA 
c      * P(N,ALPHA,BETA,X)**2 dX 
c    = 2**(ALPHA+BETA+1) * Gamma ( N + ALPHA + 1 ) * Gamma ( N + BETA + 1 ) /
c      ( 2 * N + ALPHA + BETA ) * N! * Gamma ( N + ALPHA + BETA + 1 )
c
c  Special values:
c
c    P(N,ALPHA,BETA)(1) = (N+ALPHA)!/(N!*ALPHA!) for integer ALPHA.
c
c  Modified:
c
c    01 October 2002
c
c  Author:
c
c    John Burkardt
c
c  Reference:
c
c    Milton Abramowitz and Irene Stegun,
c    Handbook of Mathematical Functions,
c    US Department of Commerce, 1964.
c
c  Parameters:
c
c    Input, integer N, the highest order polynomial to compute.  Note
c    that polynomials 0 through N will be computed.
c
c    Input, real ( kind = 8 ) ALPHA, one of the parameters defining the Jacobi
c    polynomials, ALPHA must be greater than -1.
c
c    Input, real ( kind = 8 ) BETA, the second parameter defining the Jacobi
c    polynomials, BETA must be greater than -1.
c
c    Input, real ( kind = 8 ) X, the point at which the polynomials are 
c    to be evaluated.
c
c    Output, real ( kind = 8 ) CX(0:N), the values of the first N+1 Jacobi
c    polynomials at the point X.
c
          implicit none
          integer n,i
          double precision alpha,beta,cx,c1,c2,c3,c4,r_i,x
          dimension cx(n+1)
c
          if(alpha.le.-1.0D+00) then
            write ( *, '(a)' ) ' '
            write ( *, '(a)' ) 'JACOBI_POLY - Fatal error!'
            write ( *, '(a,g14.6)' ) '  Illegal input value of ALPHA = ', alpha
            write ( *, '(a)' ) '  But ALPHA must be greater than -1.'
            stop
          end if
          if(beta.le.-1.0D+00) then
            write ( *, '(a)' ) ' '
            write ( *, '(a)' ) 'JACOBI_POLY - Fatal error!'
            write ( *, '(a,g14.6)' ) '  Illegal input value of BETA = ', beta
            write ( *, '(a)' ) '  But BETA must be greater than -1.'
            stop
          end if
         if(n.lt.0) then
           return
         end if
         cx(1) = 1.0D+00
         if(n.eq.0) then
           return
         end if
         cx(1+1) = (1.0D+00+0.5D+00*(alpha+beta))*x+0.5D+00*(alpha-beta)
         do i = 2, n
           r_i = dble(i) 
           c1=2.0D+00*r_i*(r_i+alpha+beta)*(2.0D+00*r_i-2.0D+00+alpha+
     @        beta)
           c2=(2.0D+00*r_i-1.0D+00+alpha+beta)*(2.0D+00*r_i+alpha+beta) 
     @      *(2.0D+00*r_i-2.0D+00+alpha+beta)
           c3=(2.0D+00*r_i-1.0D+00+alpha+beta)*(alpha+beta)*(alpha-beta)
           c4=-2.0D+00*(r_i-1.0D+00+alpha)*(r_i-1.0D+00+beta)  
     @      *(2.0D+00*r_i+alpha+beta)
           cx(i+1)=((c3+c2*x)*cx(i-1+1)+c4*cx(i-2+1))/c1
         end do
         return
         end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@@@@@@@@@@@@@@@@@@@@@@@
c
          subroutine getalflim(istar,ialphmax,ibetmax,Nalf,ibetlim,
     %      phase,finc,Q,gradx,grady,gradz,xarray,yarray,
     @      zarray,Nhoriz,xhoriz,yhoriz,bdist,mmdx,ialfmin,
     @      ialfmax,tertincl,tertbdist,tertphase,tertQ,axisscale,
     @      isw30,isw7,tertOmega)
c
c  October 9, 1999
c
c  This routine will compute the 'projection' factor of each grid element on
c  the star (istar=1 to do star 1, istar=2 to do star2), check for eclipses
c  (the horizon of the other body is in xhoriz,yhoriz), and return the
c  sky coordinates of the visible points.  Set iecheck = -1 to skip the
c  check for 
c  eclipses.
c
c  UPDATE JULY 4, 2004
c
c  Add jdum and MonteCarlo to the argument list.  If MonteCarlo > 10,
c  then use Monte Carlo integration to determine fractionally
c  eclipsed pixels.  If MonteCarlo < 10, then proceed as before
c  and use interpolation in getBBflux and getATMflux.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          parameter(twopie=2.0d0*pie)
          dimension gradx(ialphmax*ibetmax),grady(ialphmax*ibetmax),
     $        gradz(ialphmax*ibetmax),
     $        xhoriz(Nhoriz),yhoriz(Nhoriz),xarray(ialphmax*ibetmax),
     $        yarray(ialphmax*ibetmax),zarray(ialphmax*ibetmax),
     %        ibetlim(ialphmax),
     @        mmdx(ialphmax,ibetmax)
c
c
c    November 18, 2012
c
c    If there is a third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          if((isw30.ge.1).and.(isw7.ge.2))then
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
            tOmrad=TertOmega*pie/180.0d0
            xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
            yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
          endif
c
c    Keep track of the smallest and largest values of ialf on star 1 that
c    are eclipsed.
c
c
          PHASER = (PHASE/180.0d0)*pie     !orbital phase in radians
          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
c
c   Check to see of the star in question is in front.  If so, then simply
c   find the projection factors.
c
          iimax=-12345
          iimin=12345
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)      !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              PROJ = AX * GRADX(iidx) + AY*GRADY(iidx) + 
     &           AZ*GRADZ(iidx)
              IF (PROJ.LT.0.) GO TO 502    ! is the surface element visible?
              xx=xarray(iidx)
              yy=yarray(iidx)
              zz=zarray(iidx)
              xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) ! projected coords
              yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
              xp=xp+xxoff
              yp=yp+yyoff
c
c   Check to see of the point in question is eclipsed by the other star, or
c   in the case of star 1, eclipsed by the disk, or
c   in the case of a point on the bottom half of star 2, eclipsed by the disk. 
c   icut=2 for points outside and below the horizon.
c 
              iyes=-100
              call insidecircle(Nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
              if(iyes.eq.100)then
                if(ialf.lt.ialfmin)ialfmin=ialf
                if(ialf.lt.iimin)iimin=ialf
                if(ialf.gt.ialfmax)ialfmax=ialf
                if(ialf.gt.iimax)iimax=ialf
                go to 502
              endif
c
502         CONTINUE
501       continue         ! continue the alpha loop
c
c
c          dsi=dsin(fincr)*dsin(fincr)
c          ttop=1.0d0-reff1*reff1
c
          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getBBlumcor(ialphmax,ibetmax,Nalf,ibetlim,
     $      wave,visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,
     &      flum,flux,mmdx,ialfmin,ialfmax)
c
c   May 3, 2006
c
c   This routine will return the integrate flux on star 1 outside the
c   ialpha range of ialfmin,ialfmax
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension visib(ialphmax*ibetmax),
     $        surf(ialphmax*ibetmax),ibetlim(ialphmax),
     $        temp(ialphmax*ibetmax),flum(ialphmax*ibetmax),
     $        rinty(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     %        mmdx(ialphmax,ibetmax)
c
c          dint=pie*(1.0d0-flimbx/3.0d0)
c          if((ilaw.eq.2).or.(ilaw.eq.12))then
c            dint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
c          endif
c          if((ilaw.eq.3).or.(ilaw.eq.13))then
c            dint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
c          endif
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
c          if((ilaw.eq.4).or.(ilaw.eq.14))then
c            dint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)
c          endif
c

c
c   December 15, 2013:  add triangular sampling
c
          if((ilaw.eq.5).or.(ilaw.eq.15))then
            savefx=flimbx
            savefy=flimby
            flimbx=2.0d0*dsqrt(savefx)*savefy
            flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
          endif
c
          wavemu=wave/10000.0d0
          C2 = 1.4384d8          ! 1.4384 * 10.**8      ! hc/(k*1e-8)
          C1 = 1.191044d35       ! 2hc^2/((1e-8)**5)
c
c   Initialize the flum matrix.
c
c
          c1=3.74185
          c2=14.3883

          flux=0.0d0
          do 2 ialf=1,nalf
            do 1 ibet=1,ibetlim(ialf)        !4*Nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c
              iidx=mmdx(ialf,ibet)
              flum(iidx)=0.0d0
              rinty(iidx)=0.0d0
 1          continue
 2        continue
c          dtheta=0.5d0*pie/dble(Nalf)
c
          DO 10 ialf=1,nalf
            if((ialf.ge.ialfmin).and.(ialf.le.ialfmax))go to 10
c            theta=-dtheta+2.0d0*dtheta*dble(ialf)
c            dphi=pie/dble(ibetlim(ialf))
            DO 9 ibet = 1,ibetlim(ialf)               !4*nbet
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
c              iidx=kount(ialphmax,ialf,ibetlim)+ibet
c 
              iidx=mmdx(ialf,ibet)
              if((projarray(iidx).le.0.0d0))go to 9
              tkkelv=temp(iidx)/1000.0d0
              C3 = C2/(wavemu*tkkelv)
              flum(iidx)=C1/(dexp(c3)-1.0d0)/wavemu**5
              dark=(1.0d0-flimbx+flimbx*projarray(iidx))
              if(ilaw.eq.2)dark=dark-flimby*projarray(iidx)*
     %               dlog(projarray(iidx))
              if(ilaw.eq.3)dark=dark-flimby*(1.0-dsqrt(projarray(iidx)))
              if(ilaw.eq.12)dark=dark-flimby*projarray(iidx)*
     %               dlog(projarray(iidx))
              if(ilaw.eq.13)dark=dark-flimby*(1.0-dsqrt(projarray(iidx)))
c
c   UPDATE JULY 21, 2004
c
c   Add a quadratic limb darkening law, ilaw=4
c
c
              if(ilaw.eq.4)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.14)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.5)dark=dark-flimby*(1.0-(projarray(iidx)))**2
              if(ilaw.eq.15)dark=dark-flimby*(1.0-(projarray(iidx)))**2
c
              flum(iidx)=flum(iidx)*dark
              rinty(iidx)=flum(iidx) ! save intensities for plotting
              flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
              flux=flux+flum(iidx)
 9          continue
 10       continue
c
c   Scale the light curve by the integral of the limb darkening law
c   for compatibility with Wilson-Devinney.
c        
c   Scale the light curve by the integral of the limb darkening law
c   for compatibility with Wilson-Devinney.
c        
c          flux=pie*flux/dint
c
c
c   UPDATE April 3, 2002
c
c   Scale the fluxes.
c
c          solarrad=6.9598d10
c          flux=flux*(separ*solarrad)**2
cc
c          rldint=dint
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
c   December 22, 2012
c
c   Comment out for now
c
c          subroutine newcomputeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
c     &       atmT,atmg,atmmu,Nmu,
c     &       atmint,Tmax,Tmin,gmax,gmin,outinty,
c     @       icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,itguess,imuguess)
cc
c          implicit double precision (a-h,o-z)
cc
c          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
c     %       atmint(maxlines,maxmu,8),Nmu(maxlines),outinty(8),
c     @       tempgh(200),tempgl(200),ghinty(200,8),yscratch(200),
c     @       tscratch(2),glinty(200,8),tinty(2,8),y2scratch(2)
cc
c
c          dimension scalex1(200,20),scaley1(200,20)
c          dimension scalex2(200,20),scaley2(200,20)
c          dimension scalex3(200,20),scaley3(200,20)
c          dimension scalex4(200,20),scaley4(200,20)
c          dimension scalex5(200,20),scaley5(200,20)
c          dimension scalex6(200,20),scaley6(200,20)
c          dimension scalex7(200,20),scaley7(200,20)
c          dimension scalex8(200,20),scaley8(200,20)
cc          dimension stdscalex(100),stdscaley(100)
cc          dimension stdscalex(50),stdscaley(50)
c          dimension stdscalex(36),stdscaley(36)
c          dimension Ngmu(20)
c          dimension gscratch1(2),gscratch2(2),gscratch3(2),gscratch4(2)
c          dimension gscratch5(2),gscratch6(2),gscratch7(2),gscratch8(2)
c          dimension gx1(20),gy1(20)
c          dimension gx2(20),gy2(20)
c          dimension gx3(20),gy3(20)
c          dimension gx4(20),gy4(20)
c          dimension gx5(20),gy5(20)
c          dimension gx6(20),gy6(20)
c          dimension gx7(20),gy7(20)
c          dimension gx8(20),gy8(20)
c          dimension finalx1(200),finaly1(200)
c          dimension finalx2(200),finaly2(200)
c          dimension finalx3(200),finaly3(200)
c          dimension finalx4(200),finaly4(200)
c          dimension finalx5(200),finaly5(200)
c          dimension finalx6(200),finaly6(200)
c          dimension finalx7(200),finaly7(200)
c          dimension finalx8(200),finaly8(200)
c          dimension scrx(200),scry(200)
c          dimension peakx(20)
c          dimension peaky1(20),peaky2(20),peaky3(20),peaky4(20)
c          dimension peaky5(20),peaky6(20),peaky7(20),peaky8(20)
c          data stdscalex/0.003,0.01d0,0.03d0,0.06d0,0.09d0,0.12d0,
c     %                   0.15d0,0.18d0,0.21d0,0.24d0,0.27d0,
c     @                   0.30d0,0.33d0,0.36d0,0.39d0,
c     %                   0.42d0,0.45d0,0.48d0,0.51d0,
c     @                   0.54d0,0.57d0,0.60d0,
c     %                   0.63d0,0.66d0,0.69d0,0.72d0,0.75d0,
c     @                   0.78d0,0.81d0,0.84d0,0.87d0,
c     %                   0.90d0,0.93d0,0.96d0,0.99,1.00d0/
c
cc          data stdscalex/0.02d0,0.04d0,
cc     @                   0.06d0,0.08d0,0.10d0,
cc     %                   0.12d0,0.14d0,0.16d0,
cc     @                   0.18d0,0.20d0,
cc     %                   0.22d0,0.24d0,0.26d0,
cc     @                   0.28d0,0.30d0,
cc     %                   0.32d0,0.34d0,0.36d0,
cc     @                   0.38d0,0.40d0,
cc     %                   0.42d0,0.44d0,0.46d0,
cc     @                   0.48d0,0.50d0,
cc     %                   0.52d0,0.54d0,0.56d0,
cc     @                   0.58d0,0.60d0,
cc     %                   0.62d0,0.64d0,0.66d0,
cc     @                   0.68d0,0.70d0,
cc     %                   0.72d0,0.74d0,0.76d0,
cc     @                   0.78d0,0.80d0,
cc     %                   0.82d0,0.84d0,0.86d0,
cc     @                   0.88d0,0.90d0,
cc     %                   0.92d0,0.94d0,0.96d0,
cc     @                   0.98d0,1.00d0/
c
cC          data stdscalex/0.01d0,0.02d0,0.03d0,0.04d0,0.05d0,
cC     @                   0.06d0,0.07d0,0.08d0,0.09d0,0.10d0,
cC     %                   0.11d0,0.12d0,0.13d0,0.14d0,0.15d0,
cC     @                   0.16d0,0.17d0,0.18d0,0.19d0,0.20d0,
cC     %                   0.21d0,0.22d0,0.23d0,0.24d0,0.25d0,
cC     @                   0.26d0,0.27d0,0.28d0,0.29d0,0.30d0,
cC     %                   0.31d0,0.32d0,0.33d0,0.34d0,0.35d0,
cC     @                   0.36d0,0.37d0,0.38d0,0.39d0,0.40d0,
cC     %                   0.41d0,0.42d0,0.43d0,0.44d0,0.45d0,
cC     @                   0.46d0,0.47d0,0.48d0,0.49d0,0.50d0,
cC     %                   0.51d0,0.52d0,0.53d0,0.54d0,0.55d0,
cC     @                   0.56d0,0.57d0,0.58d0,0.59d0,0.60d0,
cC     %                   0.61d0,0.62d0,0.63d0,0.64d0,0.65d0,
cC     @                   0.66d0,0.67d0,0.68d0,0.69d0,0.70d0,
cC     %                   0.71d0,0.72d0,0.73d0,0.74d0,0.75d0,
cC     @                   0.76d0,0.77d0,0.78d0,0.79d0,0.80d0,
cC     %                   0.81d0,0.82d0,0.83d0,0.84d0,0.85d0,
cC     @                   0.86d0,0.87d0,0.88d0,0.89d0,0.90d0,
cC     %                   0.91d0,0.92d0,0.93d0,0.94d0,0.95d0,
cC     @                   0.96d0,0.97d0,0.98d0,0.99d0,1.00d0/
cc
cc
cc         if(rmuin.gt.0.69d0)then
cc            call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
cc     &        atmT,atmg,atmmu,Nmu,
cc     &        atmint,Tmax,Tmin,gmax,gmin,outinty)
cc            return
cc          endif
cc
cc          write(*,*)icnU,icnB,icnV,icnR
c
c          gl1=4.0d0
c          gl2=4.0d0
c          gl3=4.0d0
c          tempmu=1.0d0
c          call locate(atmT,Nlines,Tin,indexT)
cc
cc          call hunt(atmT,Nlines,Tin,itguess)
cc
cc          indexT=itguess
cc
cc   indexT is index where the temperature is less than Tin.
cc
cc   For all temperature values equal to atmT(indexT), produce arrays
cc   of (inty,mu), and interpolate mu(inty=stdval) vs. g curves to
cc   produce the limb darkening curve for log(g)=gin.  Then given this,
cc   produce the intensity at mu=rmuin.
cc
c          tscratch(1)=atmT(indexT+1)
cc
cc   Now search the Tvalues equal to atmT(indexT+1) and find intensities
cc   for all of the g values.
cc
c          igcount=0
c          do 600 i=0,Nlines-(indexT+1)
c            if(atmT(indexT+1+i).eq.atmT(indexT+1))then
c              igcount=igcount+1
c              tempgl(igcount)=atmg(indexT+1+i)
c            endif
c 600      continue
c          call locate(tempgl,igcount,gin,index1)
c          if(index1.le.2)then
c            gl1=tempgl(1)
c            gl2=tempgl(2)
c            gl3=tempgl(3)
c          endif
c          if(index1.ge.igcount)then
c            gl1=tempgl(igcount-2)
c            gl2=tempgl(igcount-1)
c            gl3=tempgl(igcount)
c          endif
c          if((index1.gt.2).and.(index1.lt.igcount))then
c            gl1=tempgl(index1-1)
c            gl2=tempgl(index1)
c            gl3=tempgl(index1+1)
c          endif
cc
c          N=36
c          Nhigh=0
c          igcount=0
c          do 10 i=0,Nlines-(indexT+1)
c            if(atmT(indexT+1+i).eq.atmT(indexT+1))then
c              fredg=atmg(indexT+1+i)
c              if((fredg.eq.gl1).or.(fredg.eq.gl2).or.(fredg.eq.gl3))then
c                igcount=igcount+1
c                tempgh(igcount)=atmg(indexT+1+i)
cc                Ngmu(igcount)=Nmu(indexT+1+i)
c                Ngmu(igcount)=0
c                do 1 j=1,Nmu(indexT+1+i)
c                  tempmu=atmmu(indexT+1+i,j)
c                  dl=rmuin  -1.0d0
c                  dh=rmuin  +1.0d0
c                  if((j.eq.1).or.(j.eq.Nmu(indexT+1+i)).or.
c     $              ((tempmu.ge.dl).and.(tempmu.le.dh)))then
cc
c                    Ngmu(igcount)=Ngmu(igcount)+1
c                    jjj=Ngmu(igcount)
cc
c                    if(icnU.ne.430)then
c                      scalex1(jjj,igcount)=atmint(indexT+1+i,j,1)
c                      scaley1(jjj,igcount)=tempmu
c                    endif
c                    if(icnB.ne.430)then
c                      scalex2(jjj,igcount)=atmint(indexT+1+i,j,2)
c                      scaley2(jjj,igcount)=tempmu
c                    endif
c                    if(icnV.ne.430)then
c                      scalex3(jjj,igcount)=atmint(indexT+1+i,j,3)
c                      scaley3(jjj,igcount)=tempmu
c                    endif
c                    if(icnR.ne.430)then
c                      scalex4(jjj,igcount)=atmint(indexT+1+i,j,4)
c                      scaley4(jjj,igcount)=tempmu
c                    endif
c                    if(icnI.ne.430)then
c                      scalex5(jjj,igcount)=atmint(indexT+1+i,j,5)
c                      scaley5(jjj,igcount)=tempmu
c                    endif
c                    if(icnJ.ne.430)then
c                      scalex6(jjj,igcount)=atmint(indexT+1+i,j,6)
c                      scaley6(jjj,igcount)=tempmu
c                    endif
c                    if(icnH.ne.430)then
c                      scalex7(jjj,igcount)=atmint(indexT+1+i,j,7)
c                      scaley7(jjj,igcount)=tempmu
c                    endif
c                    if(icnK.ne.430)then
c                      scalex8(jjj,igcount)=atmint(indexT+1+i,j,8)
c                      scaley8(jjj,igcount)=tempmu
c                    endif
c                  endif
c1               continue
cc                write(*,*)jjj,igcount
c              endif
c            else
c              go to 15
c            endif
c10        continue
cc
cc   Establish the intensity at mu=1 for log(g)=gin
cc
c15         do 500 ig=1,igcount
c             if(icnU.ne.430)peaky1(ig)=scalex1(Ngmu(ig),ig)
c             if(icnB.ne.430)peaky2(ig)=scalex2(Ngmu(ig),ig)
c             if(icnV.ne.430)peaky3(ig)=scalex3(Ngmu(ig),ig)
c             if(icnR.ne.430)peaky4(ig)=scalex4(Ngmu(ig),ig)
c             if(icnI.ne.430)peaky5(ig)=scalex5(Ngmu(ig),ig)
c             if(icnJ.ne.430)peaky6(ig)=scalex6(Ngmu(ig),ig)
c             if(icnH.ne.430)peaky7(ig)=scalex7(Ngmu(ig),ig)
c             if(icnK.ne.430)peaky8(ig)=scalex8(Ngmu(ig),ig)
c500        continue
cc
c           call locate(tempgh,igcount,gin,index1)
c           m=2
c           k=min(max(index1-(m-1)/2,1),igcount+1-m)
c           if(icnU.ne.430)call polint(tempgh(k),peaky1(k),m,gin,qqq1,dy)
c           if(icnB.ne.430)call polint(tempgh(k),peaky2(k),m,gin,qqq2,dy)
c           if(icnV.ne.430)call polint(tempgh(k),peaky3(k),m,gin,qqq3,dy)
c           if(icnR.ne.430)call polint(tempgh(k),peaky4(k),m,gin,qqq4,dy)
c           if(icnI.ne.430)call polint(tempgh(k),peaky5(k),m,gin,qqq5,dy)
c           if(icnJ.ne.430)call polint(tempgh(k),peaky6(k),m,gin,qqq6,dy)
c           if(icnH.ne.430)call polint(tempgh(k),peaky7(k),m,gin,qqq7,dy)
c           if(icnK.ne.430)call polint(tempgh(k),peaky8(k),m,gin,qqq8,dy)
cc
cc   Now loop over the scalex1 array and find the mu where the intensity
cc   is equal to the peak, 0.98*peak, 0.96*peak, etc.
cc
c           do 20 i=1,N
c             do 11 ig=1,igcount
c               if(icnU.ne.430)scale1=scalex1(Ngmu(ig),ig)*stdscalex(i)
c               if(icnB.ne.430)scale2=scalex2(Ngmu(ig),ig)*stdscalex(i)
c               if(icnV.ne.430)scale3=scalex3(Ngmu(ig),ig)*stdscalex(i)
c               if(icnR.ne.430)scale4=scalex4(Ngmu(ig),ig)*stdscalex(i)
c               if(icnI.ne.430)scale5=scalex5(Ngmu(ig),ig)*stdscalex(i)
c               if(icnJ.ne.430)scale6=scalex6(Ngmu(ig),ig)*stdscalex(i)
c               if(icnH.ne.430)scale7=scalex7(Ngmu(ig),ig)*stdscalex(i)
c               if(icnK.ne.430)scale8=scalex8(Ngmu(ig),ig)*stdscalex(i)
cc
c               ifred=0
c               rlowmu=rmuin-0.1d0
c               rhighmu=rmuin+0.1d0
c
c               if(icnU.ne.430)then
c                 do 101 j=1,Ngmu(ig)
c                   scrx(j)=scalex1(j,ig)
c                   scry(j)=scaley1(j,ig)
c101              continue
c                 call locate(scrx,Ngmu(ig),scale1,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale1,qqq,dy)
c                 gx1(ig)=tempgh(ig)
c                 gy1(ig)=qqq
c               endif
cc
c               if(icnB.ne.430)then
c                 do 102 j=1,Ngmu(ig)
c                   scrx(j)=scalex2(j,ig)
c                   scry(j)=scaley2(j,ig)
c102              continue
c                 call locate(scrx,Ngmu(ig),scale2,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale2,qqq,dy)
c                 gx2(ig)=tempgh(ig)
c                 gy2(ig)=qqq
c               endif
cc
c               if(icnV.ne.430)then
c                 do 103 j=1,Ngmu(ig)
c                   scrx(j)=scalex3(j,ig)
c                   scry(j)=scaley3(j,ig)
c103              continue
c                 call locate(scrx,Ngmu(ig),scale3,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale3,qqq,dy)
c                 gx3(ig)=tempgh(ig)
c                 gy3(ig)=qqq
c               endif
cc
c               if(icnR.ne.430)then
c                 do 104 j=1,Ngmu(ig)
c                   scrx(j)=scalex4(j,ig)
c                   scry(j)=scaley4(j,ig)
c104              continue
c                 call locate(scrx,Ngmu(ig),scale4,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale4,qqq,dy)
c                 gx4(ig)=tempgh(ig)
c                 gy4(ig)=qqq
c               endif
cc
c               if(icnI.ne.430)then
c                 do 105 j=1,Ngmu(ig)
c                   scrx(j)=scalex5(j,ig)
c                   scry(j)=scaley5(j,ig)
c105              continue
c                 call locate(scrx,Ngmu(ig),scale5,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale5,qqq,dy)
c                 gx5(ig)=tempgh(ig)
c                 gy5(ig)=qqq
c               endif
cc
c               if(icnJ.ne.430)then
c                 do 106 j=1,Ngmu(ig)
c                   scrx(j)=scalex6(j,ig)
c                   scry(j)=scaley6(j,ig)
c106              continue
c                 call locate(scrx,Ngmu(ig),scale6,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale6,qqq,dy)
c                 gx6(ig)=tempgh(ig)
c                 gy6(ig)=qqq
c               endif
cc
c               if(icnH.ne.430)then
c                 do 107 j=1,Ngmu(ig)
c                   scrx(j)=scalex7(j,ig)
c                   scry(j)=scaley7(j,ig)
c107              continue
c                 call locate(scrx,Ngmu(ig),scale7,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale7,qqq,dy)
c                 gx7(ig)=tempgh(ig)
c                 gy7(ig)=qqq
c               endif
cc
c               if(icnK.ne.430)then
c                 do 108 j=1,Ngmu(ig)
c                   scrx(j)=scalex8(j,ig)
c                   scry(j)=scaley8(j,ig)
c108              continue
c                 call locate(scrx,Ngmu(ig),scale8,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale8,qqq,dy)
c                 gx8(ig)=tempgh(ig)
c                 gy8(ig)=qqq
c               endif
cc
c11           continue
cc
c             if(icnU.ne.430)then
c               call polint(gx1,gy1,igcount,gin,qqq,dy)
c               finalx1(i)=qqq
c               finaly1(i)=stdscalex(i)*qqq1
c             endif
cc
c             if(icnB.ne.430)then
c               call polint(gx2,gy2,igcount,gin,qqq,dy)
c               finalx2(i)=qqq
c               finaly2(i)=stdscalex(i)*qqq2
c             endif
cc
c             if(icnV.ne.430)then
c               call polint(gx3,gy3,igcount,gin,qqq,dy)
c               finalx3(i)=qqq
c               finaly3(i)=stdscalex(i)*qqq3
c             endif
cc
c             if(icnR.ne.430)then
c               call polint(gx4,gy4,igcount,gin,qqq,dy)
c               finalx4(i)=qqq
c               finaly4(i)=stdscalex(i)*qqq4
c             endif
cc
c             if(icnI.ne.430)then
c               call polint(gx5,gy5,igcount,gin,qqq,dy)
c               finalx5(i)=qqq
c               finaly5(i)=stdscalex(i)*qqq5
c             endif
cc
c             if(icnJ.ne.430)then
c               call polint(gx6,gy6,igcount,gin,qqq,dy)
c               finalx6(i)=qqq
c               finaly6(i)=stdscalex(i)*qqq6
c             endif
cc
c             if(icnH.ne.430)then
c               call polint(gx7,gy7,igcount,gin,qqq,dy)
c               finalx7(i)=qqq
c               finaly7(i)=stdscalex(i)*qqq7
c             endif
cc
c             if(icnK.ne.430)then
c               call polint(gx8,gy8,igcount,gin,qqq,dy)
c               finalx8(i)=qqq
c               finaly8(i)=stdscalex(i)*qqq8
c             endif
cc
c20         continue
cc
c           if(icnU.ne.430)then
c             call locate(finalx1,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx1(k),finaly1(k),m,rmuin,qqq,dy)
c               gscratch1(1)=qqq
c             else
c               gscratch1(1)=finaly1(1)
c             endif
c           endif
cc
c           if(icnB.ne.430)then
c             call locate(finalx2,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx2(k),finaly2(k),m,rmuin,qqq,dy)
c               gscratch2(1)=qqq
c             else
c               gscratch2(1)=finaly2(1)
c             endif
c           endif
cc
c           if(icnV.ne.430)then
c             call locate(finalx3,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx3(k),finaly3(k),m,rmuin,qqq,dy)
c               gscratch3(1)=qqq
c             else
c               gscratch3(1)=finaly3(1)
c             endif
c           endif
cc
c           if(icnR.ne.430)then
c             call locate(finalx4,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx4(k),finaly4(k),m,rmuin,qqq,dy)
c               gscratch4(1)=qqq
c             else
c               gscratch4(1)=finaly4(1)
c             endif
c           endif
cc
c           if(icnI.ne.430)then
c             call locate(finalx5,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx5(k),finaly5(k),m,rmuin,qqq,dy)
c               gscratch5(1)=qqq
c             else
c               gscratch5(1)=finaly5(1)
c             endif
c           endif
cc
c           if(icnJ.ne.430)then
c             call locate(finalx6,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx6(k),finaly6(k),m,rmuin,qqq,dy)
c               gscratch6(1)=qqq
c             else
c               gscratch6(1)=finaly6(1)
c             endif
c           endif
cc
c           if(icnH.ne.430)then
c             call locate(finalx7,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx7(k),finaly7(k),m,rmuin,qqq,dy)
c               gscratch7(1)=qqq
c             else
c               gscratch7(1)=finaly7(1)
c             endif
c           endif
cc
c           if(icnK.ne.430)then
c             call locate(finalx8,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx8(k),finaly8(k),m,rmuin,qqq,dy)
c               gscratch8(1)=qqq
c             else
c               gscratch8(1)=finaly8(1)
c             endif
c           endif
cc
cc   Now search the Tvalues equal to atmT(indexT+1) and find intensities
cc   for all of the g values.
cc
c          tscratch(2)=atmT(indexT)
cc
cc   Now search the Tvalues equal to atmT(indexT+1) and find intensities
cc   for all of the g values.
cc
c          igcount=0
c          do 601 i=0,Nlines-(indexT+1)
c            if(atmT(indexT+1+i).eq.atmT(indexT+1))then
c              igcount=igcount+1
c              tempgl(igcount)=atmg(indexT+1+i)
c            endif
c 601     continue
c          call locate(tempgl,igcount,gin,index1)
c          if(index1.le.2)then
c            gl1=tempgl(1)
c            gl2=tempgl(2)
c            gl3=tempgl(3)
c          endif
c          if(index1.ge.igcount)then
c            gl1=tempgl(igcount-2)
c            gl2=tempgl(igcount-1)
c            gl3=tempgl(igcount)
c          endif
c          if((index1.gt.2).and.(index1.lt.igcount))then
c            gl1=tempgl(index1-1)
c            gl2=tempgl(index1)
c            gl3=tempgl(index1+1)
c          endif
cc
c          Nhigh=0
c          igcount=0
c          do 30 i=0,indexT-1
c            if(atmT(indexT-i).eq.atmT(indexT))then
c              fredg=atmg(indexT-i)
c              if((fredg.eq.gl1).or.(fredg.eq.gl2).or.(fredg.eq.gl3))then
c                igcount=igcount+1
c                tempgh(igcount)=atmg(indexT-i)
cc                Ngmu(igcount)=Nmu(indexT-i)
c                Ngmu(igcount)=0
c                do 31 j=1,Nmu(indexT-i)
c                  dl=rmuin -1.0d0
c                  dh=rmuin +1.0d0
c                  if((j.eq.1).or.(j.eq.Nmu(indexT+1+i)).or.
c     $              ((tempmu.ge.dl).and.(tempmu.le.dh)))then
c                    Ngmu(igcount)=Ngmu(igcount)+1
c                    jjj=Ngmu(igcount)
c                    if(icnU.ne.430)then
c                      scalex1(jjj,igcount)=atmint(indexT-i,j,1)
c                      scaley1(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnB.ne.430)then
c                      scalex2(jjj,igcount)=atmint(indexT-i,j,2)
c                      scaley2(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnV.ne.430)then
c                      scalex3(jjj,igcount)=atmint(indexT-i,j,3)
c                      scaley3(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnR.ne.430)then
c                      scalex4(jjj,igcount)=atmint(indexT-i,j,4)
c                      scaley4(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnI.ne.430)then
c                      scalex5(jjj,igcount)=atmint(indexT-i,j,5)
c                      scaley5(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnJ.ne.430)then
c                      scalex6(jjj,igcount)=atmint(indexT-i,j,6)
c                      scaley6(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnH.ne.430)then
c                      scalex7(jjj,igcount)=atmint(indexT-i,j,7)
c                      scaley7(jjj,igcount)=atmmu(indexT-i,j)
c                    endif
c                    if(icnK.ne.430)then
c                      scalex8(j,igcount)=atmint(indexT-i,j,8)
c                      scaley8(j,igcount)=atmmu(indexT-i,j)
c                    endif
c                  endif
c31              continue
c              endif
c            else
c              go to 25
c            endif
c30        continue
c25        do 501 ig=1,igcount
c            if(icnU.ne.430)peaky1(ig)=scalex1(Ngmu(ig),ig)
c            if(icnB.ne.430)peaky2(ig)=scalex2(Ngmu(ig),ig)
c            if(icnV.ne.430)peaky3(ig)=scalex3(Ngmu(ig),ig)
c            if(icnR.ne.430)peaky4(ig)=scalex4(Ngmu(ig),ig)
c            if(icnI.ne.430)peaky5(ig)=scalex5(Ngmu(ig),ig)
c            if(icnJ.ne.430)peaky6(ig)=scalex6(Ngmu(ig),ig)
c            if(icnH.ne.430)peaky7(ig)=scalex7(Ngmu(ig),ig)
c            if(icnK.ne.430)peaky8(ig)=scalex8(Ngmu(ig),ig)
c501       continue
cc
c          call locate(tempgh,igcount,gin,index1)
c          m=2
c          k=min(max(index1-(m-1)/2,1),igcount+1-m)
c          if(icnU.ne.430)call polint(tempgh(k),peaky1(k),m,gin,qqq1,dy)
c          if(icnB.ne.430)call polint(tempgh(k),peaky2(k),m,gin,qqq2,dy)
c          if(icnV.ne.430)call polint(tempgh(k),peaky3(k),m,gin,qqq3,dy)
c          if(icnR.ne.430)call polint(tempgh(k),peaky4(k),m,gin,qqq4,dy)
c          if(icnI.ne.430)call polint(tempgh(k),peaky5(k),m,gin,qqq5,dy)
c          if(icnJ.ne.430)call polint(tempgh(k),peaky6(k),m,gin,qqq6,dy)
c          if(icnH.ne.430)call polint(tempgh(k),peaky7(k),m,gin,qqq7,dy)
c          if(icnK.ne.430)call polint(tempgh(k),peaky8(k),m,gin,qqq8,dy)
cc
cc   Now loop over the scalex1 array and find the mu where the intensity
cc   is equal to the peak, 0.98*peak, 0.96*peak, etc.
cc
c           do 40 i=1,N
c             do 21 ig=1,igcount
c               if(icnU.ne.430)scale1=scalex1(Ngmu(ig),ig)*stdscalex(i)
c               if(icnB.ne.430)scale2=scalex2(Ngmu(ig),ig)*stdscalex(i)
c               if(icnV.ne.430)scale3=scalex3(Ngmu(ig),ig)*stdscalex(i)
c               if(icnR.ne.430)scale4=scalex4(Ngmu(ig),ig)*stdscalex(i)
c               if(icnI.ne.430)scale5=scalex5(Ngmu(ig),ig)*stdscalex(i)
c               if(icnJ.ne.430)scale6=scalex6(Ngmu(ig),ig)*stdscalex(i)
c               if(icnH.ne.430)scale7=scalex7(Ngmu(ig),ig)*stdscalex(i)
c               if(icnK.ne.430)scale8=scalex8(Ngmu(ig),ig)*stdscalex(i)
cc
c               if(icnU.ne.430)then
c                 do 201 j=1,Ngmu(ig)
c                   scrx(j)=scalex1(j,ig)
c                   scry(j)=scaley1(j,ig)
c201              continue
c                 call locate(scrx,Ngmu(ig),scale1,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale1,qqq,dy)
c                 gx1(ig)=tempgh(ig)
c                 gy1(ig)=qqq
c               endif
cc
c               if(icnB.ne.430)then
c                 do 202 j=1,Ngmu(ig)
c                   scrx(j)=scalex2(j,ig)
c                   scry(j)=scaley2(j,ig)
c202              continue
c                 call locate(scrx,Ngmu(ig),scale2,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale2,qqq,dy)
c                 gx2(ig)=tempgh(ig)
c                 gy2(ig)=qqq
c               endif
cc
c               if(icnV.ne.430)then
c                 do 203 j=1,Ngmu(ig)
c                   scrx(j)=scalex3(j,ig)
c                   scry(j)=scaley3(j,ig)
c203              continue
c                 call locate(scrx,Ngmu(ig),scale3,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale3,qqq,dy)
c                 gx3(ig)=tempgh(ig)
c                 gy3(ig)=qqq
c               endif
cc
c               if(icnR.ne.430)then
c                 do 204 j=1,Ngmu(ig)
c                   scrx(j)=scalex4(j,ig)
c                   scry(j)=scaley4(j,ig)
c204              continue
c                 call locate(scrx,Ngmu(ig),scale4,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale4,qqq,dy)
c                 gx4(ig)=tempgh(ig)
c                 gy4(ig)=qqq
c               endif
cc
c               if(icnI.ne.430)then
c                 do 205 j=1,Ngmu(ig)
c                   scrx(j)=scalex5(j,ig)
c                   scry(j)=scaley5(j,ig)
c205              continue
c                 call locate(scrx,Ngmu(ig),scale5,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale5,qqq,dy)
c                 gx5(ig)=tempgh(ig)
c                 gy5(ig)=qqq
c               endif
cc
c               if(icnJ.ne.430)then
c                 do 206 j=1,Ngmu(ig)
c                   scrx(j)=scalex6(j,ig)
c                   scry(j)=scaley6(j,ig)
c206              continue
c                 call locate(scrx,Ngmu(ig),scale6,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale6,qqq,dy)
c                 gx6(ig)=tempgh(ig)
c                 gy6(ig)=qqq
c               endif
cc
c               if(icnH.ne.430)then
c                 do 207 j=1,Ngmu(ig)
c                   scrx(j)=scalex7(j,ig)
c                   scry(j)=scaley7(j,ig)
c207              continue
c                 call locate(scrx,Ngmu(ig),scale7,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale7,qqq,dy)
c                 gx7(ig)=tempgh(ig)
c                 gy7(ig)=qqq
c               endif
cc
c               if(icnK.ne.430)then
c                 do 208 j=1,Ngmu(ig)
c                   scrx(j)=scalex8(j,ig)
c                   scry(j)=scaley8(j,ig)
c208              continue
c                 call locate(scrx,Ngmu(ig),scale8,index1)
c                 m=2
c                 k=min(max(index1-(m-1)/2,1),Ngmu(ig)+1-m)
c                 call polint(scrx(k),scry(k),m,scale8,qqq,dy)
c                 gx8(ig)=tempgh(ig)
c                 gy8(ig)=qqq
c               endif
cc
c21           continue
cc
c             if(icnU.ne.430)then
c               call polint(gx1,gy1,igcount,gin,qqq,dy)
c               finalx1(i)=qqq
c               finaly1(i)=stdscalex(i)*qqq1
c             endif
cc
c             if(icnB.ne.430)then
c               call polint(gx2,gy2,igcount,gin,qqq,dy)
c               finalx2(i)=qqq
c               finaly2(i)=stdscalex(i)*qqq2
c             endif
cc
c             if(icnV.ne.430)then
c               call polint(gx3,gy3,igcount,gin,qqq,dy)
c               finalx3(i)=qqq
c               finaly3(i)=stdscalex(i)*qqq3
c             endif
cc
c             if(icnR.ne.430)then
c               call polint(gx4,gy4,igcount,gin,qqq,dy)
c               finalx4(i)=qqq
c               finaly4(i)=stdscalex(i)*qqq4
c             endif
cc
c             if(icnI.ne.430)then
c               call polint(gx5,gy5,igcount,gin,qqq,dy)
c               finalx5(i)=qqq
c               finaly5(i)=stdscalex(i)*qqq5
c             endif
cc
c             if(icnJ.ne.430)then
c               call polint(gx6,gy6,igcount,gin,qqq,dy)
c               finalx6(i)=qqq
c               finaly6(i)=stdscalex(i)*qqq6
c             endif
cc
c             if(icnH.ne.430)then
c               call polint(gx7,gy7,igcount,gin,qqq,dy)
c               finalx7(i)=qqq
c               finaly7(i)=stdscalex(i)*qqq7
c             endif
cc
c             if(icnK.ne.430)then
c               call polint(gx8,gy8,igcount,gin,qqq,dy)
c               finalx8(i)=qqq
c               finaly8(i)=stdscalex(i)*qqq8
c             endif
cc
c40         continue
cc
c           if(icnU.ne.430)then
c             call locate(finalx1,N,rmuin,muindex)
c             if(muindex.gt.0)then  !(rmuin.ge.finalx1(1))then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx1(k),finaly1(k),m,rmuin,qqq,dy)
c               gscratch1(2)=qqq
c             else
c               gscratch1(2)=finaly1(1)
c             endif
c           endif
cc
c           if(icnB.ne.430)then
c             call locate(finalx2,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx2(k),finaly2(k),m,rmuin,qqq,dy)
c               gscratch2(2)=qqq
c             else
c               gscratch2(2)=finaly2(1)
c             endif
c           endif
cc
c           if(icnV.ne.430)then
c             call locate(finalx3,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx3(k),finaly3(k),m,rmuin,qqq,dy)
c               gscratch3(2)=qqq
c             else
c               gscratch3(2)=finaly3(1)
c             endif
c           endif
cc
c           if(icnR.ne.430)then
c             call locate(finalx4,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx4(k),finaly4(k),m,rmuin,qqq,dy)
c               gscratch4(2)=qqq
c             else
c               gscratch4(2)=finaly4(1)
c             endif
c           endif
cc
c           if(icnI.ne.430)then
c             call locate(finalx5,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx5(k),finaly5(k),m,rmuin,qqq,dy)
c               gscratch5(2)=qqq
c             else
c               gscratch5(2)=finaly5(1)
c             endif
c           endif
cc
c           if(icnJ.ne.430)then
c             call locate(finalx6,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx6(k),finaly6(k),m,rmuin,qqq,dy)
c               gscratch6(2)=qqq
c             else
c               gscratch6(2)=finaly6(1)
c             endif
c           endif
cc
c           if(icnH.ne.430)then
c             call locate(finalx7,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx7(k),finaly7(k),m,rmuin,qqq,dy)
c               gscratch7(2)=qqq
c             else
c               gscratch7(2)=finaly7(1)
c             endif
c           endif
cc
c           if(icnK.ne.430)then
c             call locate(finalx8,N,rmuin,muindex)
c             if(muindex.gt.0)then
c               m=2
c               k=min(max(muindex-(m-1)/2,1),N+1-m)
c               call polint(finalx8(k),finaly8(k),m,rmuin,qqq,dy)
c               gscratch8(2)=qqq
c             else
c               gscratch8(2)=finaly8(1)
c             endif
c           endif
cc
cc   Finally, take the final pass and interpolate between T
cc
c           if(icnU.ne.430)then
c             call polint(tscratch,gscratch1,m,Tin,qqq,dy)
c             outinty(1)=qqq
c           endif
c           if(icnB.ne.430)then
c             call polint(tscratch,gscratch2,m,Tin,qqq,dy)
c             outinty(2)=qqq
c           endif
c           if(icnV.ne.430)then
c             call polint(tscratch,gscratch3,m,Tin,qqq,dy)
c             outinty(3)=qqq
c           endif
c           if(icnR.ne.430)then
c             call polint(tscratch,gscratch4,m,Tin,qqq,dy)
c             outinty(4)=qqq
c           endif
c           if(icnI.ne.430)then
c             call polint(tscratch,gscratch5,m,Tin,qqq,dy)
c             outinty(5)=qqq
c           endif
c           if(icnJ.ne.430)then
c             call polint(tscratch,gscratch6,m,Tin,qqq,dy)
c             outinty(6)=qqq
c           endif
c           if(icnH.ne.430)then
c             call polint(tscratch,gscratch7,m,Tin,qqq,dy)
c             outinty(7)=qqq
c           endif
c           if(icnK.ne.430)then
c             call polint(tscratch,gscratch8,m,Tin,qqq,dy)
c             outinty(8)=qqq
c           endif
cc
c 300      continue
cc
c
cc
c          return
c          end
c
c !@#$%&*&%$#@!!@#$%&*&%$#@!!@#$%&*&%$#@!!@#$%&*&%$#@!
c
          subroutine distorttime(Nmaxphase,Nphase,xmod,yeclipse,RV,
     @       gamma,pconj)
c
c   February 5, 2001
c
c   This routine will apply a phase shift to a light or velocity curve

c   
          implicit double precision(a-h,o-z)
c
          parameter(NNdum=720001,speed=2.99792458d5)
          dimension xmod(Nmaxphase),yeclipse(Nmaxphase)
          dimension RV(Nmaxphase)
c

          do 10 i=1,Nphase
c            write(*,*)xmod(i),yeclipse(i)
             if(yeclipse(i).gt.0.0d0)then
               if(xmod(i).lt.0.5d0)then
                 ttt=(RV(i)-gamma)/speed*(xmod(i)-pconj)
c                 write(*,*)ttt
                 xmod(i)=xmod(i)+ttt
                else
                 ttt=(RV(i)-gamma)/speed*(xmod(i)-(pconj+1.0d0))
c                 write(*,*)ttt
                 xmod(i)=xmod(i)+ttt
                endif
             endif
 10       continue
c
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getfracs(Nmaxphase,icount,fracs1,fracs2,fracs3,
     @      fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,dphase,
     %      eshift,pshift,ionephase,ism1,ecc,sw26)
c
c   October 10, 2007
c
c   This is a new routine that will return the luminosity ratios in
c   each bandpass.  compfracs(i,1) will have L_2/L_1, and
c   compfracs(i,2) will have L_disk/L_tot.
c
          implicit double precision(a-h,o-z)
c
          dimension compfracs(8,3)
          dimension fracs1(Nmaxphase,4),fracs2(Nmaxphase,4)
          dimension fracs3(Nmaxphase,4),fracs4(Nmaxphase,4)
          dimension fracs5(Nmaxphase,4),fracs6(Nmaxphase,4)
          dimension fracs7(Nmaxphase,4),fracs8(Nmaxphase,4)
c
          parameter(kkk=720001)  !Nmaxphase
          dimension scratch1(kkk),scratch2(kkk),xscratch(kkk)
          dimension scratch3(kkk)
c
          aaa=1.0d0
          bbb=1.0d0
          ccc=1.0d0
          eee=1.0d0
          do 10 i=1,8     !loop over filters
c
c   UPDATE October 27, 2008
c
c   First, 'finish' the fraction curves
c
            iii=icount-1
            NNN=icount
            if((ionephase.eq.0).and.(ism1.ge.1).and.(ecc.eq.0.0d0))then
c
              Nloop=0
              iloop=1
              phase=180.0d0
              Nloop=idint(((360.0d0-dphase)-(180.0d0+dphase))/dphase)
c       
c              do 1 phase=180.0d0+dphase,360.0d0-dphase,dphase
c
              do 1 iloop=1,Nloop+1
                phase=phase+dphase  
                NNN=NNN+1
                if(i.eq.1)then
                  fracs1(NNN,1)=fracs1(iii,1)
                  fracs1(NNN,2)=fracs1(iii,2)
                  fracs1(NNN,3)=fracs1(iii,3)
                  fracs1(NNN,4)=fracs1(iii,4)
                endif
                if(i.eq.2)then
                  fracs2(NNN,1)=fracs2(iii,1)
                  fracs2(NNN,2)=fracs2(iii,2)
                  fracs2(NNN,3)=fracs2(iii,3)
                  fracs2(NNN,4)=fracs2(iii,4)
                endif
                if(i.eq.3)then
                  fracs3(NNN,1)=fracs3(iii,1)
                  fracs3(NNN,2)=fracs3(iii,2)
                  fracs3(NNN,3)=fracs3(iii,3)
                  fracs3(NNN,4)=fracs3(iii,4)
                endif
                if(i.eq.4)then
                  fracs4(NNN,1)=fracs4(iii,1)
                  fracs4(NNN,2)=fracs4(iii,2)
                  fracs4(NNN,3)=fracs4(iii,3)
                  fracs4(NNN,4)=fracs4(iii,4)
                endif
                if(i.eq.5)then
                  fracs5(NNN,1)=fracs5(iii,1)
                  fracs5(NNN,2)=fracs5(iii,2)
                  fracs5(NNN,3)=fracs5(iii,3)
                  fracs5(NNN,4)=fracs5(iii,4)
                endif
                if(i.eq.6)then
                  fracs6(NNN,1)=fracs6(iii,1)
                  fracs6(NNN,2)=fracs6(iii,2)
                  fracs6(NNN,3)=fracs6(iii,3)
                  fracs6(NNN,4)=fracs6(iii,4)
                endif
                if(i.eq.7)then
                  fracs7(NNN,1)=fracs7(iii,1)
                  fracs7(NNN,2)=fracs7(iii,2)
                  fracs7(NNN,3)=fracs7(iii,3)
                  fracs7(NNN,4)=fracs7(iii,4)
                endif
                if(i.eq.8)then
                  fracs8(NNN,1)=fracs8(iii,1)
                  fracs8(NNN,2)=fracs8(iii,2)
                  fracs8(NNN,3)=fracs8(iii,3)
                  fracs8(NNN,4)=fracs8(iii,4)
                endif
                xscratch(NNN)=phase/360.0d0
                xscratch(iii)=xscratch(NNN)
                iii=iii-1
 1            continue
            endif
c
c  UPDATE October 27, 2008
c
c  If the variable sw26 is positive, then reference the disk fraction at 
c  sw26.   Otherwise, take the median over the whole orbit.
c   
c
            if(sw26.le.0.0d0)then
              do 8 jj=1,NNN
                if(i.eq.1)then
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
                endif
                if(i.eq.2)then
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
                endif
                if(i.eq.3)then
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
                endif
                if(i.eq.4)then
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
                endif
                if(i.eq.5)then
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
                endif
                if(i.eq.6)then
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
                endif
                if(i.eq.7)then
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
                endif
                if(i.eq.8)then
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
                endif
                ddd=aaa+bbb+ccc+eee
                if(aaa.eq.0.0d0)then
                  scratch1(jj)=0.0d0
                  scratch3(jj)=0.0d0
                else      
                  scratch1(jj)=bbb/aaa
                  scratch3(jj)=eee/aaa
                endif
                if(ddd.eq.0.0d0)then
                  scratch2(jj)=0.0d0
                else      
                  scratch2(jj)=ccc/ddd
                endif
8             continue
c  
              if(icount.le.2)then
                compfracs(i,1)=0.0d0
                compfracs(i,2)=0.0d0
                compfracs(i,3)=0.0d0
                go to 10
              endif

              if(NNN.gt.1)call sort3(NNN,scratch1,scratch2,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                rmedian1=(scratch1(NNN/2)+scratch1(NNN/2+1))/2.0
              else
                rmedian1=scratch1(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch2,scratch1,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian2=(scratch2(NNN/2)+scratch2(NNN/2+1))/2.0
              else
                rmedian2=scratch2(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch3,scratch1,scratch2)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian3=(scratch3(NNN/2)+scratch3(NNN/2+1))/2.0
              else
                rmedian3=scratch3(NNN/2+1)
              endif
c
              if(rmedian1.lt.0.0d0)rmedian1=0.0d0
              if(rmedian2.lt.0.0d0)rmedian2=0.0d0
              if(rmedian3.lt.0.0d0)rmedian3=0.0d0

              compfracs(i,1)=rmedian1
              compfracs(i,2)=rmedian2
              compfracs(i,3)=rmedian3
            else
              diffmin=123456789.0d0
              do 9 jj=1,NNN
                fred=dmod(xscratch(jj)+eshift+pshift,1.0d0)
                if(fred.lt.0.0d0)fred=fred+1.0d0
                if(fred.gt.1.0d0)fred=fred-1.0d0
                diff=dabs(fred-sw26)
                if(diff.le.diffmin)then
                  diffmin=diff

                 if(i.eq.1)then
                   aaa=fracs1(jj,1)
                   bbb=fracs1(jj,2)
                   ccc=fracs1(jj,3)
                   eee=fracs1(jj,4)
                 endif
                 if(i.eq.2)then
                   aaa=fracs2(jj,1)
                   bbb=fracs2(jj,2)
                   ccc=fracs2(jj,3)
                   eee=fracs2(jj,4)
                 endif
                 if(i.eq.3)then
                   aaa=fracs3(jj,1)
                   bbb=fracs3(jj,2)
                   ccc=fracs3(jj,3)
                   eee=fracs3(jj,4)
                 endif
                 if(i.eq.4)then
                   aaa=fracs4(jj,1)
                   bbb=fracs4(jj,2)
                   ccc=fracs4(jj,3)
                   eee=fracs4(jj,4)
                 endif
                 if(i.eq.5)then
                   aaa=fracs5(jj,1)
                   bbb=fracs5(jj,2)
                   ccc=fracs5(jj,3)
                   eee=fracs5(jj,4)
                 endif
                 if(i.eq.6)then
                   aaa=fracs6(jj,1)
                   bbb=fracs6(jj,2)
                   ccc=fracs6(jj,3)
                   eee=fracs6(jj,4)
                 endif
                 if(i.eq.7)then
                   aaa=fracs7(jj,1)
                   bbb=fracs7(jj,2)
                   ccc=fracs7(jj,3)
                   eee=fracs7(jj,4)
                 endif
                 if(i.eq.8)then
                   aaa=fracs8(jj,1)
                   bbb=fracs8(jj,2)
                   ccc=fracs8(jj,3)
                   eee=fracs8(jj,4)
                 endif
c
                  ddd=aaa+bbb+ccc+eee
                  compfracs(i,1)=bbb/aaa
                  if(ddd.eq.0.0d0)then
                    compfracs(i,2)=0.0d0
                  else
                    compfracs(i,2)=ccc/ddd
                  endif  
                  if(aaa.eq.0.0d0)then
                    compfracs(i,3)=0.0d0
                  else
                    compfracs(i,3)=eee/aaa
                  endif  
                endif
9             continue
            endif
c
10        continue
c
          return
          end
c 
c
c
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
c
          subroutine setdensity(fill1,omega,bdist,Q,period,density,
     @       tidephi,itide,ecc,thetamis,phimis)
c
c   October 10, 2008
c
c   This a new subroutine to set the mass ratio given the fill factor
c   and density.
c
          implicit double precision (a-h,o-z)  
c
          parameter(pie=3.14159265358979323d0)
c
           smmks=1.9889d30    !solar mass in kg
           p=period*24.0d0*3600.0d0
           gmsun=1.32712440018d20  !mks units
           ddd=density*1000.0d0
c
c   Have an ititial guess at Q
c
           Qhigh=0.1d0
           overQh=Qhigh
           Qlow=1.0d-20
           overQl=Qlow
           icount=1

999       Qmid=0.5d0*(Qhigh+Qlow)
          overQh=Qhigh
          overQm=Qmid
          overQl=Qlow

          call findL1(overQh,omega,x0h,1,bdist,tidephi,
     &         ecc,thetamis,phimis) 

          x=fill1*x0h
          y=0.0d0
          z=0.0d0

          call POTEN(overQh,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,bdist,
     @      cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          call findradius(overQh,omega,savepsi0,x0h*fill1,bdist,
     &      reffhigh,tidephi,itide,ecc,thetamis,phimis)


          call findL1(overQl,omega,x0l,1,bdist,tidephi,
     &       ecc,thetamis,phimis) 

          x=fill1*x0l
          y=0.0d0
          z=0.0d0
          call POTEN(overQl,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @     bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          call findradius(overQl,omega,savepsi0,x0l*fill1,bdist,
     &         refflow,tidephi,itide,ecc,thetamis,phimis)

          call findL1(overQm,omega,x0m,1,bdist,tidephi,
     &      ecc,thetamis,phimis) 

          x=fill1*x0m
          y=0.0d0
          z=0.0d0
          call POTEN(overQm,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @     bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          call findradius(overQm,omega,savepsi0,x0m*fill1,bdist,
     &       reffmid,tidephi,itide,ecc,thetamis,phimis)

c          write(*,455)reffhigh,reffmid,refflow
c          write(*,*)gmsun,p

          denhigh=3.0d0*pie*smmks/(reffhigh**3*gmsun*
     %         p*p*(1.0d0+Qhigh))
          denmid=3.0d0*pie*smmks/(reffmid**3*gmsun*
     %         p*p*(1.0d0+Qmid))
c
          fmid=denmid-ddd
          fhigh=denhigh-ddd
c
          if(fhigh*fmid.gt.0.0d0)then
            Qhigh=Qmid
          else
            Qlow=Qmid
          endif
c
          icount=icount+1
          Q=Qmid
c
          if((dabs(fmid).gt.1.0d-12).and.(icount.le.200))go to 999
c
          if(fmid.le.1.0d-12)then
            write(2,1000)density,fill1,Q
          else
            write(2,1001)density,fill1,Q
          endif

1000      format('Info:  density = ',f7.5,' g/cc and fill1 = ',f7.5/,
     %      '       The mass ratio has been set to ',1pe16.9)
1001      format('Warning:  a density of ',f7.5,' g/cc and fill1 = ',f7.5/,
     %      '         is not possible.  The mass ratio has been set to ',
     %        1pe16.9)
          return
          end
c
c   *******
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&c
c
         function gammq(a,x)
        
         implicit double precision(a-h,o-z)
         double precision a,gammq,x
         double precision gammcf,gamser,gln

         if((x.lt.0.0d0).or.(a.le.0.0d0))then
           write(*,*)'bad argument in gammq'
           stop
         endif
c
         if(x.lt.a+1.0d0)then
           call gser(gamser,a,x,gln)
           gammq=1.0d0-gamser
         else
           call gcf(gammcf,a,x,gln)
           gammq=gammcf
         endif
         return
         end
c
c  ********c
c
      SUBROUTINE gcf(gammcf,a,x,gln)
      implicit double precision(a-h,o-z)
      INTEGER ITMAX
      double precision a,gammcf,gln,x,EPS,FPMIN
      PARAMETER (ITMAX=100,EPS=3.d-7,FPMIN=1.d-30)
CU    USES gammln
      INTEGER i
      double precision an,b,c,d,del,h
      gln=gamma_log(a)

      b=x+1.0d0-a
      c=1.0d0/FPMIN
      d=1.0d0/b
      h=d
      do 11 i=1,ITMAX
        an=-i*(i-a)
        b=b+2.0d0
        d=an*d+b
        if(abs(d).lt.FPMIN)d=FPMIN
        c=b+an/c
        if(abs(c).lt.FPMIN)c=FPMIN
        d=1.0d0/d
        del=d*c
        h=h*del
        if(dabs(del-1.0d0).lt.EPS)goto 1
11    continue
      write(*,*)'a too large, ITMAX too small in gcf'
      stop
1     gammcf=dexp(-x+a*dlog(x)-gln)*h
      return
      END
c
c
c
      SUBROUTINE gser(gamser,a,x,gln)
      implicit double precision(a-h,o-z)
      INTEGER ITMAX
      double precision a,gamser,gln,x,EPS
      PARAMETER (ITMAX=100,EPS=3.d-7)
CU    USES gammln
      INTEGER n
      double precision ap,del,sum
      gln=gamma_log(a)

      if(x.le.0.0d0)then
        if(x.lt.0.0d0)write(*,*) 'x < 0 in gser'
        gamser=0.0d0
        return
      endif
      ap=a
      sum=1.0d0/a
      del=sum
      do 11 n=1,ITMAX
        ap=ap+1.0d0
        del=del*x/ap
        sum=sum+del
        if(dabs(del).lt.dabs(sum)*EPS)goto 1
11    continue
      write(*,*) 'a too large, ITMAX too small in gser'
      stop
1     gamser=sum*dexp(-x+a*dlog(x)-gln)
      return
      END
c
c
c   &&&&&&&&&&&&&&&&&&&&&&
c
          subroutine setfill(istar,Q,fill,radfill,omega,bdist,
     &         tidephi,itide,ecc,thetamis,phimis)
c
c
c 
          implicit double precision(a-h,o-z)
c
          if(radfill.ge.1.0d0)return
          if(radfill.le.0.0d0)return

          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q

          fbig=1.0d0
          fsmall=0.0d-8
c
c   First, find the distance to L1.
c
          call findL1(overQ,omega,x0,1,bdist,tidephi,
     &           ecc,thetamis,phimis)       
c          Rl=x0                           !save the L1 distance
          x=x0
          y=0.0d0
          z=0.0d0
c
c   UPDATE November 14, 2009
c
c   initialize cox and coy for the routine that computes the tidal
c   equilibrium option.
c
          cox=1.0d0
          coy=0.0d0
          call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,bdist,
     $      cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          call findradius(overQ,omega,savepsi0,x0,bdist,reff,tidephi,
     &         itide,ecc,thetamis,phimis)
          reffA=reff
c
          call findL1(overQ,omega,x0,1,bdist,tidephi,ecc,
     &          thetamis,phimis)       
          x=x0*fsmall
          y=0.0d0
          z=0.0d0
          call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,bdist,
     $       cox,coy,tidephi,itide,ecc,thetamis,phimis)
          savepsi0=psi     ! value of the potential at x-axis 
          call findradius(overQ,omega,savepsi0,x0,bdist,reff,
     &         tidephi,itide,ecc,thetamis,phimis)
c
          do 10 i=1,20
            fnew=0.5d0*(fbig+fsmall)
            call findL1(overQ,omega,x0,1,bdist,tidephi,
     &           ecc,thetamis,phimis)       
            x=x0*fnew
            y=0.0d0
            z=0.0d0
            call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @          bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            savepsi0=psi     ! value of the potential at x-axis 
            call findradius(overQ,omega,savepsi0,x0,bdist,reff,
     $          tidephi,itide,ecc,thetamis,phimis)
            reffnew=reff
            if((reffA*radfill-reffnew).gt.0.0d0)then
              fsmall=fnew
            else
              fbig=fnew
            endif
10        continue
c
          fill=fnew
          if(istar.eq.1)write(2,665)radfill,fill
          if(istar.eq.2)write(2,666)radfill,fill

665       format('Info:  radfill1 = ',f10.8,', fill1 set to ',f10.8)
666       format('Info:  radfill2 = ',f10.8,', fill2 set to ',f10.8)
          return
          end

c
c  &&&&&&&&&&&&&&&&&&&&
c

        SUBROUTINE LPN(N,X,PN,PD)
C
C       ===============================================
C       Purpose: Compute Legendre polynomials Pn(x)
C                and their derivatives Pn'(x)
C       Input :  x --- Argument of Pn(x)
C                n --- Degree of Pn(x) ( n = 0,1,...)
C       Output:  PN(n) --- Pn(x)
C                PD(n) --- Pn'(x)
C       ===============================================
C
        IMPLICIT DOUBLE PRECISION (P,X)
        DIMENSION PN(0:N),PD(0:N)
        PN(0)=1.0D0
        PN(1)=X
        PD(0)=0.0D0
        PD(1)=1.0D0
        P0=1.0D0
        P1=X
        DO 10 K=2,N
           PF=(2.0D0*K-1.0D0)/K*X*P1-(K-1.0D0)/K*P0
           PN(K)=PF
           IF (DABS(X).EQ.1.0D0) THEN
              PD(K)=0.5D0*X**(K+1)*K*(K+1.0D0)
           ELSE
              PD(K)=K*(P1-X*PF)/(1.0D0-X*X)
           ENDIF
           P0=P1
 10        P1=PF
        RETURN
        END
c
c
c   @@@@@@@@@@@@@@@@@@@@@@@@@@
c
          subroutine analyticscale(Q,finc,period,primmass,primK,ecc,
     @       frac1,frac2,primrad,ratrad,reff1,reff2,separ,vrot1,vrot2,
     @       gpole1,gpole2,rM1,rM2)
c
c   December 9, 2009
c
c   This routine will return the radii and ratio of radii, which will
c   be needed for the fastanalytic routine.
c
          implicit double precision(a-h,o-z)        
c
          parameter(pie=3.14159265358979323d0)
c
          solarmass=1.9889d33
          solarrad=6.9598d10
          Gcgs=6.67259d-8     !G in cgs
          p=period*24.0d0*3600.0d0
          gmsun=1.32712440018d20  !mks units
          fincr=finc*pie/180.0d0
          gsun=2.739910d4

c
c   If frac1 and primrad are zero, then there is not enough information.
c   Write an error message and stop.
c
c   Likewise, if ratrad and frac2 are both zero, write an error message
c   and stop.
c
          if((frac1.le.0.0d0).and.(primrad.le.0.0d0))then
            write(*,*)'There is not enough information to determine ',
     &       'the primary radius.  Set frac1 > 0 or primrad > 0'        
            stop
          endif
c
          if((frac2.le.0.0d0).and.(ratrad.le.0.0d0))then
            write(*,*)'There is not enough information to determine ',
     &       'the secondary radius.  Set frac2 > 0 or ratrad > 0'        
            stop
          endif
c
c   primmass > 0 only, set the separation
c
          if((primmass.gt.0.0d0).and.(primK.le.0.0d0))then
            rmass=primmass*solarmass
            separ=(Gcgs*p*p*(1.0d0+Q)*rmass
     $          /(4.0d0*pie*pie))**(1.d0/3.0d0)/solarrad
            separ=(gmsun*p*p*primmass*(1.0d0+Q)/
     @            (4.0d0*pie*pie))**(1.0d0/3.0d0)
            separ=separ/solarrad*100.0d0
            write(2,1199)primmass,separ
            go to 99
          endif
c
c
c   primK > 0 only, set the separation
c
          if((primmass.le.0.0d0).and.(primK.gt.0.0d0))then
            efact=dsqrt(1.0d0-ecc*ecc)
            vkcgs=primK*100000.0d0*efact
            separ=vkcgs*p*(1.0d0+Q)/(2.0*pie*dsin(fincr)*Q)/solarrad
            write(2,1188)primK,separ
            go to 99
          endif
c
c   primmass > 0 and primK > 0.  Solve for Q and separ
c
          if((primmass.gt.0.0d0).and.(primK.gt.0.0d0))then
            rmass=primmass*solarmass
            efact=dsqrt(1.0d0-ecc*ecc)
            dqhi=7.0d0
            dqlo=-7.0d0
            do 555 kk=1,35
              Qhigh=10.0d0**dqhi
              Qlow=10.0d0**dqlo
              Qmid=10.0**((dqhi+dqlo)*0.5d0)
              aa=vfcn(Qlow,period,finc,primmass,primK,ecc)
c              bb=vfcn(Qhigh,period,finc,primmass,primK,ecc)
              cc=vfcn(Qmid,period,finc,primmass,primK,ecc)
              if(aa*cc.lt.0.0d0)then
                dqhi=(dqhi+dqlo)*0.5d0
              else
                dqlo=(dqhi+dqlo)*0.50
              endif
 555        continue
c
            do 556 kk=1,25
              Qmid=(Qhigh+Qlow)*0.5d0
              aa=vfcn(Qlow,period,finc,primmass,primK,ecc)
c              bb=vfcn(Qhigh,period,finc,primmass,primK,ecc)
              cc=vfcn(Qmid,period,finc,primmass,primK,ecc)
              if(aa*cc.lt.0.0d0)then
                Qhigh=(Qhigh+Qlow)*0.5d0
              else
                Qlow=(Qhigh+Qlow)*0.50
              endif
 556         continue
c
             Q=Qmid
             separ=(gmsun*p*p*primmass*
     &              (1.0d0+Q)/(4.0d0*pie*pie))**(1.0d0/3.0d0)
             separ=separ/solarrad*100.0d0              
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
             total_mass=primmass*(1.0d0+Q)
c
c             ppp=period*24.0d0
             write(2,1177)primmass,primK,Q,separ
             go to 99
           endif
c
1177      format(/'fast analytic mode:',
     &        /'Info:  M_1 fixed at ',f9.6,' solar masses and ',
     &        'K_1 fixed at ',f11.6,' km/sec.',/
     &        'Q is set to ',f12.7,' and the separation is ',f13.7,
     &        ' solar radii')
1199      format(/'fast analytic mode:',
     %            /'Info:  M_1 fixed at ',f9.6,' solar masses.  The',  
     %        ' separation',/ '       has been set to ',f13.7,
     $         ' solar radii')  
1188      format(/'fast analytic mode:',
     @         /'Info:  K_1 fixed at ',f14.8,' km/sec.  The',  
     %        ' separation',/ '       has been set to ',f13.7,
     $         ' solar radii')  
c

99        continue
c
c   We should now have the separation in solar radii.  Figure out if
c   there is enough information to get the radii from the input values
c   of frac1, frac2, primrad, and ratrad.  If frac1 is specified, then
c   find the primary radius from that.  If frac2 is specified, then
c   find the secondary radius from that.
c
          if(frac1.gt.0.0d0)then
            reff1=frac1
            if(frac2.gt.0.0d0)then
              reff2=frac2
              ratrad=reff1/reff2
              go to 199
            endif
c
c   If frac2 is negative and abs(frac2) > frac1, treat frac2 as the
c   fractional sum of radii
c
            if((frac2.lt.0.0d0).and.(dabs(frac2).gt.frac1))then
              reff2=dabs(frac2)-frac1 
              ratrad=reff1/reff2
              go to 199
            endif
            if(ratrad.gt.0.0d0)then
              reff2=reff1/ratrad
              go to 199
            endif
            ratrad=reff1/reff2
            go to 199
          endif
c
          if(primrad.gt.0.0d0)then
            reff1=primrad/separ
            if(frac2.gt.0.0d0)then
              reff2=frac2
              ratrad=reff1/reff2
              go to 199
            endif
            if(ratrad.gt.0.0d0)then
              reff2=reff1/ratrad
              go to 199
            endif
          endif
c
199       continue
c
c         if(ratrad.eq.0.0d0)ratrad=reff1/reff2
c
c   We have to figure out the gravities and the rotational velocities.
c
          fpsq=4.0d0*pie*pie
          sifinc=dsin(fincr)
          smet=separ*6.9598d8
          total_mass=smet*smet*smet*fpsq/(period*86400.0d0)**2/gmsun
          rM1=total_mass/(1.0d0+Q)
          rM2=Q*rM1           
          R1=reff1*separ
          R2=reff2*separ
c
          gpole1=gsun*rM1/(R1*R1)  
          gpole2=gsun*rM2/(R2*R2)  
c
          fact=solarrad*2.0d0*pie/86400.0d0/1.0d5  !50.613093d0
          vrot1=fact*R1/period*sifinc
          vrot2=fact*R2/period*sifinc

          return
          end
c
c   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getanalyticint(maxlines,maxmu,Nlines,atmT,atmg,
     @      atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,
     @      atmint7,atmint8,gpole,darkint,tpole,
     %      dwavex,dwavey,ilaw,iatm,istar,wave,reff,separ)
c
c  December 9, 2009
c
c  This subroutine will evaluate the integral:
c
c  dint = int^1_0 (I(T,g,mu)*mu*du)
c
c  The dint values will go into the reference fluxes for the fast
c  analytic mode.  
c
c  if iatm=0, then use black bodies
c
c
          implicit double precision(a-h,o-z)

          parameter(pie=3.14159265358979323d0)
c
          dimension atmT(maxlines),atmg(maxlines),atmmu(maxlines,maxmu),
     %       Nmu(maxlines),outinty(8),
     @       darkint(8),summ(8)
          dimension atmint1(maxlines,maxmu),atmint2(maxlines,maxmu)
          dimension atmint3(maxlines,maxmu),atmint4(maxlines,maxmu)
          dimension atmint5(maxlines,maxmu),atmint6(maxlines,maxmu)
          dimension atmint7(maxlines,maxmu),atmint8(maxlines,maxmu)
c
          dimension dwavex(8,3),dwavey(8,3),wave(8)
c

          solarrad=6.9598d10
          if(iatm.gt.0)then
c
c   Find the rough place in the atmosphere table.
c
            Tin=tpole
            gin=dlog10(gpole)
            call locate(atmT,Nlines,Tin,indexT)
            itguess=indexT
c
            do 1 i=1,8
              summ(i)=0.0d0
 1          continue
c
            hhh=0.01d0
            do 4 i=100,0,-1
              rmuin=dble(i-1)/500.0d0+0.001d0
              rmuin=dble(i)/100.0d0
              if(rmuin.gt.0.0d0)then
                call computeinty(Tin,gin,rmuin,maxlines,maxmu,Nlines,
     @             atmT,atmg,atmmu,Nmu,atmint1,atmint2,atmint3,atmint4,
     @             atmint5,atmint6,atmint7,atmint8,outinty,icnU,icnB,
     @             icnV,icnR,icnI,icnJ,icnH,icnK,itguess,
     @             dwavex,dwavey,ilaw,iatm,istar)
              else
                outinty(1)=0.0d0
                outinty(2)=0.0d0
                outinty(3)=0.0d0
                outinty(4)=0.0d0
                outinty(5)=0.0d0
                outinty(6)=0.0d0
                outinty(7)=0.0d0
                outinty(8)=0.0d0
              endif
c
              do 88 k=1,8
                if(i.eq.100)then
                  summ(k)=summ(k)+1.0d0*hhh*outinty(k)*rmuin
                else
                  summ(k)=summ(k)+2.0d0*hhh*outinty(k)*rmuin
                endif
                darkint(k)=summ(k)*reff*reff
                darkint(k)=darkint(k)*(separ*solarrad)**2
 88           continue
 4          continue
            return
          endif
c
          if(iatm.le.0)then 
            do 200 jj=1,8
              flimbx=dwavex(jj,istar)
              flimby=dwavey(jj,istar)
c
c
c   December 15, 2013:  add triangular sampling
c
              if((ilaw.eq.5).or.(ilaw.eq.15))then
                savefx=flimbx
                savefy=flimby
                flimbx=2.0d0*dsqrt(savefx)*savefy
                flimby=dsqrt(savefx)*(1.0d0-2.0d0*savefy)
              endif
c
              ddint=pie*(1.0d0-flimbx/3.0d0)
              if(ilaw.eq.2)then
                ddint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
              endif
              if(ilaw.eq.3)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
              endif
              if(ilaw.eq.4)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
              if(ilaw.eq.5)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
              if(ilaw.eq.12)then
                ddint=pie*(1.0d0-flimbx/3.0d0+2.0d0*flimby/9.0d0)
              endif
              if(ilaw.eq.13)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/5.0d0)
              endif
              if(ilaw.eq.14)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
              if(ilaw.eq.15)then
                ddint=pie*(1.0d0-flimbx/3.0d0-flimby/6.0d0)           
              endif
c
              wavemu=wave(jj)/10000.0d0
              c1=3.74185
              c2=14.3883
              tkkelv=tpole/1000.0d0
              C3 = C2/(wavemu*tkkelv)
              darkint(jj)=ddint*C1/(dexp(c3)-1.0d0)/wavemu**5*reff*reff
              darkint(jj)=C1/(dexp(c3)-1.0d0)/wavemu**5*reff*reff
              darkint(jj)=darkint(jj)*(separ*solarrad)**2
200         continue
          endif
c
          return
c
          end
c
c  &&&&&&&&&&&&&
c
          subroutine fastanalytic(Nphase,Nmaxphase,xmod,ymodU,ymodB,
     $       ymodV,ymodR,ymodI,ymodJ,ymodH,ymodK,ymods1,ymods2,ymods3,
     &       ymodd,RV1,RV2,drv1,drv2,NRVphase,xRVmod,fracs1,
     @       fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,
     @       ratrad,period,T0,ecc,argper,
     @       omega1,finc,ilaw,dwavex,dwavey,bigI,bigbeta,sw29,
     @       sw30,ialign,ikeep,pshift,reff1,reff2,darkint1,darkint2,
     @       idark2,dphase,iRVfilt,vrot1,vrot2,Q,separ,gamma,
     @       isw27,icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK,icnRV1,
     @       icnRV2,timearray,sw9,sw23,sw24,isw7,SA3,third,contam,pconj,
     @       beam1,beam2,Ngap,gaplow,gaphigh,tertperiod,tertt0,tertecos,
     @       tertesin,tertincl,tertOmega,tertQ,itconj,tertconj,isw30,
     @       darkint3,omegadot,odetime,zzq,Nstep,timeinterp,mandel,
     @       contamS0,contamS1,contamS2,contamS3,Iseason,Ndyn,
     @       P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
     @       P2ratrad,
     @       P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @       P3ratrad,
     @       P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,P4Omega,P4Q,
     @       P4ratrad,
     @       P5tconj,P5period,P5T0,P5ecos,P5esin,P5incl,P5Omega,P5Q,
     @       P5ratrad,   
     @       P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
     @       P6ratrad,
     @       P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
     @       P7ratrad,
     @       P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @       P8ratrad,RV3,NSC,xSC,ySC)
c
c   UPDATE December 9, 2009
c
c   This is a new routine that will compute light curves using the 
c   analytic expressions of Giminez.  This routine tries to do as little
c   as possible when computing the curves.
c
c   UPDATE March 15, 2011
c
c   Make obsparm dimension 18 (added sum of radii)
c

c          implicit double precision(a-h,o-z)
          implicit none 
c
          integer nmaxphase,Ndyn,mm,nphase,ilaw,ialign,ikeep
          integer idark2,iRVfilt,nRVphase,isw27,icnU,icnB,icnV,icnR
          integer icnI,icnJ,icnH,icnK,icnRV1,icnRV2,isw7,ngap
          integer itconj,isw30,nstep,mandel,iseason,nSC,neclipse1
          integer icounttime,Nloopout,iloopout,nloopin,iloopin,nnn
          integer ijk,ntime,kk,icount,jlo,inback,saveinback,ll

          real*8 tertphase2,tertrnu2,tertppp2,phase,xxoff1,centx3a,centy3a
          real*8 tertphase3,tertrnu3,tertppp3,tertxcen,yyoff1
          real*8 tertphase4,tertrnu4,tertppp4,tertycen,tOmrad
          real*8 tertphase5,tertrnu5,tertppp5,tOmrad2,tOmrad3,tOmrad4
          real*8 tertphase6,tertrnu6,tertppp6,tOmrad5,tOmrad6,tOmrad7
          real*8 tertphase7,tertrnu7,tertppp7,tOmrad8,xxoff,yyoff
          real*8 tertphase8,tertrnu8,tertppp8,xx,yy,zz,xp,xtran,yp,ytran
          real*8 centx4a,centy4a,centx4,centy4,timein,velout1,velout2
          real*8 centx5a,centy5a,centx5,centy5,velout3,velout4,velout5
          real*8 centx6a,centy6a,centx6,centy6,velout6,velout7,velout8
          real*8 centx7a,centy7a,centx7,centy7,velout9,velout10,tshift
          real*8 centx8a,centy8a,centx8,centy8,dummyphase,phaser,delta
          real*8 centx9a,centy9a,centx9,centy9,dummyrat,zprim,veloutx1,zsec
          real*8 centx10a,centy10a,centx10,centy10,tphaser,offset2,offset3
          real*8 tphaser2,tphaser3,tdelta1,zplanet,tdelta2,tdelta3,offset4
          real*8 tdelta4,tdelta5,tdelta6,vel1,vel2,dop1,dop2,offset1

          real*8 tertbdist8,phasein,tertphase,tertrnu,tertppp
          real*8 tertbdist3,tertbdist4,tertbdist5,tertbdist6,tertbdist7
          real*8 ttiny,phaseout,em,bigE,rnu,tertbdist,tertbdist2
          real*8 pstartout,pstopout,argrad,dflux,phper1,phper2,eshift
          real*8 phper8a,phper8b,bdist,pstart,pstop,pconj2,pstep
          real*8 tstart,tstop,tstep,SA1,sneed,reff3,reff4,reff5,reff6
          real*8 reff7,reff8,reff9,reff10,fincr,ppp,total_mass,tertmass
          real*8 gmsun,tt1,smet,tertsep,axisscale,tertecc,tertargrad
          real*8 tertsep2,axisscale2,tt12,smet2,tertmass2,tertarg
          real*8 tertsep3,axisscale3,tt13,smet3,tertmass3
          real*8 tertsep4,axisscale4,tt14,smet4,tertmass4
          real*8 tertsep5,axisscale5,tt15,smet5,tertmass5
          real*8 tertsep6,axisscale6,tt16,smet6,tertmass6
          real*8 tertsep7,axisscale7,tt17,smet7,tertmass7
          real*8 tertsep8,axisscale8,tt18,smet8,tertmass8
          real*8 tertecc2,tertargrad2,tertarg2,pconj3,pconj4
          real*8 tertecc3,tertargrad3,tertarg3,phper3a,phper3b
          real*8 tertecc4,tertargrad4,tertarg4,pconj3_2,pconj4_4
          real*8 tertecc5,tertargrad5,tertarg5,pconj4_2,pconj3_4
          real*8 tertecc6,tertargrad6,tertarg6,pconj3_3,pconj4_3
          real*8 tertecc7,tertargrad7,tertarg7,phper4a,phper4b,pconj3_5
          real*8 tertecc8,tertargrad8,tertarg8,pconj4_5,phper5a,phper5b
          real*8 pconj3_6,pconj4_6,phper6a,phper6b,pconj3_7,pconj4_7
          real*8 phper7a,phper7b,pconj3_8,pconj4_8

          real*8 saveargper,centx1,centx2,centx3,centy1,centy2,centy3
          real*8 tertt02,tertt03,tertt04,tertt05,tertt06,tertt07,tertt08
          real*8 p2ratrad,p3ratrad,p4ratrad,p5ratrad,p6ratrad,p7ratrad
          real*8 xSC,ySC,dwavex,dwavey,xmod,ymodU,ymodB,ymodV,p8ratrad
          real*8 ymodR,ymodI,ymodJ,ymodK,ymodH,ymods1,ymods2,ymodd
          real*8 ymods3,rv1,rv2,drv1,drv2,xrvmod,fracs1,fracs2,fracs3
          real*8 fracs4,fracs5,fracs6,fracs7,fracs8,darkint1,darkint2
          real*8 timearray,third,gaplow,gaphigh,darkint3,odetime,zzq
          real*8 timeinterp,refflux1,refflux2,refflux3,refflux4,refflux5
          real*8 refflux6,refflux7,refflux8,refflux9,refflux10,corr1,corr2
          real*8 corr1a,corr2a,corr3a,gimvel1,gimvel2,corr3a_2,corr2a_2
          real*8 corr1a_2,corr3a_3,corr2a_3,rv3,corr3,corr1a_3,pie,twopie
          real*8 sobrad,sobtheta,rmu,xsob,ratrad,period,t0,ecc,argper,omega1
          real*8 finc,bigI,bigbeta,sw29,sw30,pshift,reff1,reff2,dphase,vrot1
          real*8 vrot2,Q,separ,gamma,sw9,sw23,sw24,SA3,contam,pconj,beam1
          real*8 beam2,tertperiod,tertT0,tertecos,tertesin,tertincl,tertOmega
          real*8 tertQ,tertconj,omegadot,contamS0,contamS1,contamS2,contamS3
          real*8 p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q
          real*8 p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,p3q
          real*8 p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,p4omega,p4q
          real*8 p5tconj,p5period,p5t0,p5ecos,p5esin,p5incl,p5omega,p5q
          real*8 p6tconj,p6period,p6t0,p6ecos,p6esin,p6incl,p6omega,p6q
          real*8 p7tconj,p7period,p7t0,p7ecos,p7esin,p7incl,p7omega,p7q
          real*8 p8tconj,p8period,p8t0,p8ecos,p8esin,p8incl,p8omega,p8q

          dimension xSC(9999),ySC(9999)
          dimension dwavex(8,3),dwavey(8,3)
          dimension xmod(Nmaxphase),ymodU(Nmaxphase),ymodB(Nmaxphase),
     $      ymodV(Nmaxphase),ymodR(Nmaxphase),ymodI(Nmaxphase),
     $      ymodJ(Nmaxphase),ymodH(Nmaxphase),ymodK(Nmaxphase),
     &      ymods1(Nmaxphase),ymods2(Nmaxphase),ymodd(Nmaxphase),
     &      RV1(Nmaxphase),RV2(Nmaxphase),dRV1(Nmaxphase),
     %      dRV2(Nmaxphase),ymods3(Nmaxphase)
          dimension xRVmod(Nmaxphase),RV3(Nmaxphase)
          dimension fracs1(Nmaxphase,4),fracs2(Nmaxphase,4)
          dimension fracs3(Nmaxphase,4),fracs4(Nmaxphase,4)
          dimension fracs5(Nmaxphase,4),fracs6(Nmaxphase,4)
          dimension fracs7(Nmaxphase,4),fracs8(Nmaxphase,4)
          dimension refflux1(8),refflux2(8),third(8),refflux3(8)
          dimension refflux4(8),refflux5(8),refflux6(8)
          dimension refflux7(8),refflux8(8),refflux9(8),refflux10(8)
          dimension corr1(8),corr2(8),corr3(8),corr1a(8),corr2a(8),
     @          corr3a(8),darkint3(8)
          dimension darkint1(8),darkint2(8),gimvel1(8),gimvel2(8)
          dimension corr3a_2(8),corr2a_2(8),corr1a_2(8)
          dimension corr3a_3(8),corr2a_3(8),corr1a_3(8)

          dimension timearray(9000000),gaphigh(9999),gaplow(9999)
          dimension odetime(Ndyn),timeinterp(6),zzq(6,60,Ndyn)

          parameter(pie=3.141592653589793d0,twopie=2.0d0*pie)
          parameter(MM=100)
          dimension sobrad(MM),sobtheta(MM),rmu(MM),xsob(2)
c
          Neclipse1=0
          tertT0=0.0d0
          tertT02=0.0d0
          tertT03=0.0d0
          tertT04=0.0d0
          tertT05=0.0d0
          tertT06=0.0d0
          tertT07=0.0d0
          tertT08=0.0d0

          saveargper=argper
c
          centx1=0.0d0
          centx2=0.0d0
          centx3=0.0d0
          centy1=0.0d0
          centy2=0.0d0
          centy3=0.0d0
          icounttime=0
          Nloopout=0
          iloopout=0
          Nloopin=0
          iloopin=0
          tstep=sw9
          tstart=sw23
          tstop=sw24
          SA1=reff1*reff1*4.0d0*pie
          Sneed=SA1*SA3
          reff3=dsqrt(Sneed/4.0d0/pie)
c
          if(P2ratrad.eq.0.0d0)then
            reff4=0.0d0
          else
            reff4=reff1/P2ratrad
          endif
c
          if(P3ratrad.eq.0.0d0)then
            reff5=0.0d0
          else
            reff5=reff1/P3ratrad
          endif
c
          if(P4ratrad.eq.0.0d0)then
            reff6=0.0d0
          else
            reff6=reff1/P4ratrad
          endif
c
          if(P5ratrad.eq.0.0d0)then
            reff7=0.0d0
          else
            reff7=reff1/P5ratrad
          endif
c
          if(P6ratrad.eq.0.0d0)then
            reff8=0.0d0
          else
            reff8=reff1/P6ratrad
          endif
c
          if(P7ratrad.eq.0.0d0)then
            reff9=0.0d0
          else
            reff9=reff1/P7ratrad
          endif
c
          if(P8ratrad.eq.0.0d0)then
            reff10=0.0d0
          else
            reff10=reff1/P8ratrad
          endif
c
c   initialize the Sobel sequence, if using a third body
c
          if(isw30.gt.0)then
            nnn=-1
            call sobseq(nnn,xsob)
            nnn=2
            call sobseq(nnn,xsob)
            call sobseq(nnn,xsob)
            call sobseq(nnn,xsob)
c
            do ijk=1,MM
              call sobseq(nnn,xsob)
              sobrad(ijk)=xsob(1)
              sobtheta(ijk)=xsob(2)*twopie
              rmu(ijk)=dsqrt(1.0d0-xsob(1)*xsob(1))
            enddo
c
            fincr=finc*pie/180.0d0        ! radians
            ppp=period*24.0d0             ! period in hours
            total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)

            tertmass=total_mass/tertQ
            gmsun=1.32712440018d20   !m^3/sec^2
            tt1=(total_mass+tertmass)*(tertperiod*86400.0d0)**2*gmsun
            smet=(tt1/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep=smet/6.9598d8   !6.959d8
            axisscale=tertsep/separ
            tt1=(total_mass)*(period*86400.0d0)**2*gmsun
            smet=(tt1/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P2Q.le.0.0d0)then
              tertmass2=0.0d0
            else
              tertmass2=total_mass/P2Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt12=(total_mass+tertmass2)*(P2period*86400.0d0)**2*gmsun
            smet2=(tt12/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep2=smet2/6.9598d8   !6.959d8
            axisscale2=tertsep2/separ
            tt12=(total_mass)*(period*86400.0d0)**2*gmsun
            smet2=(tt12/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P3Q.le.0.0d0)then
              tertmass3=0.0d0
            else
              tertmass3=total_mass/P3Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt13=(total_mass+tertmass3)*(P3period*86400.0d0)**2*gmsun
            smet3=(tt13/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep3=smet3/6.9598d8   !6.959d8
            axisscale3=tertsep3/separ
            tt13=(total_mass)*(period*86400.0d0)**2*gmsun
            smet3=(tt13/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P4Q.le.0.0d0)then
              tertmass4=0.0d0
            else
              tertmass4=total_mass/P4Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt14=(total_mass+tertmass4)*(P4period*86400.0d0)**2*gmsun
            smet4=(tt14/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep4=smet4/6.9598d8   !6.959d8
            axisscale4=tertsep4/separ
            tt14=(total_mass)*(period*86400.0d0)**2*gmsun
            smet4=(tt14/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P5Q.le.0.0d0)then
              tertmass5=0.0d0
            else
              tertmass5=total_mass/P5Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt15=(total_mass+tertmass5)*(P5period*86400.0d0)**2*gmsun
            smet5=(tt15/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep5=smet5/6.9598d8   !6.959d8
            axisscale5=tertsep5/separ
            tt15=(total_mass)*(period*86400.0d0)**2*gmsun
            smet5=(tt15/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P5Q.le.0.0d0)then
              tertmass6=0.0d0
            else
              tertmass6=total_mass/P6Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt16=(total_mass+tertmass6)*(P6period*86400.0d0)**2*gmsun
            smet6=(tt16/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep6=smet6/6.9598d8   !6.959d8
            axisscale6=tertsep6/separ
            tt16=(total_mass)*(period*86400.0d0)**2*gmsun
            smet6=(tt16/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P7Q.le.0.0d0)then
              tertmass7=0.0d0
            else
              tertmass7=total_mass/P7Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt17=(total_mass+tertmass7)*(P7period*86400.0d0)**2*gmsun
            smet7=(tt17/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep7=smet7/6.9598d8   !6.959d8
            axisscale7=tertsep7/separ
            tt17=(total_mass)*(period*86400.0d0)**2*gmsun
            smet7=(tt17/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            if(P8Q.le.0.0d0)then
              tertmass8=0.0d0
            else
              tertmass8=total_mass/P8Q
            endif
            gmsun=1.32712440018d20   !m^3/sec^2
            tt18=(total_mass+tertmass8)*(P8period*86400.0d0)**2*gmsun
            smet8=(tt18/(4.0d0*pie*pie))**(1.0d0/3.0d0)
            tertsep8=smet8/6.9598d8   !6.959d8
            axisscale8=tertsep8/separ
            tt18=(total_mass)*(period*86400.0d0)**2*gmsun
            smet8=(tt18/(4.0d0*pie*pie))**(1.0d0/3.0d0)
c
            tertecc=dsqrt(tertecos**2+tertesin**2)
            tertargrad=datan2(tertesin,tertecos) !-0.5d0*pie
            if(tertargrad.lt.0.0d0)tertargrad=tertargrad+2.0d0*pie
            if(tertargrad.gt.pie+pie)tertargrad=tertargrad-2.0d0*pie
            tertarg=(datan2(tertesin,tertecos))*180.0d0/pie
            if(tertarg.lt.0.0d0)tertarg=tertarg+360.0d0
            if(tertarg.gt.360.0d0)tertarg=tertarg-360.0d0
c
c
            tertecc2=dsqrt(P2ecos**2+P2esin**2)
            tertargrad2=datan2(P2esin,P2ecos) 
            if(tertargrad2.lt.0.0d0)tertargrad2=tertargrad2+2.0d0*pie
            if(tertargrad2.gt.pie+pie)tertargrad2=tertargrad2-2.0d0*pie
            tertarg2=(datan2(P2esin,P2ecos))*180.0d0/pie
            if(tertarg2.lt.0.0d0)tertarg2=tertarg2+360.0d0
            if(tertarg2.gt.360.0d0)tertarg2=tertarg2-360.0d0
c
            tertecc3=dsqrt(P3ecos**2+P3esin**2)
            tertargrad3=datan2(P3esin,P3ecos) 
            if(tertargrad3.lt.0.0d0)tertargrad3=tertargrad3+2.0d0*pie
            if(tertargrad3.gt.pie+pie)tertargrad3=tertargrad3-2.0d0*pie
            tertarg3=(datan2(P3esin,P3ecos))*180.0d0/pie
            if(tertarg3.lt.0.0d0)tertarg3=tertarg3+360.0d0
            if(tertarg3.gt.360.0d0)tertarg3=tertarg3-360.0d0
c
            tertecc4=dsqrt(P4ecos**2+P4esin**2)
            tertargrad4=datan2(P4esin,P4ecos) 
            if(tertargrad4.lt.0.0d0)tertargrad4=tertargrad4+2.0d0*pie
            if(tertargrad4.gt.pie+pie)tertargrad4=tertargrad4-2.0d0*pie
            tertarg4=(datan2(P4esin,P4ecos))*180.0d0/pie
            if(tertarg4.lt.0.0d0)tertarg4=tertarg4+360.0d0
            if(tertarg4.gt.360.0d0)tertarg4=tertarg4-360.0d0
c
            tertecc5=dsqrt(P5ecos**2+P5esin**2)
            tertargrad5=datan2(P5esin,P5ecos) 
            if(tertargrad5.lt.0.0d0)tertargrad5=tertargrad5+2.0d0*pie
            if(tertargrad5.gt.pie+pie)tertargrad5=tertargrad5-2.0d0*pie
            tertarg5=(datan2(P5esin,P5ecos))*180.0d0/pie
            if(tertarg5.lt.0.0d0)tertarg5=tertarg5+360.0d0
            if(tertarg5.gt.360.0d0)tertarg5=tertarg5-360.0d0
c
            tertecc6=dsqrt(P6ecos**2+P6esin**2)
            tertargrad6=datan2(P6esin,P6ecos) 
            if(tertargrad6.lt.0.0d0)tertargrad6=tertargrad6+2.0d0*pie
            if(tertargrad6.gt.pie+pie)tertargrad6=tertargrad6-2.0d0*pie
            tertarg6=(datan2(P6esin,P6ecos))*180.0d0/pie
            if(tertarg6.lt.0.0d0)tertarg6=tertarg6+360.0d0
            if(tertarg6.gt.360.0d0)tertarg6=tertarg6-360.0d0
c
            tertecc7=dsqrt(P7ecos**2+P7esin**2)
            tertargrad7=datan2(P7esin,P7ecos) 
            if(tertargrad7.lt.0.0d0)tertargrad7=tertargrad7+2.0d0*pie
            if(tertargrad7.gt.pie+pie)tertargrad7=tertargrad7-2.0d0*pie
            tertarg7=(datan2(P7esin,P7ecos))*180.0d0/pie
            if(tertarg7.lt.0.0d0)tertarg7=tertarg7+360.0d0
            if(tertarg7.gt.360.0d0)tertarg7=tertarg7-360.0d0
c
            tertecc8=dsqrt(P8ecos**2+P8esin**2)
            tertargrad8=datan2(P8esin,P8ecos) 
            if(tertargrad8.lt.0.0d0)tertargrad8=tertargrad8+2.0d0*pie
            if(tertargrad8.gt.pie+pie)tertargrad8=tertargrad8-2.0d0*pie
            tertarg8=(datan2(P8esin,P8ecos))*180.0d0/pie
            if(tertarg8.lt.0.0d0)tertarg8=tertarg8+360.0d0
            if(tertarg8.gt.360.0d0)tertarg8=tertarg8-360.0d0
c
            call findconj(tertargrad,tertecc,pconj3,pconj4,phper3a,
     @        phper3b)
            call findconj(tertargrad2,tertecc2,pconj3_2,pconj4_2,phper3a,
     @        phper3b)
            call findconj(tertargrad3,tertecc3,pconj3_3,pconj4_3,phper3a,
     @        phper3b)
            call findconj(tertargrad4,tertecc4,pconj3_4,pconj4_4,phper4a,
     @        phper4b)
            call findconj(tertargrad5,tertecc5,pconj3_5,pconj4_5,phper5a,
     @        phper5b)
            call findconj(tertargrad6,tertecc6,pconj3_6,pconj4_6,phper6a,
     @        phper6b)
            call findconj(tertargrad7,tertecc7,pconj3_7,pconj4_7,phper7a,
     @        phper7b)
            call findconj(tertargrad8,tertecc8,pconj3_8,pconj4_8,phper8a,
     @        phper8b)

          endif  !end if isw30 > 0
c
          if(isw7.eq.2)call filltime(ntime,timearray,tstart,tstop,tstep)
c
          if(ialign.le.0)then
            bigI=finc
            bigbeta=0.0d0
          endif
          do 9 kk=1,8
            refflux1(kk)=darkint1(kk)
            refflux2(kk)=darkint2(kk)
            refflux3(kk)=darkint3(kk)
            refflux4(kk)=0.0d0
            refflux5(kk)=0.0d0
            refflux6(kk)=0.0d0
            refflux7(kk)=0.0d0
            refflux8(kk)=0.0d0
            refflux9(kk)=0.0d0
            refflux10(kk)=0.0d0
            corr1(kk)=0.0d0
            corr2(kk)=0.0d0
            corr3(kk)=0.0d0
            corr1a(kk)=0.0d0
            corr2a(kk)=0.0d0
            corr3a(kk)=0.0d0
            if(idark2.ge.1)darkint2(kk)=0.0d0
9         continue
c
          if(ecc.le.0.0d0)argper=90.0d0
          bdist=1.0d0
          pstart=0.0d0
          pstop=360.0d0-dphase
          pconj=pie
          pconj2=0.0d0
          pstep=dphase
          pstartout=0.0d0
          pstopout=0.0d0
          if(ecc.gt.0.0d0)then
            pstartout=0.0d0
            pstopout=360.0d0-dphase
          endif
          argrad=argper*pie/180.0d0
          fincr=finc*pie/180.0d0
          dflux=0.0d0
c
          icount=0
c
c  Here is some code adapted from Wilson-Devinney to keep track of
c  phases needed for eccentric orbits.
c
          call findconj(argrad,ecc,pconj,pconj2,phper1,phper2)
c
          eshift=0.0d0
          if(ikeep.eq.1)eshift=phper1+pconj-0.5d0
          if(ikeep.eq.2)eshift=phper2+pconj2
          if(ecc.eq.0.0d0)then
            eshift=0.0d0
            pconj=0.0d0
          endif
c
          ttiny=0.0d0
          if(ecc.le.0.0d0)ttiny=1.0d-6
c
          if((isw7.eq.2).and.(ecc.gt.0.0d0))then
            pstartout=360.0d0*(timearray(1)-T0)/period
            pstopout=360.0d0*(timearray(ntime)-T0)/period
            dphase=360.0d0*tstep/period
          endif

          Nloopout=idint((pstopout+ttiny-pstartout)/dphase)
          phaseout=pstartout-dphase
c
c          do 999 phaseout=pstartout,pstopout+ttiny,dphase
c
          do 999 iloopout=1,Nloopout+1
            phaseout=phaseout+dphase
c
            argper=saveargper+(timearray(icounttime+1)-T0)*
     @           omegadot/365.25d0
            argrad=pie*argper/180.0d0
            if((icount.ge.1).and.(Ngap.ge.1))then
              do ijk=1,Ngap
                if((timearray(icounttime).gt.gaplow(ijk)).and.
     @               (timearray(icounttime).lt.gaphigh(ijk)))then
                  icounttime=icounttime+1
                  goto 999
                endif
              enddo
              do ijk=1,Ngap
                if((timearray(icounttime).gt.gaplow(ijk)).and.
     @               (timearray(icounttime).lt.gaphigh(ijk)))then
                  icounttime=icounttime+1
                  goto 999
                endif
              enddo
 8888      endif
c
            if(ecc.gt.0.0d0)then
              em=phaseout*pie/180.0d0
              call getE(em,ecc,bigE)
11107         if(bigE.lt.0.0)then
                bigE=bigE+2.0d0*pie
                go to 11107
              endif
22207         if(bigE.gt.2.0d0*pie)then
                bigE=bigE-2.0d0*pie
                go to 22207
              endif
              rnu=2.0d0*datan(dsqrt((1.0d0+ecc)/(1.0d0-ecc))*
     @             dtan(bigE/2.0d0))
11105         if(rnu.lt.0.0)then
                rnu=rnu+2.0d0*pie
                go to 11105
              endif
11106         if(rnu.gt.2.0d0*pie)then
                rnu=rnu-2.0d0*pie
                go to 11106
              endif
              bdist=(1.0d0-ecc*dcos(bigE))
              pstart=dmod(rnu*180.0d0/pie+argper+90.0d0,360.0d0)
              pstop=dmod(rnu*180.0d0/pie+argper+90.0d0,360.0d0)
            endif
            pstep=dphase
c
c            phaser=pstart*pie/180.0d0
c            delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
c            delta=bdist*dsqrt(delta)
c
            if((isw7.eq.2).and.(ecc.eq.0.0d0))then
              pstart=360.0d0*(timearray(1)-T0)/period
              pstop=360.0d0*(timearray(ntime)-T0)/period
              pstep=360.0d0*tstep/period
            endif
c 
c   Add the third body phases here if needed
c
            if((isw30.ge.1).and.(isw7.ge.2))then
              if(iloopout.eq.1)then
                if(itconj.eq.2)then
                  tertT0=0.0d0
                  tertT02=0.0d0
                  tertT03=0.0d0
                  tertT04=0.0d0
                  tertT05=0.0d0
                  tertT06=0.0d0
                  tertT07=0.0d0
                  tertT08=0.0d0
                  call getT0(tertincl,tertperiod,tertecc,tertarg,
     $               tertT0,tertconj)
                  call getT0(P2incl,P2period,tertecc2,tertarg2,
     $               tertT02,P2tconj)
                  call getT0(P3incl,P3period,tertecc3,tertarg3,
     $               tertT03,P3tconj)
                  call getT0(P4incl,P4period,tertecc4,tertarg4,
     $               tertT04,P4tconj)
                  call getT0(P5incl,P5period,tertecc5,tertarg5,
     $               tertT05,P5tconj)
                  call getT0(P6incl,P6period,tertecc6,tertarg6,
     $               tertT06,P6tconj)
                  call getT0(P7incl,P7period,tertecc7,tertarg7,
     $               tertT07,P7tconj)
                  call getT0(P8incl,P8period,tertecc8,tertarg8,
     $               tertT08,P8tconj)
                endif
                if(itconj.eq.1)then
                  call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     $                tertT0,tertconj)
                  call getT0tran(P2incl,P2period,tertecc2,tertarg2,
     $                tertT02,P2tconj)
                  call getT0tran(P3incl,P3period,tertecc3,tertarg3,
     $                tertT03,P3tconj)
                  call getT0tran(P4incl,P4period,tertecc4,tertarg4,
     $                tertT04,P4tconj)
                  call getT0tran(P5incl,P5period,tertecc5,tertarg5,
     $                tertT05,P5tconj)
                  call getT0tran(P6incl,P6period,tertecc6,tertarg6,
     $                tertT06,P6tconj)
                  call getT0tran(P7incl,P7period,tertecc7,tertarg7,
     $                tertT07,P7tconj)
                  call getT0tran(P8incl,P8period,tertecc8,tertarg8,
     $                tertT08,P8tconj)
c
                endif
              endif
              tertbdist=0.0d0
              tertbdist2=0.0d0
              tertbdist3=0.0d0
              tertbdist4=0.0d0
              tertbdist5=0.0d0
              tertbdist6=0.0d0
              tertbdist7=0.0d0
              tertbdist8=0.0d0
              if(tertperiod.le.0.0d0)then
                tertphase=0.0d0
              else
                tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
              endif
              tertphase=360.0d0*tertphase
              call tertnu(tertphase,tertecc,tertbdist,tertrnu)
              tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @            360.0d0)
              if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
              if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
              tertppp=dmod(tertphase,360.0d0)
              if(tertppp.lt.0.0d0)tertppp=tertppp+360.0d0
              if(tertppp.gt.360.0d0)tertppp=tertppp-360.0d0
c
              if(P2period.le.0.0d0)then
                tertphase2=0.0d0
              else
                tertphase2=(timearray(icounttime+1)-tertt02)/P2period
              endif
              tertphase2=360.0d0*tertphase2
              call tertnu(tertphase2,tertecc2,tertbdist2,tertrnu2)
              tertphase2=dmod(tertrnu2*180.0d0/pie+tertarg2+90.0d0,
     @            360.0d0)
              if(tertphase2.lt.0.0d0)tertphase2=tertphase2+360.0d0
              if(tertphase2.gt.360.0d0)tertphase2=tertphase2-360.0d0
              tertppp2=dmod(tertphase2,360.0d0)
              if(tertppp2.lt.0.0d0)tertppp2=tertppp2+360.0d0
              if(tertppp2.gt.360.0d0)tertppp2=tertppp2-360.0d0
c
              if(P3period.le.0.0d0)then
                tertphase3=0.0d0
              else
                tertphase3=(timearray(icounttime+1)-tertt03)/P3period
              endif
              tertphase3=360.0d0*tertphase3
              call tertnu(tertphase3,tertecc3,tertbdist3,tertrnu3)
              tertphase3=dmod(tertrnu3*180.0d0/pie+tertarg3+90.0d0,
     @            360.0d0)
              if(tertphase3.lt.0.0d0)tertphase3=tertphase3+360.0d0
              if(tertphase3.gt.360.0d0)tertphase3=tertphase3-360.0d0
              tertppp3=dmod(tertphase3,360.0d0)
              if(tertppp3.lt.0.0d0)tertppp3=tertppp3+360.0d0
              if(tertppp3.gt.360.0d0)tertppp3=tertppp3-360.0d0
c
              if(P4period.le.0.0d0)then
                tertphase4=0.0d0
              else
                tertphase4=(timearray(icounttime+1)-tertt04)/P4period
              endif
              tertphase4=360.0d0*tertphase4
              call tertnu(tertphase4,tertecc4,tertbdist4,tertrnu4)
              tertphase4=dmod(tertrnu4*180.0d0/pie+tertarg4+90.0d0,
     @            360.0d0)
              if(tertphase4.lt.0.0d0)tertphase4=tertphase4+360.0d0
              if(tertphase4.gt.360.0d0)tertphase4=tertphase4-360.0d0
              tertppp4=dmod(tertphase4,360.0d0)
              if(tertppp4.lt.0.0d0)tertppp4=tertppp4+360.0d0
              if(tertppp4.gt.360.0d0)tertppp4=tertppp4-360.0d0
c
              if(P5period.le.0.0d0)then
                tertphase5=0.0d0
              else
                tertphase5=(timearray(icounttime+1)-tertt05)/P5period
              endif
              tertphase5=360.0d0*tertphase5
              call tertnu(tertphase5,tertecc5,tertbdist5,tertrnu5)
              tertphase5=dmod(tertrnu5*180.0d0/pie+tertarg5+90.0d0,
     @            360.0d0)
              if(tertphase5.lt.0.0d0)tertphase5=tertphase5+360.0d0
              if(tertphase5.gt.360.0d0)tertphase5=tertphase5-360.0d0
              tertppp5=dmod(tertphase5,360.0d0)
              if(tertppp5.lt.0.0d0)tertppp5=tertppp5+360.0d0
              if(tertppp5.gt.360.0d0)tertppp5=tertppp5-360.0d0
c
              if(P6period.le.0.0d0)then
                tertphase6=0.0d0
              else
                tertphase6=(timearray(icounttime+1)-tertt06)/P6period
              endif
              tertphase6=360.0d0*tertphase6
              call tertnu(tertphase6,tertecc6,tertbdist6,tertrnu6)
              tertphase6=dmod(tertrnu6*180.0d0/pie+tertarg6+90.0d0,
     @            360.0d0)
              if(tertphase6.lt.0.0d0)tertphase6=tertphase6+360.0d0
              if(tertphase6.gt.360.0d0)tertphase6=tertphase6-360.0d0
              tertppp6=dmod(tertphase6,360.0d0)
              if(tertppp6.lt.0.0d0)tertppp6=tertppp6+360.0d0
              if(tertppp6.gt.360.0d0)tertppp6=tertppp6-360.0d0
c 
              if(P7period.le.0.0d0)then
                tertphase7=0.0d0
              else
                tertphase7=(timearray(icounttime+1)-tertt07)/P7period
              endif
              tertphase7=360.0d0*tertphase7
              call tertnu(tertphase7,tertecc7,tertbdist7,tertrnu7)
              tertphase7=dmod(tertrnu7*180.0d0/pie+tertarg7+90.0d0,
     @            360.0d0)
              if(tertphase7.lt.0.0d0)tertphase7=tertphase7+360.0d0
              if(tertphase7.gt.360.0d0)tertphase7=tertphase7-360.0d0
              tertppp7=dmod(tertphase7,360.0d0)
              if(tertppp7.lt.0.0d0)tertppp7=tertppp7+360.0d0
              if(tertppp7.gt.360.0d0)tertppp7=tertppp7-360.0d0
c
              if(P8period.le.0.0d0)then
                tertphase8=0.0d0
              else
                tertphase8=(timearray(icounttime+1)-tertt08)/P8period
              endif
              tertphase8=360.0d0*tertphase8
              call tertnu(tertphase8,tertecc8,tertbdist8,tertrnu8)
              tertphase8=dmod(tertrnu8*180.0d0/pie+tertarg8+90.0d0,
     @            360.0d0)
              if(tertphase8.lt.0.0d0)tertphase8=tertphase8+360.0d0
              if(tertphase8.gt.360.0d0)tertphase8=tertphase8-360.0d0
              tertppp8=dmod(tertphase8,360.0d0)
              if(tertppp8.lt.0.0d0)tertppp8=tertppp8+360.0d0
              if(tertppp8.gt.360.0d0)tertppp8=tertppp8-360.0d0
 
          endif
c
            phasein=0.0d0
            Nloopin=0
            Nloopin=idint((pstop+ttiny-pstart)/pstep)
            phasein=pstart-pstep
c
c            do 10 phasein=pstart,pstop+ttiny,pstep
c
            jlo=100
            do 10 iloopin=1,Nloopin+1
              phasein=phasein+pstep
c
              if((icount.ge.1).and.(Ngap.ge.1))then
                do ijk=1,Ngap
                  if((timearray(icounttime).gt.gaplow(ijk)).and.
     @                 (timearray(icounttime).lt.gaphigh(ijk)))then
                    icounttime=icounttime+1
                    goto 10
                  endif
                enddo
              endif
c
              icount=icount+1
              icounttime=icounttime+1
              phase=dmod(phasein,360.0d0)
c
c   add the third body phases if needed
c
              if((isw30.ge.1).and.(isw7.ge.2))then
                if(iloopout.eq.1)then
                  if(itconj.eq.2)then
                    call getT0(tertincl,tertperiod,tertecc,tertarg,
     @                 tertT0,tertconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @                 tertT0,tertconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P2incl,P2period,tertecc2,tertarg2,
     @                 tertT02,P2tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P2incl,P2period,tertecc2,tertarg2,
     @                 tertT02,P2tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P3incl,P3period,tertecc3,tertarg3,
     @                 tertT03,P3tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P3incl,P3period,tertecc3,tertarg3,
     @                 tertT03,P3tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P4incl,P4period,tertecc4,tertarg4,
     @                 tertT04,P4tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P4incl,P4period,tertecc4,tertarg4,
     @                 tertT04,P4tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P5incl,P5period,tertecc5,tertarg5,
     @                 tertT05,P5tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P5incl,P5period,tertecc5,tertarg5,
     @                 tertT05,P5tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P6incl,P6period,tertecc6,tertarg6,
     @                 tertT06,P6tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P6incl,P6period,tertecc6,tertarg6,
     @                 tertT06,P6tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P7incl,P7period,tertecc7,tertarg7,
     @                 tertT07,P7tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P7incl,P7period,tertecc7,tertarg7,
     @                 tertT07,P7tconj)
                  endif
c
                  if(itconj.eq.2)then
                    call getT0(P8incl,P8period,tertecc8,tertarg8,
     @                 tertT08,P8tconj)
                  endif
                  if(itconj.eq.1)then
                    call getT0tran(P8incl,P8period,tertecc8,tertarg8,
     @                 tertT08,P8tconj)
                  endif
c
                endif

                tertphase=(timearray(icounttime)-tertt0)/tertperiod
                tertphase=360.0d0*tertphase  
                call tertnu(tertphase,tertecc,tertbdist,tertrnu)
                tertphase=dmod(tertrnu*180.0d0/pie+tertarg+90.0d0,
     @              360.0d0)
                if(tertphase.lt.0.0d0)tertphase=tertphase+360.0d0
                if(tertphase.gt.360.0d0)tertphase=tertphase-360.0d0
c
                if(P2period.le.0.0d0)then
                  tertphase2=0.0d0
                else
                  tertphase2=(timearray(icounttime)-tertt02)/P2period
                endif
                tertphase2=360.0d0*tertphase2  
                call tertnu(tertphase2,tertecc2,tertbdist2,tertrnu2)
                tertphase2=dmod(tertrnu2*180.0d0/pie+tertarg2+90.0d0,
     @              360.0d0)
                if(tertphase2.lt.0.0d0)tertphase2=tertphase2+360.0d0
                if(tertphase2.gt.360.0d0)tertphase2=tertphase2-360.0d0
c
                if(P3period.le.0.0d0)then
                  tertphase3=0.0d0
                else
                  tertphase3=(timearray(icounttime)-tertt03)/P3period
                endif
                tertphase3=360.0d0*tertphase3  
                call tertnu(tertphase3,tertecc3,tertbdist3,tertrnu3)
                tertphase3=dmod(tertrnu3*180.0d0/pie+tertarg3+90.0d0,
     @              360.0d0)
                if(tertphase3.lt.0.0d0)tertphase3=tertphase3+360.0d0
                if(tertphase3.gt.360.0d0)tertphase3=tertphase3-360.0d0
c
                if(P4period.le.0.0d0)then
                  tertphase4=0.0d0
                else
                  tertphase4=(timearray(icounttime)-tertt04)/P4period
                endif
                tertphase4=360.0d0*tertphase4  
                call tertnu(tertphase4,tertecc4,tertbdist4,tertrnu4)
                tertphase4=dmod(tertrnu4*180.0d0/pie+tertarg4+90.0d0,
     @              360.0d0)
                if(tertphase4.lt.0.0d0)tertphase4=tertphase4+360.0d0
                if(tertphase4.gt.360.0d0)tertphase4=tertphase4-360.0d0
c
                if(P5period.le.0.0d0)then
                  tertphase5=0.0d0
                else
                  tertphase5=(timearray(icounttime)-tertt05)/P5period
                endif
                tertphase5=360.0d0*tertphase5  
                call tertnu(tertphase5,tertecc5,tertbdist5,tertrnu5)
                tertphase5=dmod(tertrnu5*180.0d0/pie+tertarg5+90.0d0,
     @              360.0d0)
                if(tertphase5.lt.0.0d0)tertphase5=tertphase5+360.0d0
                if(tertphase5.gt.360.0d0)tertphase5=tertphase5-360.0d0
c
                if(P6period.le.0.0d0)then
                  tertphase6=0.0d0
                else
                  tertphase6=(timearray(icounttime)-tertt06)/P6period
                endif
                tertphase6=360.0d0*tertphase6  
                call tertnu(tertphase6,tertecc6,tertbdist6,tertrnu6)
                tertphase6=dmod(tertrnu6*180.0d0/pie+tertarg6+90.0d0,
     @              360.0d0)
                if(tertphase6.lt.0.0d0)tertphase6=tertphase6+360.0d0
                if(tertphase6.gt.360.0d0)tertphase6=tertphase6-360.0d0
c
                if(P7period.le.0.0d0)then
                  tertphase7=0.0d0
                else
                  tertphase7=(timearray(icounttime)-tertt07)/P7period
                endif
                tertphase7=360.0d0*tertphase7 
                call tertnu(tertphase7,tertecc7,tertbdist7,tertrnu7)
                tertphase7=dmod(tertrnu7*180.0d0/pie+tertarg7+90.0d0,
     @              360.0d0)
                if(tertphase7.lt.0.0d0)tertphase7=tertphase7+360.0d0
                if(tertphase7.gt.360.0d0)tertphase7=tertphase7-360.0d0
c
                if(P8Period.le.0.0d0)then
                  tertphase8=0.0d0
                else
                  tertphase8=(timearray(icounttime)-tertt08)/P8period
                endif
                tertphase8=360.0d0*tertphase8 
                call tertnu(tertphase8,tertecc8,tertbdist8,tertrnu8)
                tertphase8=dmod(tertrnu8*180.0d0/pie+tertarg8+90.0d0,
     @              360.0d0)
                if(tertphase8.lt.0.0d0)tertphase8=tertphase8+360.0d0
                if(tertphase8.gt.360.0d0)tertphase8=tertphase8-360.0d0
c
                xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
c
                tOmrad=tertOmega*pie/180.00d0
                tOmrad2=P2Omega*pie/180.00d0
                tOmrad3=P3Omega*pie/180.00d0
                tOmrad4=P4Omega*pie/180.00d0
                tOmrad5=P5Omega*pie/180.00d0
                tOmrad6=P6Omega*pie/180.00d0
                tOmrad7=P7Omega*pie/180.00d0
                tOmrad8=P8Omega*pie/180.00d0
c
                xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
                yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase,fincr,Q,1,bdist)+xxoff
                yp=ytran(xx,yy,zz,phase,fincr,Q,1,bdist)+yyoff
                centx1=xp
                centy1=yp
c
                xx=0.0d0
                yy=0.0d0
                zz=0.0d0
                xp=xtran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+xxoff
                yp=ytran(xx,yy,zz,phase+180.0d0,fincr,Q,2,bdist)+yyoff
c
                centx2=xp
                centy2=yp
c
                centx3a=tertxcen(1,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
                centy3a=tertycen(1,tertincl,tertbdist,tertphase,tertQ,
     @            axisscale)
c 
                centx3=centx3a*dcos(tOmrad)-centy3a*dsin(tOmrad)
                centy3=centx3a*dsin(tOmrad)+centy3a*dcos(tOmrad)
c 
                centx4a=tertxcen(1,P2incl,tertbdist2,tertphase2,P2Q,
     @            axisscale2)
                centy4a=tertycen(1,P2incl,tertbdist2,tertphase2,P2Q,
     @            axisscale2) 
                centx4=centx4a*dcos(tOmrad2)-centy4a*dsin(tOmrad2)
                centy4=centx4a*dsin(tOmrad2)+centy4a*dcos(tOmrad2)
c
                centx5a=tertxcen(1,P3incl,tertbdist3,tertphase3,P3Q,
     @            axisscale3)
                centy5a=tertycen(1,P3incl,tertbdist3,tertphase3,P3Q,
     @            axisscale3) 
                centx5=centx5a*dcos(tOmrad3)-centy5a*dsin(tOmrad3)
                centy5=centx5a*dsin(tOmrad3)+centy5a*dcos(tOmrad3)
c 
                centx6a=tertxcen(1,P4incl,tertbdist4,tertphase4,P4Q,
     @            axisscale4)
                centy6a=tertycen(1,P4incl,tertbdist4,tertphase4,P4Q,
     @            axisscale4) 
                centx6=centx6a*dcos(tOmrad4)-centy6a*dsin(tOmrad4)
                centy6=centx6a*dsin(tOmrad4)+centy6a*dcos(tOmrad4)
c 
                centx7a=tertxcen(1,P5incl,tertbdist5,tertphase5,P5Q,
     @            axisscale5)
                centy7a=tertycen(1,P5incl,tertbdist5,tertphase5,P5Q,
     @            axisscale5) 
                centx7=centx7a*dcos(tOmrad5)-centy7a*dsin(tOmrad5)
                centy7=centx7a*dsin(tOmrad5)+centy7a*dcos(tOmrad5)
c 
                centx8a=tertxcen(1,P6incl,tertbdist6,tertphase6,P6Q,
     @            axisscale6)
                centy8a=tertycen(1,P6incl,tertbdist6,tertphase6,P6Q,
     @            axisscale6) 
                centx8=centx8a*dcos(tOmrad6)-centy8a*dsin(tOmrad6)
                centy8=centx8a*dsin(tOmrad6)+centy8a*dcos(tOmrad6)
c 
                centx9a=tertxcen(1,P7incl,tertbdist7,tertphase7,P7Q,
     @            axisscale7)
                centy9a=tertycen(1,P7incl,tertbdist7,tertphase7,P7Q,
     @            axisscale7) 
                centx9=centx9a*dcos(tOmrad7)-centy9a*dsin(tOmrad7)
                centy9=centx9a*dsin(tOmrad7)+centy9a*dcos(tOmrad7)
c 
                centx10a=tertxcen(1,P8incl,tertbdist8,tertphase8,P8Q,
     @            axisscale8)
                centy10a=tertycen(1,P8incl,tertbdist8,tertphase8,P8Q,
     @            axisscale8) 
                centx10=centx10a*dcos(tOmrad8)-centy10a*dsin(tOmrad8)
                centy10=centx10a*dsin(tOmrad8)+centy10a*dcos(tOmrad8)
c 
                if(isw30.ge.2)then
                  timein=timearray(icounttime)
                  call LTTsky(odetime,zzq,Nstep,timeinterp,1,timein,
     @              centx1,centy1,velout1,jlo,Ndyn)
                  centx1=centx1/separ
                  centy1=centy1/separ
                  call LTTsky(odetime,zzq,Nstep,timeinterp,2,timein,
     @              centx2,centy2,velout2,jlo,Ndyn)
                  centx2=centx2/separ
                  centy2=centy2/separ
                  call LTTsky(odetime,zzq,Nstep,timeinterp,3,timein,
     @              centx3,centy3,velout3,jlo,Ndyn)
                  centx3=centx3/separ
                  centy3=centy3/separ
                  if(isw30.ge.4)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,4,timein,
     @               centx4,centy4,velout4,jlo,Ndyn)
                    centx4=centx4/separ
                    centy4=centy4/separ
                  endif
                  if(isw30.ge.5)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,5,timein,
     @               centx5,centy5,velout5,jlo,Ndyn)
                    centx5=centx5/separ
                    centy5=centy5/separ
                  endif
                  if(isw30.ge.6)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,6,timein,
     @               centx6,centy6,velout6,jlo,Ndyn)
                    centx6=centx6/separ
                    centy6=centy6/separ
                  endif
                  if(isw30.ge.7)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,7,timein,
     @               centx7,centy7,velout7,jlo,Ndyn)
                    centx7=centx7/separ
                    centy7=centy7/separ
                  endif
                  if(isw30.ge.8)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,8,timein,
     @               centx8,centy8,velout8,jlo,Ndyn)
                    centx8=centx8/separ
                    centy8=centy8/separ
                  endif
                  if(isw30.ge.9)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,9,timein,
     @               centx9,centy9,velout9,jlo,Ndyn)
                    centx9=centx9/separ
                    centy9=centy9/separ
                  endif
                  if(isw30.ge.10)then
                    call LTTsky(odetime,zzq,Nstep,timeinterp,10,timein,
     @               centx10,centy10,velout10,jlo,Ndyn)
                    centx10=centx10/separ
                    centy10=centy10/separ
                  endif
                endif

              endif

              if(phase.lt.0.0d0)phase=phase+360.0d0
c              extphase=phase
              if((ecc.gt.0.0d0).or.(pshift.ne.0.0d0))then
                tshift=pshift+eshift
              endif
              dummyphase=dmod(phase+180.0d0,360.0d0)  ! this is for star 2
c
              phaser=phase*pie/180.0d0
              delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
              delta=bdist*dsqrt(delta)
c
              do kk=1,8
                corr1(kk)=0.0d0
                corr2(kk)=0.0d0
                corr3(kk)=0.0d0
                corr1a(kk)=0.0d0
                corr2a(kk)=0.0d0
                corr3a(kk)=0.0d0
                corr1a_2(kk)=0.0d0
                corr2a_2(kk)=0.0d0
                corr3a_2(kk)=0.0d0
                corr1a_3(kk)=0.0d0
                corr2a_3(kk)=0.0d0
                corr3a_3(kk)=0.0d0
              enddo

              if(isw30.eq.0)then   ! no body 3, so do normally
                call analyticg(isw27,ilaw,dwavex,dwavey,delta,reff1,
     @            ratrad,refflux1,refflux2,phaser,pconj,pconj2,gimvel1,
     @            fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @            Neclipse1,1,corr1,corr2,mandel,0,0)
                phaser=phase*pie/180.0d0
                delta=(cos(fincr)**2+(sin(fincr)*sin(phaser))**2)
                delta=bdist*dsqrt(delta)

                dummyrat= 1.0d0/ratrad
                call analyticg(isw27,ilaw,dwavex,dwavey,delta,reff2,
     @            dummyrat,refflux1,refflux2,phaser,pconj,pconj2,
     @            gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @            bigbeta,Neclipse1,2,corr1,corr2,mandel,0,0)
c
              endif
c
              if(isw30.ge.1)then   ! body 3
                phaser=phase*pie/180.0d0
                delta=dsqrt((centx1-centx2)**2+(centy1-centy2)**2)
                inback=0
                if(isw30.ge.3)then
                  call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @               zprim,veloutx1,jlo,Ndyn)
                  call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @               zsec,veloutx1,jlo,Ndyn)
                  if(zprim.gt.zsec)inback=99
                endif
                call analyticg(isw27,ilaw,dwavex,dwavey,delta,reff1,
     @            ratrad,refflux1,refflux2,phaser,pconj,pconj2,gimvel1,
     @            fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @            Neclipse1,1,corr1,corr2,mandel,inback,isw30)

                dummyrat= 1.0d0/ratrad
                saveinback=inback
                if(saveinback.ne.0)inback=0
                if(saveinback.eq.0)inback=99
                if(isw30.ge.3)then
                  call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @               zprim,veloutx1,jlo,Ndyn)
                  call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @               zsec,veloutx1,jlo,Ndyn)
c                  if(zprim.lt.zsec)inback=99  
                endif
                call analyticg(isw27,ilaw,dwavex,dwavey,delta,reff2,
     @            dummyrat,refflux1,refflux2,phaser,pconj,pconj2,
     @            gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @            bigbeta,Neclipse1,2,corr1,corr2,mandel,inback,
     @            isw30)
cc
                tphaser=tertphase*pie/180.0d0
                tphaser2=tertphase2*pie/180.0d0
                tphaser3=tertphase3*pie/180.0d0
c
c   planet 1 on primary
c
                tdelta1=dsqrt((centx1-centx3)**2+(centy1-centy3)**2)
                if(tdelta1.le.reff3+reff1)then
                  dummyrat=reff3/reff1
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,9,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zprim.lt.zplanet)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta1,reff3,
     @              dummyrat,refflux3,refflux1,tphaser,pconj3,pconj4,
     @              gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a,corr1a,mandel,inback,isw30)
c
                  dummyrat=reff1/reff3
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99
  
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,9,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zprim)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta1,reff1,
     @              dummyrat,refflux3,refflux1,tphaser,pconj3,pconj4,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,3,corr3a,corr1a,mandel,inback,
     @              isw30)
                endif
c 
c  planet 1 on secondary
c
                tdelta2=dsqrt((centx2-centx3)**2+(centy2-centy3)**2)
                if(tdelta2.le.reff3+reff2)then
                  dummyrat=reff3/reff2
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                 zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,9,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zsec.lt.zplanet)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta2,reff3,
     @              dummyrat,refflux3,refflux2,tphaser,pconj3,pconj4,
     @              gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a,corr2a,mandel,inback,isw30)
c
                  dummyrat=reff2/reff3
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                 zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,9,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zsec)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta2,reff2,
     @              dummyrat,refflux3,refflux2,tphaser,pconj3,pconj4,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,3,corr3a,corr2a,mandel,inback,
     @              isw30)  
                 endif
c
c   planet 2 on primary
c
                if(isw30.ge.4)then
                  tdelta3=dsqrt((centx1-centx4)**2+(centy1-centy4)**2)
                  dummyrat=reff4/reff1
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,12,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zprim.lt.zplanet)inback=99
                  endif 
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta3,reff4,
     @              dummyrat,refflux4,refflux1,tphaser2,pconj3_2,
     @              pconj4_2,gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a_2,corr1a_2,mandel,inback,isw30)
c
                  if(reff4.le.0.0d0)then
                    dummyrat=1.d20
                  else
                    dummyrat=reff1/reff4
                  endif
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99

                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,12,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zprim)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta3,reff1,
     @              dummyrat,refflux4,refflux1,tphaser2,
     @              pconj3_2,pconj4_2,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,2,corr3a_2,corr1a_2,mandel,inback,
     @              isw30)
c 
c  planet 2 on secondary
c
                  tdelta4=dsqrt((centx2-centx4)**2+(centy2-centy4)**2)
                  dummyrat=reff4/reff2
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                 zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,12,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zsec.lt.zplanet)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta4,reff4,
     @              dummyrat,refflux4,refflux2,tphaser2,
     @              pconj3_2,pconj4_2,gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a_2,corr2a_2,mandel,inback,isw30)
c
                  if(reff4.le.0.0d0)then
                    dummyrat=1.0d20
                  else
                    dummyrat=reff2/reff4
                  endif
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99
c
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,12,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zsec)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta4,reff2,
     @              dummyrat,refflux4,refflux2,tphaser2,
     @              pconj3_2,pconj4_2,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,2,corr3a_2,corr2a_2,mandel,inback,
     @              isw30)  
                endif
c
c   planet 3 on primary
c
                if(isw30.ge.4)then                
                  tdelta5=dsqrt((centx1-centx5)**2+(centy1-centy5)**2)
                  dummyrat=reff5/reff1
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,15,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zprim.lt.zplanet)inback=99
                  endif 
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta5,reff5,
     @              dummyrat,refflux5,refflux1,tphaser3,pconj3_3,
     @              pconj4_3,gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a_3,corr1a_3,mandel,inback,isw30)
c
                  if(reff5.le.0.0d0)then
                    dummyrat=1.0d20
                  else
                    dummyrat=reff1/reff5
                  endif
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99
c
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,3,timein,
     @                 zprim,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,15,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zprim)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta5,reff1,
     @              dummyrat,refflux5,refflux1,tphaser3,
     @              pconj3_3,pconj4_3,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,2,corr3a_3,corr1a_3,mandel,inback,
     @              isw30)
c   
c  planet 3 on secondary
c
                  tdelta6=dsqrt((centx2-centx5)**2+(centy2-centy5)**2)
                  dummyrat=reff5/reff2
                  inback=0
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                 zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,15,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
                    if(zsec.lt.zplanet)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta6,reff5,
     @              dummyrat,refflux5,refflux2,tphaser3,
     @              pconj3_3,pconj4_3,gimvel1,
     @              fincr,vrot1,omega1,period,separ,Q,ecc,bigI,bigbeta,
     @              Neclipse1,1,corr3a_3,corr2a_3,mandel,inback,isw30)
c
                  dummyrat=reff2/reff5
                  saveinback=inback
                  if(saveinback.ne.0)inback=0
                  if(saveinback.eq.0)inback=99
c
                  if(isw30.ge.3)then
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,6,timein,
     @                 zsec,veloutx1,jlo,Ndyn)
                    call divdiffzonly(odetime,zzq,Nstep,timeinterp,15,timein,
     @                 zplanet,veloutx1,jlo,Ndyn)
c                    if(zplanet.lt.zsec)inback=99
                  endif
                  call analyticg(isw27,ilaw,dwavex,dwavey,tdelta6,reff2,
     @              dummyrat,refflux5,refflux2,tphaser3,
     @              pconj3_3,pconj4_3,
     @              gimvel2,fincr,vrot2,omega1,period,separ,Q,ecc,bigI,
     @              bigbeta,Neclipse1,2,corr3a_3,corr2a_3,mandel,inback,
     @              isw30)  
                endif
c
              endif  !Nbody >3
c
c
c
              call getrefvel(1,phase,finc,Q,separ,period,gamma,
     @           vel1,ecc,argrad,isw27,gimvel1,iRVfilt)
              if(delta.lt.dabs(reff1-reff2))then
                   gimvel2(iRVfilt)=0.0d0
              endif
              call getrefvel(2,dummyphase,finc,Q,separ,period,
     @           gamma,vel2,ecc,argrad+pie,isw27,gimvel2,iRVfilt)
c
              do ll=1,8
                dop1=0.0d0
                dop2=0.0d0
                if(isw30.eq.0)then
                  offset1=darkint1(ll)+corr1(ll)+corr1a(ll)
                  offset2=darkint2(ll)+corr2(ll)+corr2a(ll)
                  offset3=third(ll)
                  if(offset2.lt.0.0d0)offset2=0.0d0
                  if(ll.eq.iRVfilt)then
                    dop1=(vel1-gamma)/2.99792458d5
                    dop2=(vel2-gamma)/2.99792458d5
                    offset1=offset1*(1.0d0-beam1*dop1)
                    offset2=offset2*(1.0d0-beam2*dop2)
                  endif
                  RV1(icount)=vel1
                  RV2(icount)=vel2
                  if(ll.eq.1)ymodU(icount)=pie*(third(1)+offset1
     @                +offset2)
                  if(ll.eq.2)ymodB(icount)=pie*(third(2)+offset1
     @                +offset2)
                  if(ll.eq.3)ymodV(icount)=pie*(third(3)+offset1
     @                +offset2)
                  if(ll.eq.4)ymodR(icount)=pie*(third(4)+offset1
     @                +offset2)
                  if(ll.eq.5)ymodI(icount)=pie*(third(5)+offset1
     @                +offset2)
                  if(ll.eq.6)ymodJ(icount)=pie*(third(6)+offset1
     @                +offset2)
                  if(ll.eq.7)ymodH(icount)=pie*(third(7)+offset1
     @                +offset2)
                  if(ll.eq.8)ymodK(icount)=pie*(third(8)+offset1
     @                +offset2)
c

                  if(ll.eq.iRVfilt)then
                    ymods1(icount)=pie*(offset1)   !refflux1(ll)
                    ymods2(icount)=pie*(offset2)   !refflux2(ll)
                    ymods3(icount)=pie*(third(ll))
                  endif
c
                  if(ll.eq.1)then
                    fracs1(icount,1)=pie*(offset1)
                    fracs1(icount,2)=pie*(offset2)
                    fracs1(icount,3)=0.0d0
                    fracs1(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.2)then
                    fracs2(icount,1)=pie*(offset1)
                    fracs2(icount,2)=pie*(offset2)
                    fracs2(icount,3)=0.0d0
                    fracs2(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.3)then
                    fracs3(icount,1)=pie*(offset1)
                    fracs3(icount,2)=pie*(offset2)
                    fracs3(icount,3)=0.0d0
                    fracs3(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.4)then
                    fracs4(icount,1)=pie*(offset1)
                    fracs4(icount,2)=pie*(offset2)
                    fracs4(icount,3)=0.0d0
                    fracs4(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.5)then
                    fracs5(icount,1)=pie*(offset1)
                    fracs5(icount,2)=pie*(offset2)
                    fracs5(icount,3)=0.0d0
                    fracs5(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.6)then
                    fracs6(icount,1)=pie*(offset1)
                    fracs6(icount,2)=pie*(offset2)
                    fracs6(icount,3)=0.0d0
                    fracs6(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.7)then
                    fracs7(icount,1)=pie*(offset1)
                    fracs7(icount,2)=pie*(offset2)
                    fracs7(icount,3)=0.0d0
                    fracs7(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.8)then
                    fracs8(icount,1)=pie*(offset1)
                    fracs8(icount,2)=pie*(offset2)
                    fracs8(icount,3)=0.0d0
                    fracs8(icount,4)=pie*(offset3)
                  endif
c     
                endif  !if isw30 = 0
c
c
                if(isw30.gt.0)then
                  offset1=darkint1(ll)+corr1(ll)+corr1a(ll)
                  offset2=darkint2(ll)+corr2(ll)+corr2a(ll)
                  if(offset2.lt.0.0d0)offset2=0.0d0
                  offset3=darkint3(ll)+corr3(ll)+corr3a(ll)
                  if(offset3.lt.0.0d0)offset3=0.0d0
                  offset4=corr3a_2(ll)+corr2a_2(ll)+corr1a_2(ll)
                  offset4=offset4+corr3a_3(ll)+corr2a_3(ll)+corr1a_3(ll)
c                  if(offset4.lt.0.0d0)offset4=0.0d0
                  if(ll.eq.iRVfilt)then
                    dop1=(vel1-gamma)/2.99792458d5
                    dop2=(vel2-gamma)/2.99792458d5
                    offset1=offset1*(1.0d0-beam1*dop1)
                    offset2=offset2*(1.0d0-beam2*dop2)
                  endif
                  if(ll.eq.1)ymodU(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.2)ymodB(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.3)ymodV(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.4)ymodR(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.5)ymodI(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.6)ymodJ(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.7)ymodH(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
                  if(ll.eq.8)ymodK(icount)=pie*(offset3+offset1
     @                +offset2+offset4)
c
                  if(isw30.lt.3)then
                    RV1(icount)=vel1
                    RV2(icount)=vel2
                    RV3(icount)=0.0d0
                  else
                    RV1(icount)=-velout1+gamma
                    RV2(icount)=-velout2+gamma
                    RV3(icount)=-velout3+gamma
                  endif
                  if(ll.eq.iRVfilt)then
                    ymods1(icount)=pie*(offset1)   !refflux1(ll)
                    ymods2(icount)=pie*(offset2)   !refflux2(ll)
                    ymods3(icount)=pie*(offset3)
                  endif
c
                  if(ll.eq.1)then
                    fracs1(icount,1)=pie*(offset1)
                    fracs1(icount,2)=pie*(offset2)
                    fracs1(icount,3)=0.0d0
                    fracs1(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.2)then
                    fracs2(icount,1)=pie*(offset1)
                    fracs2(icount,2)=pie*(offset2)
                    fracs2(icount,3)=0.0d0
                    fracs2(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.3)then
                    fracs3(icount,1)=pie*(offset1)
                    fracs3(icount,2)=pie*(offset2)
                    fracs3(icount,3)=0.0d0
                    fracs3(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.4)then
                    fracs4(icount,1)=pie*(offset1)
                    fracs4(icount,2)=pie*(offset2)
                    fracs4(icount,3)=0.0d0
                    fracs4(icount,4)=pie*(offset3)
                  endif
                  if(ll.eq.5)then
                    fracs5(icount,1)=pie*(offset1)
                    fracs5(icount,2)=pie*(offset2)
                    fracs5(icount,3)=0.0d0
                    fracs5(icount,4)=pie*(offset3)              
                  endif
                  if(ll.eq.6)then
                    fracs6(icount,1)=pie*(offset1)
                    fracs6(icount,2)=pie*(offset2)
                    fracs6(icount,3)=0.0d0
                    fracs6(icount,4)=pie*(offset3)                   
                  endif
                  if(ll.eq.7)then
                    fracs7(icount,1)=pie*(offset1)
                    fracs7(icount,2)=pie*(offset2)
                    fracs7(icount,3)=0.0d0
                    fracs7(icount,4)=pie*(offset3)                    
                  endif
                  if(ll.eq.8)then
                    fracs8(icount,1)=pie*(offset1)
                    fracs8(icount,2)=pie*(offset2)
                    fracs8(icount,3)=0.0d0
                    fracs8(icount,4)=pie*(offset3)                   
                  endif
c     
                endif  !if isw30 = 0
c              
              enddo
c
              if(isw7.le.1)xmod(icount)=phase/360.0d0   
              if(ecc.gt.0.0d0)xmod(icount)=em/(2.0d0*pie)
              if(isw7.ge.2)xmod(icount)=timearray(icounttime)
              xRVmod(icount)=xmod(icount)          
c
  10        continue
c
 999      continue    ! continue the big loop if eccentric
c
          Nphase=icount
          NRVphase=icount
c
          if(isw7.le.1)then
            if((ecc.gt.0.0d0).or.(pshift.ne.0.0d0))then
              tshift=pshift+eshift
c
c   UPDATE September 10, 2001
c
c   Add the if-then clauses.
c  
              if((ecc.gt.0.0d0).and.(ikeep.eq.1))tshift=pshift+eshift
     @               -pconj
              if((ecc.gt.0.0d0).and.(ikeep.eq.2))tshift=pshift+eshift
     @               -pconj2
              if(icnU.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodU,
     &               tshift,0)
              if(icnB.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodB,
     &               tshift,0)
              if(icnV.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodV,
     &               tshift,0)
              if(icnR.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodR,
     &               tshift,0)
              if(icnI.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodI,
     &               tshift,0)
              if(icnJ.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodJ,
     &               tshift,0)
              if(icnH.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodH,
     &               tshift,0)
              if(icnK.ne.430)call shiftlc(Nmaxphase,Nphase,xmod,ymodK,
     &               tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods1,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods2,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymods3,tshift,0)
              call shiftlc(Nmaxphase,Nphase,xmod,ymodd,tshift,1)
              if(icnRV1.ne.430)call shiftlc(Nmaxphase,Nphase,xRVmod,
     &             RV1,tshift,0)
              if(icnRV2.ne.430)call shiftlc(Nmaxphase,Nphase,xRVmod,
     $             dRV1,tshift,0)
              if(icnRV1.ne.430)call shiftlc(Nmaxphase,Nphase,xRVmod,
     &             RV2,tshift,0)
              if(icnRV2.ne.430)call shiftlc(Nmaxphase,Nphase,xRVmod,
     &            dRV2,tshift,1)
            endif
          endif
c
c   If requested, bin the light and velocity curves.  sw29 will be
c   the binsize for the photometry, in minutes, and sw30 will be the bin
c   size for the RV curves, in minutes
c
          if(sw29.gt.0.0d0)then
            if(isw7.le.1)then
              if(icnU.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodU,
     @            period,sw29)
            else
              if(icnU.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodU,
     @           period,sw29,NSC,xSC,ySC)
            endif
          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnB.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodB,period,
c     @        sw29)
c            else
c              if(icnB.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodB,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnV.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodV,period,
c     @        sw29)
c            else
c              if(icnV.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodV,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnR.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodR,period,
c     @        sw29)
c            else
c              if(icnR.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodR,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnI.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodI,period,
c     @        sw29)
c            else
c              if(icnI.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodI,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnJ.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodJ,period,
c     @        sw29)
c            else
c              if(icnJ.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodJ,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnH.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodH,period,
c     @        sw29)
c            else
c              if(icnH.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodH,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c            if(isw7.le.1)then
c              if(icnK.ne.430)call binlc(Nmaxphase,Nphase,xmod,ymodK,period,
c     @        sw29)
c            else
c              if(icnK.ne.430)call binlctime(Nmaxphase,Nphase,xmod,ymodK,period,
c     @        sw29)
c            endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods1,period,
c     @         sw29)
c             else
c               call binlc(Nmaxphase,Nphase,xmod,ymods1,period,
c     @         sw29)
c             endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods2,period,
c     @         sw29)
c             else
c               call binlctime(Nmaxphase,Nphase,xmod,ymods2,period,
c     @         sw29)
c             endif
c          endif
c          if(sw29.gt.0.0d0)then
c             if(isw7.le.1)then
c               call binlc(Nmaxphase,Nphase,xmod,ymods3,period,
c     @         sw29)
c             else
c               call binlctime(Nmaxphase,Nphase,xmod,ymods3,period,
c     @         sw29)
c             endif
c          endif
          if(sw30.gt.0.0d0)then
            if(icnRV1.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,RV1,
     @         period,sw30)
          endif
          if(sw30.gt.0.0d0)then
            if(icnRV2.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,RV2,
     @         period,sw30)
          endif
          if(sw30.gt.0.0d0)then
            if(icnRV1.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,dRV1,
     @        period,sw30)
          endif
          if(sw30.gt.0.0d0)then
            if(icnRV2.ne.430)call binlc(Nmaxphase,NRVphase,xRVmod,dRV2,
     @         period,sw30)
          endif
c
          if(Iseason.ge.1)then
            if(Nphase.gt.1)call Scontaminate(Nmaxphase,Nphase,
     @          xmod,ymodU,contamS0,contamS1,contamS2,contamS3)
          else
            if((contam.gt.0.0d0).and.(contam.lt.1.0d0))then
             if(Nphase.gt.1)call contaminate(Nmaxphase,Nphase,xmod,
     @          ymodU,contam)
            endif
          endif
c
          argper=saveargper
          return
          end
c
c   &&%&%&%&%&%&%&%&%@@@@$@@@$@$@@@@
c
          subroutine addpad(Nphase,xmod,ymod,xpad,ypad)
c
c   This routine will return a padded pair of arrays with phases going
c   from -1 to 2.
c
           implicit double precision(a-h,o-z)

           dimension xmod(Nphase),ymod(Nphase),xpad(Nphase*3),
     @        ypad(Nphase*3)
c
           icount=0
           do 10 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)-1.0d0
             ypad(icount)=ymod(i)
10         continue

           do 20 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)
             ypad(icount)=ymod(i)
20         continue

           do 30 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)+1.0d0
             ypad(icount)=ymod(i)
30         continue
c
           return
           end     
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c
          subroutine removepad(Nphase,ymod,ypad)
c
c   This routine will remove the pad.
c
           implicit double precision(a-h,o-z)

           dimension ymod(Nphase),ypad(Nphase*3)
c
           icount=0
           do 10 i=Nphase+1,2*Nphase
             icount=icount+1
             ymod(icount)=ypad(i)
10         continue
c
           return
           end     
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
c   December 23, 2012
c
c   comment out
c
c           subroutine binphi(Nphi,xmod,ymod,rowsum,Nbet)
c
cc   This subroutine will bin a light curve in phase, using a binsize given
cc   by sw29, where the units are minutes.
cc
c           implicit double precision (a-h,o-z)
cc
c           dimension xmod(Nphi),ymod(Nphi)
c           dimension xpad(900000),ypad(900000)
c           parameter(pie=3.1415926535897932384d0,twopie=pie+pie)
cc
c           if(Nphi.gt.1)call sort2(Nphi,xmod,ymod)
c           call addphipad(Nphi,xmod,ymod,xpad,ypad)
c           Mphase=Nphi*3
cc
cc   We will interpolate the model, and given each value in xmod, figure
cc   out the range of phase needed, and average the interpolated y-values
cc
c           m=3
cc
c           iover=8
c           NN=4*Nbet
c           NN=NN*iover
c           dphi=twopie/dble(NN)
c           summ=0.0d0
cc
c           do 99 i=1,NN
c             phi=-0.5d0*dphi+dphi*dble(i)
c             xxx=phi
c             call hunt(xpad,Mphase,xxx,index)
c             k=min(max(index-(m-1)/2,1),Mphase+1-m)
cc
cc               call polint(xpad(k),ypad(k),m,xxx,qqqa,dy)
c             call intep(xxx,qqqa,xpad(k),ypad(k),m,ier)
c
cc
cc             qqqa=((xpad(k+1)-xxx)*ypad(k)+(xxx-xpad(k))*ypad(k+1))
cc     @           /(xpad(k+1)-xpad(k))
cc
c             summ=summ+qqqa
c99         continue
cc
c           rowsum=summ/dble(iover)
cc
c           return
c           end
cc
c   &&%&%&%&%&%&%&%&%@@@@$@@@$@$@@@@
c
          subroutine addphipad(Nphase,xmod,ymod,xpad,ypad)
c
c   This routine will return a padded pair of arrays with phases going
c   from -1 to 2.
c
           implicit double precision(a-h,o-z)
           parameter(pie=3.14159265358979323d0)

c           dimension xmod(Nphase),ymod(Nphase),xpad(Nphase*3),ypad(Nphase*3)
           dimension xmod(2000),ymod(2000),xpad(9999),ypad(9999)
c
           icount=0
           do 10 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)-2.0d0*pie
             ypad(icount)=ymod(i)
10         continue

           do 20 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)
             ypad(icount)=ymod(i)
20         continue

           do 30 i=1,Nphase
             icount=icount+1
             xpad(icount)=xmod(i)+2.0d0*pie
             ypad(icount)=ymod(i)
30         continue
c
           return
           end
c
c   &&&&&&&&&&&&&&&&&&&&&&&@@$%$$@$@@&@&@&@@@@@@@&&&&&&&&
c
           subroutine edgecor(Nrow,xrow,yrow,phor1,phor2,corr)
c
           implicit double precision (a-h,o-z)
c
           dimension xrow(2000),yrow(2000),xpad(9999),ypad(9999)
c
           parameter(pie=3.1415926535897932384d0)
c
           corr=0.0d0
           corr1=0.0d0
           corr2=0.0d0
c
c    First, sort the array and pad it (make the angle go from
c    -2pi to 4pi to avoid edge effects
c
           if(Nrow.gt.1)call sort2(Nrow,xrow,yrow)
           call addphipad(Nrow,xrow,yrow,xpad,ypad)
           Npad=Nrow*3
c
c   Find the phi value of the visible pixel nearest to the
c   first limb (phor1)
c
           dphi=pie/dble(Nrow)
           halfdphi=0.5d0*dphi
           diffsmall=123456789.0d0
           index=1
c
c           write(*,*)'phihor = ',phor1
           if(phor1.gt.0.0d0)then
             do 10 i=1,Npad
               if(ypad(i).le.0.0d0)go to 10
               diff=dabs(phor1-xpad(i))
               if(diff.lt.diffsmall)then
                 index=i
                 diffsmall=diff
               endif
10           continue
c
c   Make sure the difference is less than dphi
c
             if(diffsmall.gt.dphi)go to 99
c
c   if the difference is greater than 0.5dphi, then add a small 
c   correction
c
             if(diffsmall.lt.halfdphi)then
               corr1=ypad(index)*(diffsmall-dphi)/dphi
c             else
               t1=diffsmall-halfdphi
               t2=(t1/halfdphi)**2
               corr1=t2*0.5d0*diffsmall*ypad(index)
             endif  
           endif
c
99         continue
c
c   Check the other limb
c
           index=1
           diffsmall=123456789.0d0
           if(phor2.gt.0.0d0)then
             do 20 i=1,Npad
               if(ypad(i).le.0.0d0)go to 20
               diff=dabs(phor2-xpad(i))
               if(diff.lt.diffsmall)then
                 index=i
                 diffsmall=diff
               endif
20           continue
c
c   Make sure the difference is less than dphi
c
             if(diffsmall.gt.dphi)go to 999
c
c   if the difference is greater than 0.5dphi, then add a small 
c   correction
c
             if(diffsmall.lt.halfdphi)then
               corr2=ypad(index)*(diffsmall-dphi)/dphi
c             else
               t1=diffsmall-halfdphi
               t2=(t1/halfdphi)**2
               corr2=t2*0.5d0*diffsmall*ypad(index)
             endif  
           endif
c
999        corr=corr1+corr2
c
c           write(*,*)corr1,corr2
c           if(corr1.gt.0.0d0)write(*,*)'corr1'
c           if(corr2.gt.0.0d0)write(*,*)'corr2'
c
           corr=0.0d0

           return
           end
c
c
cc   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
cc
c           subroutine intep(xp,p,x,f,n,ier)
cc
c           implicit double precision(a-h,o-z)
c           double precision lp1,lp2,l1,l2
c           dimension f(N),x(N)
c           ier=1
c           i0=1
c           iup=0
c           lp1=1.0d0
c           lp2=1.0d0
c           fp1=1.0d0
c           fp2=1.0d0
c           if(x(2).lt.x(1))iup=1
c           N1=N-1
c
c           if((xp.ge.x(N).and.iup.eq.0).or.(xp.le.x(N).and.iup.eq.1))then
c5            p=f(N)
c             go to 6
c           else if((xp.le.x(1).and.iup.eq.0).or.(xp.ge.x(1).and.iup.eq.1))then
c             p=f(1)
c6            ier=2
c             return
c           endif
cc
cc           entry eintep(xp,p,x,f,n,ier)
cc
c           do 1 i=i0,N
c             if(xp.lt.x(i).and.iup.eq.0)go to 2
c             if(xp.gt.x(i).and.iup.eq.1)go to 2
c1          continue
c           go to 5
c2          i=i-1
c           if(i.eq.i0-1)go to 4
c           i0=i+1
c           lp1=1.0d0/(x(i)-x(i+1))
c           lp2=1.0d0/(x(i+1)-x(i))
c           if(i.eq.1)fp1=(f(2)-f(1))/(x(2)-x(1))
c           if(i.eq.1)go to 3
c           fp1=(f(i+1)-f(i-1))/(x(i+1)-x(i-1))
c3          if(i.ge.n1)fp2=(f(n)-f(n-1))/(x(n)-x(n-1))         
c           if(i.ge.n1)go to 4
c           fp2=(f(i+2)-f(i))/(x(i+2)-x(i))
c4          xpi1=xp-x(i+1)
c           xpi=xp-x(i)
c           l1=xpi1*lp1
c           l2=xpi*lp2
c           p=f(i)*(1.0d0-2.0d0*lp1*xpi)*l1*l1+f(i+1)*(1.0d0-2.0d0*lp2*xpi1)
c    $         *l2*l2+fp2*xpi1*l2*l2+fp1*xpi*l1*l1
c           if(p.lt.0.0d0)p=0.0d0
c           return
c           end
c
c  &&&&&&&&&&&&&&&&&&&
c
c@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
c
c
          subroutine getcontimes(finc,period,ecc,argper,T0,tconj1,
     @          tconj2)
c
c   November 5, 2008
c
c   This routine will compute the conjunction times 
c   given the input parameters.
c   It basically finds the value of the true anamoly that minimizes 
c   the projected
c   separation of centers.
c
          implicit double precision (a-h,o-z)
c
          pie=3.141592653589793d0
c
          fincr=finc*pie/180.0d0
          omegar=argper*pie/180.0d0
          ft=1.5d0*pie-omegar
3139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 3139
3140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 3140

          guess=ft
          do 22 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 23
            ft=guess
22        continue

 23       ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 31101
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 31101
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 31103
31101     ecan=pie
31103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
          tconj1=t0+deltaT
c
          ft=0.5d0*pie-omegar
4139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 4139
4140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 4140

          guess=ft
          do 422 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 423
            ft=guess
422       continue

 423      ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 41101
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41101
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 41103
41101     ecan=pie
41103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
          tconj2=t0+deltaT
c
          return
          end
c
c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
c
          function ddelta(fincr,omegar,ecc,theta)
c
          implicit double precision (a-h,o-z)
c
          t1=1.0d0-ecc*ecc
          t2=1.0d0+ecc*dcos(theta)
          t3=1.0d0-(dsin(fincr)*dsin(theta+omegar))**2
          ddelta=t1/t2*dsqrt(t3)
c
          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          function deltap(fincr,omegar,ecc,theta)
c
          implicit double precision (a-h,o-z)
c
          ttiny=1.0d-4
c
          t1=ddelta(fincr,omegar,ecc,theta+ttiny)
          t2=ddelta(fincr,omegar,ecc,theta-ttiny)
          deltap=(t1-t2)/(2.0d0*ttiny)

          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          function deltapp(fincr,omegar,ecc,theta)
c
          implicit double precision (a-h,o-z)
c
          ttiny=1.0d-4
c
          t1=deltap(fincr,omegar,ecc,theta+ttiny)
          t2=deltap(fincr,omegar,ecc,theta-ttiny)
          deltapp=(t1-t2)/(2.0d0*ttiny)
          return
          end
c
c@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
c
c
          subroutine getT0(finc,period,ecc,argper,T0,Tconj)
c
c   January 30, 2010.
c
c   This routine is the inverse of getcontimes.  Given a time of transit,
c   it will figure out the T0 needed.
c
          implicit double precision (a-h,o-z)
c
          pie=3.141592653589793d0
c
          fincr=finc*pie/180.0d0
          omegar=(argper+180.0d0)*pie/180.0d0
          ft=1.5d0*pie-omegar
3139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 3139
3140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 3140

          guess=ft
          do 22 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 23
            ft=guess
22        continue

 23       ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 31501
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 31501
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 31103
31501     ecan=pie
31103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
          t0=tconj-deltaT
c
          ft=0.5d0*pie-omegar
4139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 4139
4140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 4140
c
          guess=ft
          do 422 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(ft-guess)
            if(diff.lt.1.0d-9)go to 423
            ft=guess
422       continue
c
 423      ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 41101
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41101
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 41103
41101     ecan=pie
41103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
          t9=tconj-deltaT
c
          return
          end
c
c
c    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
           subroutine binlctime(Nmaxphase,Nphase,xmod,ymod,period,sw29,
     $        NSC,xSC,ySC)
c
c   This subroutine will bin a light curve in time, using a binsize given
c   by sw29, where the units are minutes.
c
           implicit double precision (a-h,o-z)
c
           parameter(isize=3500000)
           dimension xmod(Nmaxphase),ymod(Nmaxphase)
           dimension yinter(isize),y2(isize)
           dimension xpad(isize),ypad(isize)
           dimension xSC(9999),ySC(9999)
c
           if(isize.lt.Nmaxphase)then
             write(*,*)'Dimension error in subroutine binlctime.'
             write(*,*)'Change isize to be > Nmaxphase.'
             stop
           endif
c
           do kk=1,Nphase
              xpad(kk)=xmod(kk)
              ypad(kk)=ymod(kk)
           enddo
           Mphase=Nphase
c
c   We will interpolate the model, and given each value in xmod, figure
c   out the range of phase needed, and average the interpolated y-values
c
           call spline(xpad,ypad,Mphase,0.0d0,0.0d0,y2)
c
           pstep=sw29/1440.0d0/period
           pstep=sw29/60.0d0/24.0d0
           pwidth=0.5d0*pstep
c
           NN=7
c           xxxhigh=1.0d0            !xmod(Nphase)

           do 10 i=1,Mphase
c             if(xpad(i).gt.1.0d0)go to 10
c             if(xpad(i).lt.0.0d0)go to 10
             kcount=0
             summ=0.0d0        
             jlo=i
c 
c   check if xmod(i) is in a SC range.  If so, set yiter(i)=ymod(i) 
c   and go to 10
c
             do kk=1,NSC
               if((xpad(i).ge.xSC(kk)).and.(xpad(i).le.ySC(kk)))then
                 yinter(i)=ypad(i)
                 go to 10
               endif
             enddo
             a=xpad(i)-pwidth
             b=xpad(i)+pwidth

             do 9 j=1,NN
               if(j.eq.1)then
                 xxx=a
c                 if(xxx.lt.0.0d0)xxx=1.0d0+xxx   !dabs(xxx)
c                 if(xxx.gt.xxxhigh)xxx=xxx-1.0d0
                 call hunt(xpad,Mphase,xxx,jlo)
                 if((jlo.eq.Mphase).or.(jlo.eq.0))then
                   call splint(xpad,ypad,y2,Mphase,xxx,qqqa)
                 else
                   call fastsplint(xpad,ypad,y2,Mphase,xxx,qqqa,
     @                 jlo,jlo+1)
                 endif
                 xxx=b
c                 if(xxx.lt.0.0d0)xxx=1.0d0+xxx   !dabs(xxx)
c                 if(xxx.gt.xxxhigh)xxx=xxx-1.0d0
                 call hunt(xpad,Mphase,xxx,jlo)
                 if((jlo.eq.Mphase).or.(jlo.eq.0))then
                   call splint(xpad,ypad,y2,Mphase,xxx,qqqb)
                 else
                   call fastsplint(xpad,ypad,y2,Mphase,xxx,qqqb,
     @                 jlo,jlo+1)
                 endif
                 summ=0.5d0*(b-a)*(qqqa+qqqb)
               else
                 it=2**(j-2)
                 tnm=dble(it)
                 del=(b-a)/tnm
                 x=a+0.5d0*del
                 xxx=x
c                 if(xxx.lt.0.0d0)xxx=1.0d0+xxx   !dabs(xxx)
c                 if(xxx.gt.xxxhigh)xxx=xxx-1.0d0
                 s=0.0d0
                 do 11 kk=1,it
                   kcount=kcount+1 
                   call hunt(xpad,Mphase,xxx,jlo)
                   if((jlo.eq.Mphase).or.(jlo.eq.0))then
                     call splint(xpad,ypad,y2,Mphase,xxx,qqq)
                   else
                     call fastsplint(xpad,ypad,y2,Mphase,xxx,qqq,
     @                 jlo,jlo+1)
                   endif
                   s=s+qqq
                   x=x+del
                   xxx=x
c                   if(xxx.lt.0.0d0)xxx=1.0d0+xxx   !dabs(xxx)
c                   if(xxx.gt.xxxhigh)xxx=xxx-1.0d0
11               continue
                 summ=0.5d0*(summ+(b-a)*s/tnm)
               endif
c
9           continue

           yinter(i)=summ/pstep

10         continue
c
           do 20 i=1,Mphase
             ymod(i)=yinter(i)
20         continue
c
c           call removepad(Nphase,ymod,ypad)

           return
           end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
           subroutine contaminate(Nmaxphase,Nphase,xmod,ymodU,contam)
c
           implicit double precision(a-h,o-z)
c           parameter(isize=1500000)
           parameter(isize=3500000)
           dimension xmod(Nmaxphase),ymodU(Nmaxphase),yscr(isize)
           dimension xscr(isize)
c
           if(isize.lt.Nmaxphase)then
             write(*,*)'Dimension error in subroutine contaminate.'
             write(*,*)'Make isize > Nmaxphase'
             stop
           endif
c
c
c           write(*,*)Nphase,' contaminate'
           do 50 i=1,Nphase
             xscr(i)=xmod(i)
             yscr(i)=ymodU(i)
50         continue

           if(Nphase.gt.1)call sort2(Nphase,yscr,xscr)

           rmed=yscr(Nphase/2)
c
           yoff=contam*rmed/(1.0d0-contam)
c
           do 10 i=1,Nphase
             ymodU(i)=ymodU(i)+yoff
             ymodU(i)=ymodU(i)*rmed/(rmed+yoff)
10         continue
c
           return
           end
c
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
           subroutine Scontaminate(Nmaxphase,Nphase,xmod,ymodU,
     @       contamS0,contamS1,contamS2,contamS3)
c
           implicit double precision(a-h,o-z)
           parameter(isize=3500000)
           dimension xmod(Nmaxphase),ymodU(Nmaxphase),yscr(isize)
           dimension xscr(isize)
c
           if(isize.lt.Nmaxphase)then
             write(*,*)'Dimension error in subroutine Scontaminate.'
             write(*,*)'Make isize > Nmaxphase'
             stop
           endif
c
           do 50 i=1,Nphase
             xscr(i)=xmod(i)
             yscr(i)=ymodU(i)
50         continue

           if(Nphase.gt.1)call sort2(Nphase,yscr,xscr)

           rmed=yscr(Nphase/2)
c
           do 10 i=1,Nphase
             if(xmod(i).lt.0.0d0)then
c               ymodU(i)=ymodU(i)+yoff1
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff1)
               ymodU(i)=ymodU(i)-contamS0*ymodU(i)+rmed*contamS0
             endif
             if((xmod(i).ge.0.0d0).and.(xmod(i).lt.92.0d0))then
c               ymodU(i)=ymodU(i)+yoff2
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff2)
               ymodU(i)=ymodU(i)-contamS1*ymodU(i)+rmed*contamS1
             endif
             if((xmod(i).ge.92.0d0).and.(xmod(i).lt.183.0d0))then
c               ymodU(i)=ymodU(i)+yoff3
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff3)
               ymodU(i)=ymodU(i)-contamS2*ymodU(i)+rmed*contamS2
             endif
             if((xmod(i).ge.183.0d0).and.(xmod(i).lt.276.0d0))then
c               ymodU(i)=ymodU(i)+yoff4
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff4)
               ymodU(i)=ymodU(i)-contamS3*ymodU(i)+rmed*contamS3
             endif
             if((xmod(i).ge.276.0d0).and.(xmod(i).lt.372.0d0))then
c               ymodU(i)=ymodU(i)+yoff1
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff1)
               ymodU(i)=ymodU(i)-contamS0*ymodU(i)+rmed*contamS0
             endif
             if((xmod(i).ge.372.0d0).and.(xmod(i).lt.463.0d0))then
c               ymodU(i)=ymodU(i)+yoff2
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff2)
               ymodU(i)=ymodU(i)-contamS1*ymodU(i)+rmed*contamS1
             endif
             if((xmod(i).ge.463.0d0).and.(xmod(i).lt.553.0d0))then
c               ymodU(i)=ymodU(i)+yoff3
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff3)
               ymodU(i)=ymodU(i)-contamS2*ymodU(i)+rmed*contamS2
             endif
             if((xmod(i).ge.553.0d0).and.(xmod(i).lt.636.0d0))then
c               ymodU(i)=ymodU(i)+yoff4
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff4)
               ymodU(i)=ymodU(i)-contamS3*ymodU(i)+rmed*contamS3
             endif
             if((xmod(i).ge.636.0d0).and.(xmod(i).lt.739.0d0))then
c               ymodU(i)=ymodU(i)+yoff1
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff1)
               ymodU(i)=ymodU(i)-contamS0*ymodU(i)+rmed*contamS0
             endif
             if((xmod(i).ge.739.0d0).and.(xmod(i).lt.834.0d0))then
c               ymodU(i)=ymodU(i)+yoff2
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff2)
               ymodU(i)=ymodU(i)-contamS1*ymodU(i)+rmed*contamS1
             endif
             if((xmod(i).ge.834.0d0).and.(xmod(i).lt.932.0d0))then
c               ymodU(i)=ymodU(i)+yoff3
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff3)
               ymodU(i)=ymodU(i)-contamS2*ymodU(i)+rmed*contamS2
             endif
             if((xmod(i).ge.932.0d0).and.(xmod(i).lt.1015.5d0))then
c               ymodU(i)=ymodU(i)+yoff4
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff4)
               ymodU(i)=ymodU(i)-contamS3*ymodU(i)+rmed*contamS3
             endif
             if((xmod(i).ge.1015.5d0).and.(xmod(i).lt.1106.1d0))then
c               ymodU(i)=ymodU(i)+yoff1
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff1)
               ymodU(i)=ymodU(i)-contamS0*ymodU(i)+rmed*contamS0
             endif
             if((xmod(i).ge.1106.1d0).and.(xmod(i).lt.1205.0d0))then
c               ymodU(i)=ymodU(i)+yoff2
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff2)
               ymodU(i)=ymodU(i)-contamS1*ymodU(i)+rmed*contamS1
             endif
             if((xmod(i).ge.1205.0d0).and.(xmod(i).lt.1304.2d0))then
c               ymodU(i)=ymodU(i)+yoff3
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff3)
               ymodU(i)=ymodU(i)-contamS2*ymodU(i)+rmed*contamS2
             endif
             if((xmod(i).ge.1304.2d0).and.(xmod(i).lt.1391.2d0))then
c               ymodU(i)=ymodU(i)+yoff4
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff4)
               ymodU(i)=ymodU(i)-contamS3*ymodU(i)+rmed*contamS3
             endif
             if((xmod(i).ge.1391.21d0).and.(xmod(i).lt.1481.2d0))then
c               ymodU(i)=ymodU(i)+yoff1
c               ymodU(i)=ymodU(i)*rmed/(rmed+yoff1)
               ymodU(i)=ymodU(i)-contamS0*ymodU(i)+rmed*contamS0
             endif

10         continue
c
           return
           end
c
c   @#$%&%$@&@$@!@#$%&%$@&@$@!@#$%&%$@&@$@!@#$%&%$@&@$@!@#$%&%$@&@$@!
c
          subroutine getanalfracs(Nmaxphase,icount,fracs1,fracs2,fracs3,
     @      fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,Nphase,
     %      xmod,eshift,pshift,sw26)
c
c   October 10, 2007
c
c   This is a new routine that will return the luminosity ratios in
c   each bandpass.  compfracs(i,1) will have L_2/L_1, and
c   compfracs(i,2) will have L_disk/L_tot.
c
          implicit double precision(a-h,o-z)
c
          dimension compfracs(8,3),xmod(Nmaxphase)
          dimension fracs1(Nmaxphase,4),fracs2(Nmaxphase,4)
          dimension fracs3(Nmaxphase,4),fracs4(Nmaxphase,4)
          dimension fracs5(Nmaxphase,4),fracs6(Nmaxphase,4)
          dimension fracs7(Nmaxphase,4),fracs8(Nmaxphase,4)
c
          parameter(kkk=720001)  !Nmaxphase
          dimension scratch1(kkk),scratch2(kkk),xscratch(kkk)
          dimension scratch3(kkk)
c
          aaa=1.0d0
          bbb=1.0d0
          ccc=1.0d0
          eee=1.0d0
          do 10 i=1,8     !loop over filters
c          
              do 1 iii=1,Nphase
                NNN=iii
                if(i.eq.1)then
                  fracs1(NNN,1)=fracs1(iii,1)
                  fracs1(NNN,2)=fracs1(iii,2)
                  fracs1(NNN,3)=fracs1(iii,3)
                  fracs1(NNN,4)=fracs1(iii,4)
                endif
                if(i.eq.2)then
                  fracs2(NNN,1)=fracs2(iii,1)
                  fracs2(NNN,2)=fracs2(iii,2)
                  fracs2(NNN,3)=fracs2(iii,3)
                  fracs2(NNN,4)=fracs2(iii,4)
                endif
                if(i.eq.3)then
                  fracs3(NNN,1)=fracs3(iii,1)
                  fracs3(NNN,2)=fracs3(iii,2)
                  fracs3(NNN,3)=fracs3(iii,3)
                  fracs3(NNN,4)=fracs3(iii,4)
                endif
                if(i.eq.4)then
                  fracs4(NNN,1)=fracs4(iii,1)
                  fracs4(NNN,2)=fracs4(iii,2)
                  fracs4(NNN,3)=fracs4(iii,3)
                  fracs4(NNN,4)=fracs4(iii,4)
                endif
                if(i.eq.5)then
                  fracs5(NNN,1)=fracs5(iii,1)
                  fracs5(NNN,2)=fracs5(iii,2)
                  fracs5(NNN,3)=fracs5(iii,3)
                  fracs5(NNN,4)=fracs5(iii,4)
                endif
                if(i.eq.6)then
                  fracs6(NNN,1)=fracs6(iii,1)
                  fracs6(NNN,2)=fracs6(iii,2)
                  fracs6(NNN,3)=fracs6(iii,3)
                  fracs6(NNN,4)=fracs6(iii,4)
                endif
                if(i.eq.7)then
                  fracs7(NNN,1)=fracs7(iii,1)
                  fracs7(NNN,2)=fracs7(iii,2)
                  fracs7(NNN,3)=fracs7(iii,3)
                  fracs7(NNN,4)=fracs7(iii,4)
                endif
                if(i.eq.8)then
                  fracs8(NNN,1)=fracs8(iii,1)
                  fracs8(NNN,2)=fracs8(iii,2)
                  fracs8(NNN,3)=fracs8(iii,3)
                  fracs8(NNN,4)=fracs8(iii,4)
                endif
                xscratch(NNN)=xmod(iii)    ! phase/360.0d0
                xscratch(iii)=xscratch(NNN)
  1            continue
c
c  UPDATE October 27, 2008
c
c  If the variable sw26 is positive, then reference the disk fraction at 
c  sw26.   Otherwise, take the median over the whole orbit.
c   
c
            if(sw26.le.0.0d0)then
              do 8 jj=1,NNN
                if(i.eq.1)then
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
                endif
                if(i.eq.2)then
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
                endif
                if(i.eq.3)then
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
                endif
                if(i.eq.4)then
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
                endif
                if(i.eq.5)then
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
                endif
                if(i.eq.6)then
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
                endif
                if(i.eq.7)then
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
                endif
                if(i.eq.8)then
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
                endif
                ddd=aaa+bbb+ccc+eee
                if(aaa.eq.0.0d0)then
                  scratch1(jj)=0.0d0
                  scratch3(jj)=0.0d0
                else      
                  scratch1(jj)=bbb/aaa
                  scratch3(jj)=eee/aaa
                endif
                if(ddd.eq.0.0d0)then
                  scratch2(jj)=0.0d0
                else      
                  scratch2(jj)=ccc/ddd
                endif
8             continue
c  
              if(icount.le.2)then
                compfracs(i,1)=0.0d0
                compfracs(i,2)=0.0d0
                compfracs(i,3)=0.0d0
                go to 10
              endif

              if(NNN.gt.1)call sort3(NNN,scratch1,scratch2,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                rmedian1=(scratch1(NNN/2)+scratch1(NNN/2+1))/2.0
              else
                rmedian1=scratch1(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch2,scratch1,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian2=(scratch2(NNN/2)+scratch2(NNN/2+1))/2.0
              else
                rmedian2=scratch2(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch3,scratch1,scratch2)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian3=(scratch3(NNN/2)+scratch3(NNN/2+1))/2.0
              else
                rmedian3=scratch3(NNN/2+1)
              endif
c
              if(rmedian1.lt.0.0d0)rmedian1=0.0d0
              if(rmedian2.lt.0.0d0)rmedian2=0.0d0
              if(rmedian3.lt.0.0d0)rmedian3=0.0d0

              compfracs(i,1)=rmedian1
              compfracs(i,2)=rmedian2
              compfracs(i,3)=rmedian3
            else
              diffmin=123456789.0d0
              do 9 jj=1,NNN
                fred=dmod(xscratch(jj)+eshift+pshift,1.0d0)
                if(fred.lt.0.0d0)fred=fred+1.0d0
                if(fred.gt.1.0d0)fred=fred-1.0d0
                diff=dabs(fred-sw26)
                if(diff.le.diffmin)then
                  diffmin=diff

                 if(i.eq.1)then
                   aaa=fracs1(jj,1)
                   bbb=fracs1(jj,2)
                   ccc=fracs1(jj,3)
                   eee=fracs1(jj,4)
                 endif
                 if(i.eq.2)then
                   aaa=fracs2(jj,1)
                   bbb=fracs2(jj,2)
                   ccc=fracs2(jj,3)
                   eee=fracs2(jj,4)
                 endif
                 if(i.eq.3)then
                   aaa=fracs3(jj,1)
                   bbb=fracs3(jj,2)
                   ccc=fracs3(jj,3)
                   eee=fracs3(jj,4)
                 endif
                 if(i.eq.4)then
                   aaa=fracs4(jj,1)
                   bbb=fracs4(jj,2)
                   ccc=fracs4(jj,3)
                   eee=fracs4(jj,4)
                 endif
                 if(i.eq.5)then
                   aaa=fracs5(jj,1)
                   bbb=fracs5(jj,2)
                   ccc=fracs5(jj,3)
                   eee=fracs5(jj,4)
                 endif
                 if(i.eq.6)then
                   aaa=fracs6(jj,1)
                   bbb=fracs6(jj,2)
                   ccc=fracs6(jj,3)
                   eee=fracs6(jj,4)
                 endif
                 if(i.eq.7)then
                   aaa=fracs7(jj,1)
                   bbb=fracs7(jj,2)
                   ccc=fracs7(jj,3)
                   eee=fracs7(jj,4)
                 endif
                 if(i.eq.8)then
                   aaa=fracs8(jj,1)
                   bbb=fracs8(jj,2)
                   ccc=fracs8(jj,3)
                   eee=fracs8(jj,4)
                 endif
c
                  ddd=aaa+bbb+ccc+eee
                  compfracs(i,1)=bbb/aaa
                  if(ddd.eq.0.0d0)then
                    compfracs(i,2)=0.0d0
                  else
                    compfracs(i,2)=ccc/ddd
                  endif  
                  if(aaa.eq.0.0d0)then
                    compfracs(i,3)=0.0d0
                  else
                    compfracs(i,3)=eee/aaa
                  endif  
                endif
9             continue
            endif
c
10        continue
c
          return
          end
c 
c  &&&&&&&&&&&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&&&&&&&
c
          subroutine analdistorttime(Nmaxphase,Nphase,xmod,RV,gamma,
     $        pconj)
c
c   February 5, 2001
c
c   This routine will apply a phase shift to a light or velocity curve

c   
          implicit double precision(a-h,o-z)
c
          parameter(NNdum=720001,speed=2.99792458d5)
          dimension xmod(Nmaxphase)
          dimension RV(Nmaxphase)
c

          do 10 i=1,Nphase
c            write(*,*)xmod(i),yeclipse(i)
c             if(yeclipse(i).gt.0.0d0)then
               if(xmod(i).lt.0.5d0)then
                 ttt=(RV(i)-gamma)/speed*(xmod(i)-pconj)
c                 write(*,*)ttt
                 xmod(i)=xmod(i)+ttt
                else
                 ttt=(RV(i)-gamma)/speed*(xmod(i)-(pconj+1.0d0))
c                 write(*,*)ttt
                 xmod(i)=xmod(i)+ttt
                endif
c             endif
 10       continue
c
          return
          end
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%&@&#$@$@&@&@%@$@#@$#$@#@@
c
          subroutine wRVmod(icount,xmod,ymod,fileout,isw7,gamma)
c
c  February 29, 2012
c
c  This routine will open the output file and record the given model
c  with the RV.  
c  The value of gamma will be added
c
c
c
          implicit double precision(a-h,o-z)

          dimension xmod(icount),ymod(icount)
          character*(*) fileout
c
          open(unit=20,file=fileout,status='unknown')
c
          do 10 i=1,icount
            write(20,100)xmod(i),ymod(i)+gamma
 10       continue
c
          if(isw7.ge.2)then
             close(20)
             return
          endif
          do 20 i=1,icount
            write(20,100)xmod(i)+1.0d0,ymod(i)+gamma
 20       continue
c
          close(20)
c
 100      format(f23.15,3x,1pe21.14)
c
          return
          end
c
c   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c
          subroutine setupgeo3(ialphmax,ibetmax,Nalph,Nbet,ibetlim,
     @      xarray,yarray,zarray,mmdx,phiarr,surf,radarray,gradx,grady,
     @      gradz,garray,tmatrix,reff1,SA3,reff3,t3,g3,grav3)
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265359879323d0,twopie=pie+pie)
          dimension xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     $      zarray(ialphmax*ibetmax),surf(ialphmax*ibetmax),
     &      gradx(ialphmax*ibetmax),ibetlim(ialphmax),
     $      grady(ialphmax*ibetmax),gradz(ialphmax*ibetmax),
     %      radarray(ialphmax*ibetmax),garray(ialphmax*ibetmax),
     @      mmdx(ialphmax,ibetmax),phiarr(ialphmax*ibetmax),
     @      tmatrix(ialphmax*ibetmax),grav3(ialphmax*ibetmax)
c
          itide=0
          tidephi=0.0d0         
c          tider=pie*tidephi/180.0d0
          ecc=0.0d0
          thetamis=0.0d0
          phimis=0.0d0 
          bdist=1.0d0
          omega=1.0d0
          psi0=1.d3
          overQ=1.0d0/30.0d0
c          sarea3=0.0d0
          vol=0.0d0
c          istar=0
c          iverb=99
c          fill=1.0d0
c
          dtheta=pie/dble(Nalph)
c
          do 3104 ialf=1,Nalph
            ibetlim(ialf)=4*Nbet
            r=0.00000001d0
            call rad(overQ,omega,0.0d0,0.0d0,1.0d0,psi0,r,x,y,z,1,bdist,
     @         tidephi,itide,ecc,thetamis,phimis)
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            dphi=twopie/dble(ibetlim(ialf))
            snth=dsin(theta)
            snth3=dsin(theta)/3.0d0  !*0.333333333333333d0
            cnth=dcos(theta)
            DO 3105 ibet=1,ibetlim(ialf)
c
c   UPDATE June 11, 2003
c
c   change the 2D arrays into 1D
c
              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              mmdx(ialf,ibet)=iidx
              phi=-0.5d0*dphi+dphi*dble(ibet)
              phiarr(iidx)=phi
              cox=dcos(phi)*snth                !*dsin(theta)
              coy=dsin(phi)*snth                !*dsin(theta)
              coz=cnth                          !dcos(theta)
              CALL RAD(overQ,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,
     $         tidephi,itide,ecc,thetamis,phimis)
              call POTEN(overQ,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,
     @          bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
c
              radarray(iidx) = R
              garray(iidx) = DSQRT(PSIX**2+PSIY**2+PSIZ**2)
              oneoverg=1.0d0/garray(iidx)
              GRADX(iidx) = -PSIX*oneoverg
              GRADY(iidx) = -PSIY*oneoverg
              GRADZ(iidx) = -PSIZ*oneoverg
              surf(iidx) = COX*GRADX(iidx)+COY*GRADY(iidx)
     $           + COZ*GRADZ(iidx)
c
c   The following check is for large separations.
c
c              if(surf(iidx).lt.0.7d0)surf(iidx)=0.7d0
c
              surf(iidx) = R**2 / surf(iidx)
c
c   Add terms to account for the delta phi and delta theta terms.
c
c   Expression with distribution of points linear in theta.
c
              surf(iidx)=surf(iidx)*dphi*dtheta*snth
c
c   Keep track of the surface area and volume.
c
              sarea=sarea+surf(iidx)
c
c   Expression with distribution of points linear in theta.
c
              VOL = VOL + 1.0d0*R*R*R*dphi*dtheta*snth3
c
c   Assign x,y,z coordinates of grid point
c
              xarray(iidx)=x  !radius vector times the direction cosine
              yarray(iidx)=y  ! "" ""          ""   ""
              zarray(iidx)=z  
c
3105        CONTINUE    ! continue ialf loop
3104      CONTINUE                   ! continue over ibet
c
          REFF = (0.75d0*VOL/pie) **(1.0d0/3.0d0) 
c
          SA1=reff1*reff1*4.0d0*pie
          Sneed=SA1*SA3
          Rneed=dsqrt(Sneed/4.0d0/pie)
          scale=Rneed/Reff
c
          do 4104 ialf=1,Nalph
            DO 4105 ibet=1,ibetlim(ialf)
              iidx=kount(ialphmax,ialf,ibetlim)+ibet
              radarray(iidx) = radarray(iidx)*scale
              surf(iidx)=surf(iidx)*scale*scale
              xarray(iidx)=xarray(iidx)*scale
              yarray(iidx)=yarray(iidx)*scale
              zarray(iidx)=zarray(iidx)*scale
              tmatrix(iidx)=t3
              grav3(iidx)=10.0d0**(g3)
4105        CONTINUE    ! continue ialf loop
4104      CONTINUE                   ! continue over ibet
c

c          if(istar.eq.1)then
c            if(iverb.eq.0)then
c              write(2,999)Q,1.0d0/Q
c              write(2,1000)Rl,Rl*fill,reff,fill*rocheradius(1.0d0/Q)
c              write(2,1002)reff*separation
c              write(2,1005)rocheradius(1.0d0/Q)
c              write(2,1007)savepsi0,psi0
c              write(3,2000)reff
c            endif
cc
c 5004       format('reff-r_pole   = ',f16.11,' percent') 
c 5005       format('reff-x(point) = ',f16.11,' percent') 
c 5006       format('reff-x(end)   = ',f16.11,' percent') 
cc
cc   NEW BUG ALERT  July 13, 2001
cc
cc   Change the indices of xend to 3,4
cc
c            if(iverb.eq.0)then
c              write(3,2004)psi0
c              write(3,2005)sarea
c              write(3,2006)vol
c              write(3,2007)Tpole
c            endif
c          endif
c          if(istar.eq.2)then
cc
c            psi0=psi0/overQ+0.5d0*(overQ-1.0d0)/overQ
c            savepsi0=savepsi0/overQ+0.5d0*(overQ-1.0d0)/overQ
c            if(iverb.eq.0)then
c              write(2,1001)Rl,Rl*fill,reff,fill*rocheradius(Q)
c              write(2,1002)reff*separation
c              write(2,1005)rocheradius(Q)
c              write(2,1007)savepsi0,psi0
c              write(3,3000)reff
c            endif
c
c   July 13, 2001
c
c   Change the indices of xend to 3,4
c
c          endif
c
c   Make the xend array contain the poles of the star for compatability
c   with the plotting subroutine
c
c
c
          reff3=Rneed

          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getbody3(Nalph3,Nbet3,tertperiod,tertt0,tertecos,
     @         tertesin,tertincl,tertOmega,tertQ,dwavex,dwavey,itconj,
     @         it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,
     @         P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
     @         P2ratrad,
     @         P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @         P3ratrad,
     @         P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,P4Omega,P4Q,
     @         P4ratrad,
     @         P5tconj,P5period,P5T0,P5ecos,P5esin,P5incl,P5Omega,P5Q,
     @         P5ratrad,   
     @         P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
     @         P6ratrad,
     @         P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
     @         P7ratrad,
     @         P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @         P8ratrad)
c
          implicit double precision(a-h,o-z)
c
          dimension dwavex(8,3),dwavey(8,3)
c
          ios=0
          open(unit=1,file='ELCbody3.inp',status='old',err=100,
     @         iostat=ios)
c
          read(1,*)Nalph3
          read(1,*)Nbet3
          read(1,*)itconj
          read(1,*)it1
          read(1,*)it2
          read(1,*)it3
          read(1,*)it4
          read(1,*)tertconj
          read(1,*)tertperiod
          read(1,*)tertt0
          read(1,*)tertecos
          read(1,*)tertesin
          read(1,*)tertincl
          read(1,*)tertOmega
          read(1,*)tertQ
c
c  Load the limb darkening parameters. 
c         
          do 10 i=1,8
            read(1,*)dwavex(i,3),dwavey(i,3)
 10       continue
c
          read(1,*)tertratrad
          read(1,*)hh
          read(1,*)sw72
          read(1,*)sw73
          read(1,*)P2tconj
          read(1,*)P2period
          read(1,*)P2T0
          read(1,*)P2ecos
          read(1,*)P2esin
          read(1,*)P2incl
          read(1,*)P2Omega
          read(1,*)P2Q
          read(1,*)P2ratrad

          read(1,*)P3tconj
          read(1,*)P3period
          read(1,*)P3T0
          read(1,*)P3ecos
          read(1,*)P3esin
          read(1,*)P3incl
          read(1,*)P3Omega
          read(1,*)P3Q
          read(1,*)P3ratrad

          read(1,*)P4tconj
          read(1,*)P4period
          read(1,*)P4T0
          read(1,*)P4ecos
          read(1,*)P4esin
          read(1,*)P4incl
          read(1,*)P4Omega
          read(1,*)P4Q
          read(1,*)P4ratrad

          read(1,*)P5tconj
          read(1,*)P5period
          read(1,*)P5T0
          read(1,*)P5ecos
          read(1,*)P5esin
          read(1,*)P5incl
          read(1,*)P5Omega
          read(1,*)P5Q
          read(1,*)P5ratrad
c
          read(1,*)P6tconj
          read(1,*)P6period
          read(1,*)P6T0
          read(1,*)P6ecos
          read(1,*)P6esin
          read(1,*)P6incl
          read(1,*)P6Omega
          read(1,*)P6Q
          read(1,*)P6ratrad
c
          read(1,*)P7tconj
          read(1,*)P7period
          read(1,*)P7T0
          read(1,*)P7ecos
          read(1,*)P7esin
          read(1,*)P7incl
          read(1,*)P7Omega
          read(1,*)P7Q
          read(1,*)P7ratrad
c
          read(1,*)P8tconj
          read(1,*)P8period
          read(1,*)P8T0
          read(1,*)P8ecos
          read(1,*)P8esin
          read(1,*)P8incl
          read(1,*)P8Omega
          read(1,*)P8Q
          read(1,*)P8ratrad
c
c   Come here if the input file ELCbody3.inp does not exist. The subroutine
c   writeinput will make the correct file and set default values.
c
 100      if(ios.gt.0)call writebody3input(Nalph3,Nbet3,tertperiod,
     @       tertt0,tertecos,tertesin,tertincl,tertOmega,tertQ,dwavex,
     @       dwavey,itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,
     @       sw73,P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,
     @       P2Q,P2ratrad,P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,
     @       P3Omega,P3Q,P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,
     @       P4incl,P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,
     @       P5esin,P5incl,P5Omega,P5Q,P5ratrad,
     @       P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
     @       P6ratrad,
     @       P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
     @       P7ratrad,
     @       P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @       P8ratrad)
c
c
c   Put this if-then block for successful completion.
c
          if(ios.eq.0)then 
            close(1)
            return
          endif
c
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine writebody3input(Nalph3,Nbet3,tertperiod,
     @       tertt0,tertecos,tertesin,tertincl,tertOmega,tertQ,dwavex,
     @       dwavey,itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,
     @       sw73,P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,
     @       P2Q,P2ratrad,P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,
     @       P3Omega,P3Q,P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,
     @       P4incl,P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,
     @       P5esin,P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,
     @       P6ecos,P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,
     @       P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,
     @       P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @       P8ratrad)
c

c    will write the correctly formatted file ELCbody3.inp and return
c    default parameters
c
          implicit double precision(a-h,o-z)
c
          dimension dwavex(8,3),dwavey(8,3)

          character*1 bell
c
c
          bell=char(7)
          write(*,100)bell
c
          Nalph3=60
          Nbet3=20
          tertperiod=20.0d0
          tertt0=1020.0d0
          tertecos=0.10d0
          tertesin=-0.20d0
          tertincl=90.0d0
          tertOmega=0.0d0
          tertQ=0.5d0
          tertconj=50.0d0
          itconj=0
          it1=0
          it2=0
          it3=0
          it4=0
          tertratrad=0.0d0
          hh=0.0d0
          sw72=0.0d0
          sw73=0.0d0
c
          P2tconj=0.0d0
          P2period=0.0d0
          P2T0=0.0d0
          P2ecos=0.0d0
          P2esin=0.0d0
          P2incl=0.0d0
          P2Omega=0.0d0
          P2Q=0.0d0
          P2ratrad=0.0d0
c
          P3tconj=0.0d0
          P3period=0.0d0
          P3T0=0.0d0
          P3ecos=0.0d0
          P3esin=0.0d0
          P3incl=0.0d0
          P3Omega=0.0d0
          P3Q=0.0d0
          P3ratrad=0.0d0
c
          P4tconj=0.0d0
          P4period=0.0d0
          P4T0=0.0d0
          P4ecos=0.0d0
          P4esin=0.0d0
          P4incl=0.0d0
          P4Omega=0.0d0
          P4Q=0.0d0
          P4ratrad=0.0d0
c
          P5tconj=0.0d0
          P5period=0.0d0
          P5T0=0.0d0
          P5ecos=0.0d0
          P5esin=0.0d0
          P5incl=0.0d0
          P5Omega=0.0d0
          P5Q=0.0d0
          P5ratrad=0.0d0
c
          P6tconj=0.0d0
          P6period=0.0d0
          P6T0=0.0d0
          P6ecos=0.0d0
          P6esin=0.0d0
          P6incl=0.0d0
          P6Omega=0.0d0
          P6Q=0.0d0
          P6ratrad=0.0d0
c
          P7tconj=0.0d0
          P7period=0.0d0
          P7T0=0.0d0
          P7ecos=0.0d0
          P7esin=0.0d0
          P7incl=0.0d0
          P7Omega=0.0d0
          P7Q=0.0d0
          P7ratrad=0.0d0
c
          P8tconj=0.0d0
          P8period=0.0d0
          P8T0=0.0d0
          P8ecos=0.0d0
          P8esin=0.0d0
          P8incl=0.0d0
          P8Omega=0.0d0
          P8Q=0.0d0
          P8ratrad=0.0d0
c
          do i=1,8
            dwavex(i,3)=0.635d0
            dwavey(i,3)=0.130d0
          enddo
c
          open(unit=1,file='ELCbody3.inp',status='unknown')
c
          write(1,1000)Nalph3
          write(1,1001)Nbet3
          write(1,2001)itconj
          write(1,2002)it1
          write(1,2003)it2
          write(1,2004)it3
          write(1,2005)it4
          write(1,2006)tertconj
          write(1,1002)tertperiod
          write(1,1003)tertt0
          write(1,1004)tertecos
          write(1,1005)tertesin
          write(1,1006)tertincl
          write(1,1007)tertOmega
          write(1,1008)tertQ
          do 10 i=1,8
            write(1,2000)dwavex(i,3),dwavey(i,3)
 10       continue
          write(1,2007)tertratrad
          write(1,2008)hh
          write(1,2009)sw72
          write(1,2010)sw73
c
          write(1,2020)P2tconj
          write(1,2021)P2period
          write(1,2022)P2T0
          write(1,2023)P2ecos
          write(1,2024)P2esin
          write(1,2025)P2incl
          write(1,2026)P2Omega
          write(1,2027)P2Q
          write(1,2028)P2ratrad

          write(1,2030)P3tconj
          write(1,2031)P3period
          write(1,2032)P3T0
          write(1,2033)P3ecos
          write(1,2034)P3esin
          write(1,2035)P3incl
          write(1,2036)P3Omega
          write(1,2037)P3Q
          write(1,2038)P3ratrad
c
          write(1,2040)P4tconj
          write(1,2041)P4period
          write(1,2042)P4T0
          write(1,2043)P4ecos
          write(1,2044)P4esin
          write(1,2045)P4incl
          write(1,2046)P4Omega
          write(1,2047)P4Q
          write(1,2048)P4ratrad
c
          write(1,2050)P5tconj
          write(1,2051)P5period
          write(1,2052)P5T0
          write(1,2053)P5ecos
          write(1,2054)P5esin
          write(1,2055)P5incl
          write(1,2056)P5Omega
          write(1,2057)P5Q
          write(1,2058)P5ratrad
c
          write(1,2060)P6tconj
          write(1,2061)P6period
          write(1,2062)P6T0
          write(1,2063)P6ecos
          write(1,2064)P6esin
          write(1,2065)P6incl
          write(1,2066)P6Omega
          write(1,2067)P6Q
          write(1,2068)P6ratrad
c
          write(1,2070)P7tconj
          write(1,2071)P7period
          write(1,2072)P7T0
          write(1,2073)P7ecos
          write(1,2074)P7esin
          write(1,2075)P7incl
          write(1,2076)P7Omega
          write(1,2077)P7Q
          write(1,2078)P7ratrad
c
          write(1,2080)P8tconj
          write(1,2081)P8period
          write(1,2082)P8T0
          write(1,2083)P8ecos
          write(1,2084)P8esin
          write(1,2085)P8incl
          write(1,2086)P8Omega
          write(1,2087)P8Q
          write(1,2088)P8ratrad
c
 2001     format(i1,19x,'itconj (0=T_peri, 1=T_tran, 2=T_occul)')
 2002     format(i1,19x,'set to 1 for logarithmic mass ratios')
 2003     format(i1,19x,'set to 1 for informational output file')
 2004     format(i1,19x,'it3 (currently inactive)')
 2005     format(i1,19x,'it4 (currently inactive)')
 2006     format(f16.8,4x,'tertconj             tag tj')
 2007     format(f4.2,16x,'tertratrad (P1 radius to star 1 radius,' 
     @                 'tag tb')
 2008     format(f16.8,4x,'h (step size for dynamical integration)')
 2009     format(f10.8,10x,'rk1 (apsidal constant star 1  tag a1)')
 2010     format(f10.8,10x,'rk2 (apsidal constant star 2  tag a2)')
c
          close(1)
c
 100      format(a1,'I can''t find the file ''ELCbody3.inp''!',/
     @     'I''m making one up and setting default values')
c
 1000     format(i2,18x,'Nalph3')
 1001     format(i2,18x,'Nbet3')
 1002     format(f14.6,6x,'tertperiod (days)    tag tt')
 1003     format(f16.8,4x,'tertT0               tag tu')
 1004     format(f12.9,8x,'terte*cos(omega)     tag tv')
 1005     format(f12.9,8x,'terte*sin(omega)     tag tw')
 1006     format(f13.9,7x,'tertincl (degrees)   tag tx')
 1007     format(f13.8,7x,'tertOmega (degrees)  tag ty')
 1008     format(f19.7,1x,'tertQ (EB/body3)     tag tz')
 2000     format(2(f9.6,1x))
c
2020      format(f13.6,7x,'P2tconj              tag uj')
2021      format(f14.6,6x,'P2period (days)      tag ut')
2022      format(f16.8,4x,'P2T0                 tag uu')
2023      format(f12.9,8x,'P2ecos               tag uv')
2024      format(f12.9,8x,'P2esin               tag uw')
2025      format(f13.8,7x,'P2incl (degrees)     tag ux')
2026      format(f13.8,7x,'P2Omega (degrees)    tag uy')
2027      format(f19.7,1x,'P2Q (EB/body3)       tag uz')
2028      format(f13.6,7x,'P2ratrad             tag ub')
c
2030      format(f13.6,7x,'P3tconj              tag vj')
2031      format(f14.6,6x,'P3period (days)      tag vt')
2032      format(f16.8,4x,'P3T0                 tag vu')
2033      format(f12.9,8x,'P3ecos               tag vv')
2034      format(f12.9,8x,'P3esin               tag vw')
2035      format(f13.8,7x,'P3incl (degrees)     tag vx')
2036      format(f13.8,7x,'P3Omega (degrees)    tag vy')
2037      format(f19.7,1x,'P3Q (EB/body3)       tag vz')
2038      format(f13.6,7x,'P3ratrad             tag vb')
c
2040      format(f13.6,7x,'P4tconj              tag wj')
2041      format(f14.6,6x,'P4period (days)      tag wt')
2042      format(f16.8,4x,'P4T0                 tag wu')
2043      format(f12.9,8x,'P4ecos               tag wv')
2044      format(f12.9,8x,'P4esin               tag ww')
2045      format(f13.8,7x,'P4incl (degrees)     tag wx')
2046      format(f13.8,7x,'P4Omega (degrees)    tag wy')
2047      format(f19.7,1x,'P4Q (EB/body3)       tag wz')
2048      format(f13.6,7x,'P4ratrad             tag wb')
c
2050      format(f13.6,7x,'P5tconj              tag xj')
2051      format(f14.6,6x,'P5period (days)      tag xt')
2052      format(f16.8,4x,'P5T0                 tag xu')
2053      format(f12.9,8x,'P5ecos               tag xv')
2054      format(f12.9,8x,'P5esin               tag xw')
2055      format(f13.8,7x,'P5incl (degrees)     tag xx')
2056      format(f13.8,7x,'P5Omega (degrees)    tag xy')
2057      format(f19.7,1x,'P5Q (EB/body3)       tag xz')
2058      format(f13.6,7x,'P5ratrad             tag xb')
c
2060      format(f13.6,7x,'P6tconj              tag sj')
2061      format(f14.6,6x,'P6period (days)      tag st')
2062      format(f16.8,4x,'P6T0                 tag su')
2063      format(f12.9,8x,'P6ecos               tag sv')
2064      format(f12.9,8x,'P6esin               tag sw')
2065      format(f13.8,7x,'P6incl (degrees)     tag sx')
2066      format(f13.8,7x,'P6Omega (degrees)    tag sy')
2067      format(f19.7,1x,'P6Q (EB/body3)       tag sz')
2068      format(f13.6,7x,'P6ratrad             tag sb')
c
2070      format(f13.6,7x,'P7tconj              tag hj')
2071      format(f14.6,6x,'P7period (days)      tag ht')
2072      format(f16.8,4x,'P7T0                 tag hu')
2073      format(f12.9,8x,'P7ecos               tag hv')
2074      format(f12.9,8x,'P7esin               tag hw')
2075      format(f13.8,7x,'P7incl (degrees)     tag hx')
2076      format(f13.8,7x,'P7Omega (degrees)    tag hy')
2077      format(f19.7,1x,'P7Q (EB/body3)       tag hz')
2078      format(f13.6,7x,'P7ratrad             tag hb')
c
2080      format(f13.6,7x,'P8tconj              tag kj')
2081      format(f14.6,6x,'P8period (days)      tag kt')
2082      format(f16.8,4x,'P8T0                 tag ku')
2083      format(f12.9,8x,'P8ecos               tag kv')
2084      format(f12.9,8x,'P8esin               tag kw')
2085      format(f13.8,7x,'P8incl (degrees)     tag kx')
2086      format(f13.8,7x,'P8Omega (degrees)    tag ky')
2087      format(f19.7,1x,'P8Q (EB/body3)       tag kz')
2088      format(f13.6,7x,'P8ratrad             tag kb')
c

          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine gethorizon3(Nhoriz3,xhoriz3,yhoriz3,reff3,
     @        axisscale,tertbdist,tertphase,tertincl,tertQ,tertOmega)
c
          implicit double precision(a-h,o-z)
c
          dimension xhoriz3(Nhoriz3),yhoriz3(Nhoriz3)
c
          pie=3.141592653589793d0
c
          iflag=1
          xcent1=tertxcen(iflag,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
          ycent1=tertycen(iflag,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
          tOmrad=TertOmega*pie/180.0d0
          xcent=xcent1*dcos(tOmrad)-ycent1*dsin(tOmrad)
          ycent=xcent1*dsin(tOmrad)+ycent1*dcos(tOmrad)
c         
          do 10 i=1,360
            theta=dble(i)*pie/180.0d0
            xhoriz3(i)=reff3*dcos(theta)+xcent
            yhoriz3(i)=reff3*dsin(theta)+ycent
 10       continue
c
          iflag=2
c
          return
c
          end
c
c   %%%%%%%%%%%%%%
c
          function tertxcen(iflag,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
c
          implicit double precision(a-h,o-z)
c
          pie=3.141592653589793d0
c
          dummyphase=tertphase
          overQ=tertQ
          xx=0.0d0
          yy=0.0d0
          zz=0.0d0
          if(iflag.eq.2)dummyphase=tertphase+180.0d0
c          if(iflag.eq.2)x=1.0
          fincr=tertincl*pie/180.0d0
          bdist=tertbdist*axisscale
c
          tertxcen=xtran(xx,yy,zz,dummyphase,fincr,overQ,iflag,bdist) 
          return
          end
c
c   @@@@@&&&&&&&&&&&&&&&&&&&&&&&&&
c
          function tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)
c
          implicit double precision(a-h,o-z)
c
          pie=3.141592653589793d0
c
          fincr = (tertincl/180.0d0)*pie
          bdist=tertbdist*axisscale
          tOmrad=TertOmega*pie/180.0d0
          xp=xtran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist) 
          yp=ytran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist)
          xc=xp*dcos(tOmrad)-yp*dsin(tOmrad)
c          yc=xp*dsin(tOmrad)+yp*dcos(tOmrad)
          tertxtrans=xc
c          tertytrans=yc
          return
          end
c
c   @^*&%&^%$&^$%^#^%#$$@$%@$&*%&%&^%^&#^#$%#^@
c
          function tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)
c
          implicit double precision(a-h,o-z)
c
          pie=3.141592653589793d0
c
          fincr = (tertincl/180.0d0)*pie
          bdist=tertbdist*axisscale
          tOmrad=TertOmega*pie/180.0d0
          xp=xtran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist) 
          yp=ytran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist)
c          xc=xp*dcos(tOmrad)-yp*dsin(tOmrad)
          yc=xp*dsin(tOmrad)+yp*dcos(tOmrad)
c          tertxtrans=xc
          tertytrans=yc
          return
          end
c
c   @^*&%&^%$&^$%^#^%#$$@$%@$&*%&%&^%^&#^#$%#^@
c
          function tertycen(iflag,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
c
          implicit double precision(a-h,o-z)

          pie=3.141592653589793d0
c
          dummyphase=tertphase
          overQ=tertQ
          xx=0.0d0
          yy=0.0d0
          zz=0.0d0
          if(iflag.eq.2)dummyphase=tertphase+180.0d0
c          if(iflag.eq.2)x=1.0d0
          fincr=tertincl*pie/180.0d0
          bdist=tertbdist*axisscale
c
          tertycen=ytran(xx,yy,zz,dummyphase,fincr,overQ,iflag,bdist) 
          return
          end
c
c   @@@@@
c
c
c  %%%%%%%%%%%%%%%%%%%%%
c
          subroutine fakehorizon(Nhoriz3,xhoriz3,yhoriz3,xxx,yyy,reff3)
c
          implicit double precision(a-h,o-z)
c
          dimension xhoriz3(Nhoriz3),yhoriz3(Nhoriz3)
c
          pie=3.141592653589793d0
c
          do 10 i=1,360
            theta=dble(i)*pie/180.0d0
            xhoriz3(i)=reff3*dcos(theta)+xxx
            yhoriz3(i)=reff3*dsin(theta)+yyy
 10       continue
c
          return
c
          end
c
c   @@@#######&&&&&&&&&%%%%%%%%%%$$$$$
c
          subroutine tertnu(tertphase,tertecc,tertbdist,tertrnu)
c
          implicit double precision(a-h,o-z)
c
          pie=3.14159265358979323d0

          em=tertphase*pie/180.0d0
c
          call getE(em,tertecc,bigE)
c
c   Add these blocks to ensure that angles are within the set limits
c
          bigE=dmod(bigE,2.0d0*pie)

c31153     if(bigE.lt.0.0)then
c            bigE=bigE+2.0d0*pie
c            go to 31153
c          endif
c22202    if(bigE.gt.2.0d0*pie)then
c           bigE=bigE-2.0d0*pie
c           go to 22202
c         endif
         tertrnu=2.0d0*datan(dsqrt((1.0d0+tertecc)/(1.0d0-tertecc))
     @            *dtan(bigE/2.0d0))
c
c   Add these blocks to ensure that angles are within the set limits
c
c31101    if(tertrnu.lt.0.0)then
c           tertrnu=tertrnu+2.0d0*pie
c           go to 31101
c         endif
c41101    if(tertrnu.gt.2.0d0*pie)then
c           tertrnu=tertrnu-2.0d0*pie
c           go to 41101
c         endif
   
         
        tertrnu=dmod(tertrnu,2.0d0*pie)
        tertbdist=(1.0d0-tertecc*dcos(bigE))
c
         return
         end
c
c  @@@@@@@@@@@@@@@@@@@@@@@@@
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getgap(Ngap,gaplow,gaphigh)
c
          implicit double precision(a-h,o-z)
c
          dimension gaplow(9999),gaphigh(9999)
c
c   Declare the variable bell to be character*1
c
          character*1 bell
c
          bell=char(7)
          ios=0
          open(unit=1,file='ELCgap.inp',status='old',err=100,
     @         iostat=ios)
c
          do 10 i=1,Ngap
            read(1,*,err=101,end=101)gaplow(i),gaphigh(i)
 10       continue

          if(ios.eq.0)then 
            close(1)
            return
          endif
c
c   Come here if the input file ELCgap.inp does not exist. 
c
 100      write(*,1000)bell
          Ngap=0
          return
c
 101      write(*,1002)bell
          Ngap=0
          close(1)
          return
c
c
c   Put this if-then block for successful completion.
c
c
 1000     format(a1,'Error:  File ELCgap.inp does not exist,',
     @       ' setting Ngap=0')
 1002     format(a1,'Error:  Bad entry in ELCgap.inp, setting Ngap=0')
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%
c
c@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
c
c
          subroutine getT0tran(finc,period,ecc,argper,T0,Tconj)
c
c   January 30, 2010.
c
c   This routine is the inverse of getcontimes.  Given a time of transit,
c   it will figure out the T0 needed.
c
          implicit double precision (a-h,o-z)
c
          if(period.le.0.0d0)then
            T0=0.0d0
            return
          endif
          pie=3.141592653589793d0
c
          fincr=finc*pie/180.0d0
          omegar=argper*pie/180.0d0
          ft=0.5d0*pie-omegar
3139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 3139
3140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 3140

          guess=ft
          do 22 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 23
            ft=guess
22        continue

 23       ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 31501
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 31501
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 31103
31501     ecan=pie
31103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
c          ttt=deltaT/period

c
          ft=1.5d0*pie-omegar
4139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 4139
4140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 4140

          guess=ft
          do 422 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 423
            ft=guess
422       continue

 423      ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 41101
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41101
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 41103
41101     ecan=pie
41103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
c          ttt=deltaT/period

          t0=tconj-deltaT
c
          return
          end
c
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@@@@@@@@@@@$$$$$$
c
          subroutine getgridinput(kkk,Nalph1,Nbet1,Nalph2,Nbet2,fill1,
     $      fill2,omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,
     $      betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,
     &      Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,
     @      sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,
     @      icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,
     @      dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,
     @      sw8,sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,
     @      spot2parm,spotdparm,primmass,primK,primrad,ratrad,frac1,
     @      frac2,ecosw,temprat,idark1,idark2,isw12,isw13,isw21,isw22,
     @      isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,
     @      sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,isw25,isw26,
     @      isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,ocose,
     @      osine,omegadot,contamS0,contamS1,contamS2,contamS3,
     @      sw47,sw48,sw49)
c
c   UPDATE December 20, 2012
c
c   This routine used by geneticELC.  If ieliete > 1, then open ELC.1001
c   ELC.1002, ... ELC.100(ielete-1)
c
          implicit double precision(a-h,o-z)
c
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @      dwavey(8,3)
c
          dimension spot1parm(2,4),spot2parm(2,4),spotdparm(2,4)
          dimension powercoeff(8,9)
c
          character*4 extension
          character*1 bell
c
          if(kkk.gt.9999)then
            bell=char(7)
            write(*,305)bell
            stop
          endif
            
          if(kkk.lt.10)write(extension,301)kkk
          if((kkk.ge.10).and.(kkk.lt.100))write(extension,302)kkk
          if((kkk.ge.100).and.(kkk.lt.1000))write(extension,303)kkk
          if(kkk.ge.1000)write(extension,304)kkk
c
 301      format('100',i1)
 302      format('10',i2)
 303      format('1',i3)
 304      format(i4)
 305      format(a1,'ielete is too large')
c
          ios=0
          open(unit=1,file='ELC.'//extension,status='old',err=100,
     @       iostat=ios)
c
          read(1,*,end=101,err=101)Nalph1
          read(1,*,end=101,err=101)Nbet1
          read(1,*,end=101,err=101)Nalph2
          read(1,*,end=101,err=101)Nbet2
          read(1,*,end=101,err=101)fill1
          read(1,*,end=101,err=101)fill2
          read(1,*,end=101,err=101)omega1
          read(1,*,end=101,err=101)omega2
          read(1,*,end=101,err=101)dphase
          read(1,*,end=101,err=101)Q
          read(1,*,end=101,err=101)finc
          read(1,*,end=101,err=101)Teff1
          read(1,*,end=101,err=101)Teff2
          read(1,*,end=101,err=101)Tgrav1
          read(1,*,end=101,err=101)Tgrav2
          read(1,*,end=101,err=101)betarim
          read(1,*,end=101,err=101)rinner
          read(1,*,end=101,err=101)router
          read(1,*,end=101,err=101)tdisk
          read(1,*,end=101,err=101)xi
          read(1,*,end=101,err=101)Ntheta
          read(1,*,end=101,err=101)Nradius
          read(1,*,end=101,err=101)alb1
          read(1,*,end=101,err=101)alb2
          read(1,*,end=101,err=101)Nref
          read(1,*,end=101,err=101)rLx
          read(1,*,end=101,err=101)Period
          read(1,*,end=101,err=101)fm
          read(1,*,end=101,err=101)separ
          read(1,*,end=101,err=101)gamma
          read(1,*,end=101,err=101)t3
          read(1,*,end=101,err=101)g3
          read(1,*,end=101,err=101)SA3
          read(1,*,end=101,err=101)density
          read(1,*,end=101,err=101)sw1
          read(1,*,end=101,err=101)sw2
          read(1,*,end=101,err=101)sw3
          read(1,*,end=101,err=101)T0
          read(1,*,end=101,err=101)idraw
          read(1,*,end=101,err=101)iecheck
          read(1,*,end=101,err=101)iidint
          read(1,*,end=101,err=101)iatm
          read(1,*,end=101,err=101)ism1
          read(1,*,end=101,err=101)icnU,icnB,icnV,icnR,icnI,icnJ,icnH,
     @          icnK
          read(1,*,end=101,err=101)iRVfilt
          read(1,*,end=101,err=101)isw1
          read(1,*,end=101,err=101)isw2
          read(1,*,end=101,err=101)isw3
          read(1,*,end=101,err=101)isw4
          read(1,*,end=101,err=101)ilaw
          do 10 i=1,8
            read(1,*,end=101,err=101)wave(i),dbolx(i,1),dboly(i,1),
     @         dbolx(i,2),dboly(i,2),dwavex(i,1),dwavey(i,1),
     @         dwavex(i,2),dwavey(i,2)
            dwavex(i,3)=dwavex(i,1)
            dwavey(i,3)=dwavey(i,1)
 10       continue
          read(1,*,end=101,err=101)ecc
          read(1,*,end=101,err=101)argper
          read(1,*,end=101,err=101)pshift
          read(1,*,end=101,err=101)sw5
          read(1,*,end=101,err=101)sw6
          read(1,*,end=101,err=101)sw7
          read(1,*,end=101,err=101)sw8
          read(1,*,end=101,err=101)sw9
          read(1,*,end=101,err=101)ikeep
          read(1,*,end=101,err=101)isynch
          read(1,*,end=101,err=101)isw5
          read(1,*,end=101,err=101)isw6
          read(1,*,end=101,err=101)isw7
          read(1,*,end=101,err=101)isw8
          read(1,*,end=101,err=101)isw9
          ios=0
          read(1,*,end=101,err=101)spot1parm(1,1)
          read(1,*,end=101,err=101)spot1parm(1,2)
          read(1,*,end=101,err=101)spot1parm(1,3)
          read(1,*,end=101,err=101)spot1parm(1,4)
          read(1,*,end=101,err=101)spot1parm(2,1)
          read(1,*,end=101,err=101)spot1parm(2,2)
          read(1,*,end=101,err=101)spot1parm(2,3)
          read(1,*,end=101,err=101)spot1parm(2,4)
          read(1,*,end=101,err=101)spot2parm(1,1)
          read(1,*,end=101,err=101)spot2parm(1,2)
          read(1,*,end=101,err=101)spot2parm(1,3)
          read(1,*,end=101,err=101)spot2parm(1,4)
          read(1,*,end=101,err=101)spot2parm(2,1)
          read(1,*,end=101,err=101)spot2parm(2,2)
          read(1,*,end=101,err=101)spot2parm(2,3)
          read(1,*,end=101,err=101)spot2parm(2,4)
          read(1,*,end=101,err=101)spotdparm(1,1)
          read(1,*,end=101,err=101)spotdparm(1,2)
          read(1,*,end=101,err=101)spotdparm(1,3)
          read(1,*,end=101,err=101)spotdparm(1,4)
          read(1,*,end=101,err=101)spotdparm(2,1)
          read(1,*,end=101,err=101)spotdparm(2,2)
          read(1,*,end=101,err=101)spotdparm(2,3)
          read(1,*,end=101,err=101)spotdparm(2,4)
          read(1,*,end=101,err=101)primmass
          read(1,*,end=101,err=101)primK
          read(1,*,end=101,err=101)primrad
          read(1,*,end=101,err=101)ratrad
          read(1,*,end=101,err=101)frac1
          read(1,*,end=101,err=101)frac2
          read(1,*,end=101,err=101)ecosw
          read(1,*,end=101,err=101)temprat
          read(1,*,end=101,err=101)idark1
          read(1,*,end=101,err=101)idark2
          read(1,*,end=101,err=101)isw12
          read(1,*,end=101,err=101)isw13
          read(1,*,end=101,err=101)isw21
          read(1,*,end=101,err=101)isw22
          read(1,*,end=101,err=101)isw23
          read(1,*,end=101,err=101)isw24
          read(1,*,end=101,err=101)(powercoeff(1,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(2,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(3,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(4,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(5,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(6,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(7,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(8,k),k=1,9)
          read(1,*,end=101,err=101)bigI
          read(1,*,end=101,err=101)bigbeta
          read(1,*,end=101,err=101)sw23
          read(1,*,end=101,err=101)sw24
          read(1,*,end=101,err=101)sw25
          read(1,*,end=101,err=101)sw26
          read(1,*,end=101,err=101)sw27
          read(1,*,end=101,err=101)sw28
          read(1,*,end=101,err=101)sw29
          read(1,*,end=101,err=101)sw30
          read(1,*,end=101,err=101)contam
          read(1,*,end=101,err=101)Tconj
          read(1,*,end=101,err=101)beam1
          read(1,*,end=101,err=101)beam2
          read(1,*,end=101,err=101)isw25
          read(1,*,end=101,err=101)isw26
          read(1,*,end=101,err=101)isw27
          read(1,*,end=101,err=101)isw28
          read(1,*,end=101,err=101)isw29
          read(1,*,end=101,err=101)isw30
          read(1,*,end=101,err=101)isw31
          read(1,*,end=101,err=101)isw32
          read(1,*,end=101,err=101)isw33
          read(1,*,end=101,err=101)isw34
          read(1,*,end=101,err=101)ocose
          read(1,*,end=101,err=101)osine
          read(1,*,end=101,err=101)omegadot
          read(1,*,end=101,err=101)contamS0
          read(1,*,end=101,err=101)contamS1
          read(1,*,end=101,err=101)contamS2
          read(1,*,end=101,err=101)contamS3
          read(1,*,end=101,err=101)sw47
          read(1,*,end=101,err=101)sw48
          read(1,*,end=101,err=101)sw49
c
          if(ios.eq.0)then 
            close(1)
            return
          endif
c
c   Come here if the input file ELC.???? does not exist.  
c
 100      if(ios.gt.0)then
            bell=char(7)
            write(*,1000)bell,kkk
            stop
          endif
 101      bell=char(7)               !file ended too soon         
          write(*,1002)bell,kkk
          close(1)
c
 1000     format(a1,'Error:  File ELC.???? does not exist for index ',
     @               i4)
 1002     format(a1,'Error:  Bad entry in ELC.???? for index ',i4)
c
          return
          end
c
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getgridbody3(kkk,Nalph3,Nbet3,tertperiod,tertt0,
     @      tertecos,tertesin,tertincl,tertOmega,tertQ,dwavex,dwavey,
     @      itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,
     @         P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
     @         P2ratrad,
     @         P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @         P3ratrad,
     @         P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,P4Omega,P4Q,
     @         P4ratrad,
     @         P5tconj,P5period,P5T0,P5ecos,P5esin,P5incl,P5Omega,P5Q,
     @         P5ratrad,
     @         P6tconj,P6period,P6T0,P6ecos,P6esin,P6incl,P6Omega,P6Q,
     @         P6ratrad,
     @         P7tconj,P7period,P7T0,P7ecos,P7esin,P7incl,P7Omega,P7Q,
     @         P7ratrad,
     @         P8tconj,P8period,P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,
     @         P8ratrad)
c                                                                                                                        
c
          implicit double precision(a-h,o-z)
c
          dimension dwavex(8,3),dwavey(8,3)
c
c   Declare the variable bell to be character*1
c
          character*1 bell
          character*4 extension
c
          if(kkk.gt.9999)then
            bell=char(7)
            write(*,305)bell
            stop
          endif
            
          if(kkk.lt.10)write(extension,301)kkk
          if((kkk.ge.10).and.(kkk.lt.100))write(extension,302)kkk
          if((kkk.ge.100).and.(kkk.lt.1000))write(extension,303)kkk
          if(kkk.ge.1000)write(extension,304)kkk
c
 301      format('100',i1)
 302      format('10',i2)
 303      format('1',i3)
 304      format(i4)
 305      format(a1,'ielete is too large')
c
          ios=0
          open(unit=1,file='ELCbody3.'//extension,status='old',err=100,
     @         iostat=ios)
c
          read(1,*,end=101,err=101)Nalph3
          read(1,*,end=101,err=101)Nbet3
          read(1,*,end=101,err=101)itconj
          read(1,*,end=101,err=101)it1
          read(1,*,end=101,err=101)it2
          read(1,*,end=101,err=101)it3
          read(1,*,end=101,err=101)it4
          read(1,*,end=101,err=101)tertconj
          read(1,*,end=101,err=101)tertperiod
          read(1,*,end=101,err=101)tertt0
          read(1,*,end=101,err=101)tertecos
          read(1,*,end=101,err=101)tertesin
          read(1,*,end=101,err=101)tertincl
          read(1,*,end=101,err=101)tertOmega
          read(1,*,end=101,err=101)tertQ
c
c  Load the limb darkening parameters. 
c         
          do 10 i=1,8
            read(1,*,end=101,err=101)dwavex(i,3),dwavey(i,3)
 10       continue
c
          read(1,*,end=101,err=101)tertratrad
          read(1,*,end=101,err=101)hh
          read(1,*,end=101,err=101)sw72
          read(1,*,end=101,err=101)sw73
          read(1,*)P2tconj
          read(1,*)P2period
          read(1,*)P2T0
          read(1,*)P2ecos
          read(1,*)P2esin
          read(1,*)P2incl
          read(1,*)P2Omega
          read(1,*)P2Q
          read(1,*)P2ratrad

          read(1,*)P3tconj
          read(1,*)P3period
          read(1,*)P3T0
          read(1,*)P3ecos
          read(1,*)P3esin
          read(1,*)P3incl
          read(1,*)P3Omega
          read(1,*)P3Q
          read(1,*)P3ratrad

          read(1,*)P4tconj
          read(1,*)P4period
          read(1,*)P4T0
          read(1,*)P4ecos
          read(1,*)P4esin
          read(1,*)P4incl
          read(1,*)P4Omega
          read(1,*)P4Q
          read(1,*)P4ratrad
c

          read(1,*)P5tconj
          read(1,*)P5period
          read(1,*)P5T0
          read(1,*)P5ecos
          read(1,*)P5esin
          read(1,*)P5incl
          read(1,*)P5Omega
          read(1,*)P5Q
          read(1,*)P5ratrad
c                                                                                                                        
          read(1,*)P6tconj
          read(1,*)P6period
          read(1,*)P6T0
          read(1,*)P6ecos
          read(1,*)P6esin
          read(1,*)P6incl
          read(1,*)P6Omega
          read(1,*)P6Q
          read(1,*)P6ratrad
c                                                                                                                        
          read(1,*)P7tconj
          read(1,*)P7period
          read(1,*)P7T0
          read(1,*)P7ecos
          read(1,*)P7esin
          read(1,*)P7incl
          read(1,*)P7Omega
          read(1,*)P7Q
          read(1,*)P7ratrad
c                                                                                                                        
          read(1,*)P8tconj
          read(1,*)P8period
          read(1,*)P8T0
          read(1,*)P8ecos
          read(1,*)P8esin
          read(1,*)P8incl
          read(1,*)P8Omega
          read(1,*)P8Q
          read(1,*)P8ratrad
          if(ios.eq.0)then 
            close(1)
            return
          endif

c
c   Come here if the input file ELCbody3.???? does not exist. 
c
 100      if(ios.gt.0)then
            bell=char(7)
            write(*,1000)bell,kkk
            stop
          endif
c
 101      bell=char(7)              !file ended too soon
          write(*,1002)bell,kkk
          close(1)

 1000     format(a1,'Error:  File ELCbody3.???? does not exist for ',
     $      'index ',i4)
 1002     format(a1,'Error:  Bad entry in ELCbody3.???? for index ',i4)
c
          return
          end
c
c!@$%&&&%%$$@@$$%%$$@@&&%$%&@@@@
c
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
          subroutine getfracstime(Nmaxphase,icount,fracs1,fracs2,fracs3,
     @       fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,sw26)
c
c   October 10, 2007
c
c   This is a new routine that will return the luminosity ratios in
c   each bandpass.  compfracs(i,1) will have L_2/L_1, and
c   compfracs(i,2) will have L_disk/L_tot.
c
          implicit double precision(a-h,o-z)
c
          dimension compfracs(8,3)
          dimension fracs1(Nmaxphase,4),fracs2(Nmaxphase,4)
          dimension fracs3(Nmaxphase,4),fracs4(Nmaxphase,4)
          dimension fracs5(Nmaxphase,4),fracs6(Nmaxphase,4)
          dimension fracs7(Nmaxphase,4),fracs8(Nmaxphase,4)
c
          parameter(kkk=720001)  !Nmaxphase
          dimension scratch1(kkk),scratch2(kkk),scratch3(kkk)
c
          NNN=icount
          aaa=1.0d0
          bbb=1.0d0
          ccc=1.0d0
          eee=1.0d0
          fred=0.5d0
          do 10 i=1,8     !loop over filters
c
            if(sw26.le.0.0d0)then
              do 8 jj=1,NNN
                if(i.eq.1)then
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
                endif
                if(i.eq.2)then
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
                endif
                if(i.eq.3)then
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
                endif
                if(i.eq.4)then
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
                endif
                if(i.eq.5)then
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
                endif
                if(i.eq.6)then
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
                endif
                if(i.eq.7)then
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
                endif
                if(i.eq.8)then
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
                endif
                ddd=aaa+bbb+ccc+eee
                if(aaa.eq.0.0d0)then
                  scratch1(jj)=0.0d0
                  scratch3(jj)=0.0d0
                else      
                  scratch1(jj)=bbb/aaa
                  scratch3(jj)=eee/aaa
                endif
                if(ddd.eq.0.0d0)then
                  scratch2(jj)=0.0d0
                else      
                  scratch2(jj)=ccc/ddd
                endif
8             continue
c  
              if(icount.le.2)then
                compfracs(i,1)=0.0d0
                compfracs(i,2)=0.0d0
                compfracs(i,3)=0.0d0
                go to 10
              endif

              if(NNN.gt.1)call sort3(NNN,scratch1,scratch2,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                rmedian1=(scratch1(NNN/2)+scratch1(NNN/2+1))/2.0
              else
                rmedian1=scratch1(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch2,scratch1,scratch3)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian2=(scratch2(NNN/2)+scratch2(NNN/2+1))/2.0
              else
                rmedian2=scratch2(NNN/2+1)
              endif
c
              if(NNN.gt.1)call sort3(NNN,scratch3,scratch1,scratch2)
c
              q1=dble(NNN/2)
              q2=dble(NNN)/2.0
              if(q1.eq.q2)then
                 rmedian3=(scratch3(NNN/2)+scratch3(NNN/2+1))/2.0
              else
                rmedian3=scratch3(NNN/2+1)
              endif
c
              if(rmedian1.lt.0.0d0)rmedian1=0.0d0
              if(rmedian2.lt.0.0d0)rmedian2=0.0d0
              if(rmedian3.lt.0.0d0)rmedian3=0.0d0

              compfracs(i,1)=rmedian1
              compfracs(i,2)=rmedian2
              compfracs(i,3)=rmedian3
            else
              diffmin=123456789.0d0
              do 9 jj=1,NNN
                if(fred.lt.0.0d0)fred=fred+1.0d0
                if(fred.gt.1.0d0)fred=fred-1.0d0
                diff=dabs(fred-sw26)
                if(diff.le.diffmin)then
                  diffmin=diff

                 if(i.eq.1)then
                   aaa=fracs1(jj,1)
                   bbb=fracs1(jj,2)
                   ccc=fracs1(jj,3)
                   eee=fracs1(jj,4)
                 endif
                 if(i.eq.2)then
                   aaa=fracs2(jj,1)
                   bbb=fracs2(jj,2)
                   ccc=fracs2(jj,3)
                   eee=fracs2(jj,4)
                 endif
                 if(i.eq.3)then
                   aaa=fracs3(jj,1)
                   bbb=fracs3(jj,2)
                   ccc=fracs3(jj,3)
                   eee=fracs3(jj,4)
                 endif
                 if(i.eq.4)then
                   aaa=fracs4(jj,1)
                   bbb=fracs4(jj,2)
                   ccc=fracs4(jj,3)
                   eee=fracs4(jj,4)
                 endif
                 if(i.eq.5)then
                   aaa=fracs5(jj,1)
                   bbb=fracs5(jj,2)
                   ccc=fracs5(jj,3)
                   eee=fracs5(jj,4)
                 endif
                 if(i.eq.6)then
                   aaa=fracs6(jj,1)
                   bbb=fracs6(jj,2)
                   ccc=fracs6(jj,3)
                   eee=fracs6(jj,4)
                 endif
                 if(i.eq.7)then
                   aaa=fracs7(jj,1)
                   bbb=fracs7(jj,2)
                   ccc=fracs7(jj,3)
                   eee=fracs7(jj,4)
                 endif
                 if(i.eq.8)then
                   aaa=fracs8(jj,1)
                   bbb=fracs8(jj,2)
                   ccc=fracs8(jj,3)
                   eee=fracs8(jj,4)
                 endif
c
                  ddd=aaa+bbb+ccc+eee
                  compfracs(i,1)=bbb/aaa
                  if(ddd.eq.0.0d0)then
                    compfracs(i,2)=0.0d0
                  else
                    compfracs(i,2)=ccc/ddd
                  endif  
                  if(aaa.eq.0.0d0)then
                    compfracs(i,3)=0.0d0
                  else
                    compfracs(i,3)=eee/aaa
                  endif  
                endif
9             continue
            endif
c
10        continue
c
          return
          end
c 
c
c
c
c  @#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!@#$%&!
c
          subroutine fakeanalyticg(isw12,ilaw,dwavex,dwavey,delta,reff1,
     @      ratrad,refflux1,refflux2,phaser,pconj,pconj2,gimvel,fincr,
     @      vrot,omega,period,separ,Q,ecc,bigI,bigbeta,Neclipse,istar,
     @      corr1,corr2,MM,sobrad,sobtheta,rmu)
c
c   December 29, 2012
c
c   Will compute a fast monte carlo transit, using a Sobel sequence
c 
          implicit double precision(a-h,o-z)
c 
          dimension dwavex(8,3),dwavey(8,3),refflux1(8),refflux2(8)
          dimension corr1(8),corr2(8),cx1(10000)
          dimension cx2(10000),c(10),alpha(10),cv1(10000),cv2(10000)
          dimension gimvel(8),alfone(10)
          dimension xsob(2),sobrad(MM),sobtheta(MM),rmu(MM)
c
          parameter(pie=3.14159265359879323d0)
c
          rstar=1.0d0
          rplanet=1.0d0
          Neclipse=99
          solarrad=6.9598d8
          fact=solarrad*2.0d0*pie/86400.0d0/1.0d3  !50.613093d0
          a2=(separ/(1.0d0+Q))
c          a1=separ-a2
          efact=1.0d0/dsqrt(1.0-ecc*ecc)
          sifinc=dsin(fincr)
          velK2=fact*a2/period*sifinc*efact
c
c   add rotational velocity corrections
c           
          sI=dsin(bigI*pie/180.0d0)
          sB=dsin(bigbeta*pie/180.0d0)
          cB=dcos(bigbeta*pie/180.0d0)
          vstar=-vrot*sI*(sB*dcos(fincr)*dcos(phaser)-cB*dsin(phaser))
     @        *omega
c
c   Do the case for linear first (ilaw=1)
c
          alpha(1)=0.0d0
          alpha(2)=0.0d0
          alpha(3)=0.0d0
          if(istar.eq.1)then
            rstar=reff1
            rplanet=rstar/ratrad
          endif
          if(istar.eq.2)then
            rplanet=reff1
            rstar=rplanet/ratrad
            rstar=reff1
            rplanet=rstar/ratrad
          endif
          bee=rplanet/(rstar+rplanet)
          cee=delta/(rplanet+rstar)
          if(delta.gt.(rstar+rplanet))then
            do 99 i=1,8
c              refflux2(i)=0.0d0
              corr1(i)=0.0d0
              corr2(i)=0.0d0
              gimvel(i)=0.0d0
99          continue
            Neclipse=0
            return
          endif

c   October 17, 2010
c
c   Update to make sure the nearest conjunction phase is found
c
          tt1=dabs(phaser-2.0d0*pie*pconj)
          tt2=dabs(phaser-2.0d0*pie*(pconj+1.0d0))
          tt3=dabs(phaser-2.0d0*pie*(pconj-1.0d0))
c
          small=123456789.0d0
          if(tt1.le.small)small=tt1
          if(tt2.le.small)small=tt2
          if(tt3.le.small)small=tt3
          diff1=small
c
c          tt1=dabs(phaser-2.0d0*pie*pconj)
c          tt2=dabs(phaser-2.0d0*pie*(pconj+1.0d0))
c          if(tt1.le.tt2)then
c            diff1=tt1
c          else
c            diff1=tt2
c          endif

          tt1=dabs(phaser-2.0d0*pie*pconj2)
          tt2=dabs(phaser-2.0d0*pie*(pconj2+1.0d0))
          tt3=dabs(phaser-2.0d0*pie*(pconj2-1.0d0))
c
          small=123456789.0d0
          if(tt1.le.small)small=tt1
          if(tt2.le.small)small=tt2
          if(tt3.le.small)small=tt3
          diff2=small

c          if(tt1.le.tt2)then
c            diff2=tt1
c          else
c            diff2=tt2
c          endif              

          if(istar.eq.1)then
            if(diff1.lt.diff2)then
              do 999 i=1,8
                corr1(i)=0.0d0   !was refflux2
                gimvel(i)=0.0d0
999            continue
              return
            endif
          endif

          if(istar.eq.2)then
            if(diff2.lt.diff1)then
              do 9999 i=1,8
c                refflux2(i)=0.0d0    !was commented out
                corr2(i)=0.0d0    
                gimvel(i)=0.0d0
9999           continue
              return
            endif
          endif
c
c  UPDATE September 4, 2012
c
c  If ilaw=11, this is linear with the coefficients for star 2
c  forced to be equal for those of star 1
c
c

          if((ilaw.eq.1).or.(ilaw.eq.11))then
c
            do 2 n=0,1
              rnu=dble(n+2)*0.5d0
c
              pee=rnu+2.0d0
              cue=rnu+1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
c
              call jacobi_poly(isw12,beta,alf,xx,cx1)
              cue=1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-2.0d0*cee*cee
c
              call jacobi_poly(isw12,beta,alf,xx,cx2)
c
              pee=rnu+3.0d0
              cue=2.0d0
              alf=pee-cue
              beta1=cue-1.0d0
              xx=1.0d0-(2.0d0*(cee*cee))
              call jacobi_poly(isw12,beta1,alf,xx,cv2)

              pee=rnu+3.0d0
              cue=rnu+2.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
              call jacobi_poly(isw12,beta,alf,xx,cv1)

              t1=bee*bee*((1.0d0-cee*cee)**(rnu+1.0d0))
     &             /(rnu*dexp(gamma_log(rnu+1.0d0)))
c
              v1=dexp(gamma_log(rnu)-2.0d0*gamma_log(rnu+2.0d0))
c              v1=dexp(rnp-2.0d0*gamma_log(rnu+2.0d0))
              v1=v1*cee*bee*bee*(1.0d0-bee)*(1.0d0-cee*cee)**(rnu+1.0d0)

              summ=0.0d0
              summv=0.0d0
              do 3 j=0,1  !isw12
                dj=dble(j)

                t3=(gamma_log(dj+1.0d0)+gamma_log(rnu+1.0d0)-
     %              gamma_log(dj+rnu+1.0d0))
                t3=exp(t3)

                t2=dexp(gamma_log(rnu+dble(j+1))-gamma_log(dble(j+2)))
                summ=summ+(-1.0d0)**j*(2.0d0*dble(j)+rnu+2.0d0)*t2*
     @              cx1(j+1)**2*cx2(j+1)*t3*t3
c
                v3=dexp(gamma_log(rnu+dj+3.0d0)-gamma_log(dj+1.0d0))
                v4=dexp(gamma_log(dj+1.0d0)+gamma_log(beta+1.0d0)-
     @              gamma_log(dj+1.0d0+beta))
                v5=dexp(gamma_log(dj+1.0d0)+gamma_log(beta1+1.0d0)-
     @              gamma_log(dj+1.0d0+beta1))

                v4=v4*v4*v5

                summv=summv+
     $             v3*v4*cv1(j+1)*cv1(j+1)*cv2(j+1)*
     @             (-1.0d0)**j*(2.0d0*dj+rnu+3.0d0)
c

 3            continue
              alpha(n+1)=t1*summ
              alfone(n+1)=v1*summv
 2          continue
c
            do 1 i=1,8
c
              you1=dwavex(i,istar)   
              if((ilaw.eq.11).and.(istar.eq.2))you1=dwavex(i,1)
              c(1)=(1.0d0-you1)/(1.0d0-you1/3.0D0)
              c(2)=you1/(1.0d0-you1/3.0D0)      
              atot=alpha(1)*c(1)+alpha(2)*c(2)
c
            fakesumm=0.0d0
c            MM=800000
            rdint=pie*(1.0d0-you1/3.0d0)
            do jkk=1,MM
c              call sobseq(nnn,xsob)
              rrad=sobrad(jkk)
              theta=sobtheta(jkk)! *2.0d0*pie
              xx=rrad*dcos(theta)
              yy=rrad*dsin(theta)
              dist=dsqrt((xx-delta/rstar)**2+yy**2)
              if(dist.lt.rplanet/rstar)then
                t1=0.0d0
              else
c                rmu=dsqrt(1.0d0-rrad*rrad)
                dark=1.0d0-you1*(1.0d0-rmu(jkk))
                t1=dark*rrad
              endif
              fakesumm=fakesumm+t1
            enddo
            fakesumm=1.0d0-2.0d0*pie*fakesumm/dble(MM)/rdint
c
c              if(istar.eq.1)write(*,*)fakesumm,atot,ratrad
              if(istar.eq.1)corr1(i)=-refflux1(i)*fakesumm! (atot)
              if(istar.eq.2)corr2(i)=-refflux2(i)*fakesumm! (atot)
c
              vtot=alfone(1)*c(1)+alfone(2)*c(2)
              if(delta.ne.0.0d0)then
c                delvel=vstar/delta*(vtot/(1.0d0-atot))
                delvel=vstar/delta*(vtot/(1.0d0-fakesumm))
              else
                delvel=0.0d0
              endif
              if(velK2.ne.0.0d0)then
                gimvel(i)=delvel/velK2
              else
                gimvel(i)=0.0d0
              endif
1           continue
          endif  ! end if ilaw=1
c
c  UPDATE September 4, 2012
c
c  If ilaw=14, quad law with coefficients of star 2 forced to be
c  equal to the coefficients of star 1.
c
          if((ilaw.eq.4).or.(ilaw.eq.14))then   !quadratic
c
            do 200 n=0,2
              rnu=dble(n+2)*0.5d0
c
              pee=rnu+2.0d0
              cue=rnu+1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
              call jacobi_poly(isw12,beta,alf,xx,cx1)
              cue=1.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-2.0d0*cee*cee
              call jacobi_poly(isw12,beta,alf,xx,cx2)
              t1=bee*bee*((1.0d0-cee*cee)**(rnu+1.0d0))
     &             /(rnu*dexp(gamma_log(rnu+1.0d0)))
c
              pee=rnu+3.0d0
              cue=2.0d0
              alf=pee-cue
              beta1=cue-1.0d0
              xx=1.0d0-(2.0d0*(cee*cee))
              call jacobi_poly(isw12,beta1,alf,xx,cv2)

              pee=rnu+3.0d0
              cue=rnu+2.0d0
              alf=pee-cue
              beta=cue-1.0d0
              xx=1.0d0-(2.0d0*(1.0d0-bee))
              call jacobi_poly(isw12,beta,alf,xx,cv1)
c
c
              rnp=gamma_log(rnu)
              v1=dexp(rnp-2.0d0*gamma_log(rnu+2.0d0))
              v1=v1*cee*bee*bee*(1.0d0-bee)*(1.0d0-cee*cee)**(rnu+1.0d0)

              summ=0.0d0
              summv=0.0d0
              summ=0.0d0
              do 300 j=0,isw12
                dj=dble(j)

c                  t3=(gamma_log(dj+1.0d0)+gamma_log(dj+rnu+2.0d0)-
c     %              gamma_log(2.0d0*dj+rnu+2.0d0))
c                  t3=exp(3.0d0*t3)

                t3=(gamma_log(dj+1.0d0)+gamma_log(rnu+1.0d0)-
     %              gamma_log(dj+rnu+1.0d0))
                t3=exp(t3)

                t2=dexp(gamma_log(rnu+dble(j+1))-gamma_log(dble(j+2)))
                summ=summ+(-1.0d0)**j*(2.0d0*dble(j)+rnu+2.0d0)*t2*
     @              cx1(j+1)**2*cx2(j+1)*t3*t3
c
                v3=dexp(gamma_log(rnu+dj+3.0d0)-gamma_log(dj+1.0d0))
                v4=dexp(gamma_log(dj+1.0d0)+gamma_log(beta+1.0d0)-
     @              gamma_log(dj+1.0d0+beta))
                v5=dexp(gamma_log(dj+1.0d0)+gamma_log(beta1+1.0d0)-
     @              gamma_log(dj+1.0d0+beta1))

                v4=v4*v4*v5

                summv=summv+
     $             v3*v4*cv1(j+1)*cv1(j+1)*cv2(j+1)*
     @             (-1.0d0)**j*(2.0d0*dj+rnu+3.0d0)
c
300           continue
              alpha(n+1)=t1*summ
              alfone(n+1)=v1*summv
200         continue
c
            do 100 i=1,8
              you1=dwavex(i,istar)+2.0d0*dwavey(i,istar)
              you2=-1.0d0*dwavey(i,istar)
              if((ilaw.eq.14).and.(istar.eq.2))then
                you1=dwavex(i,1)+2.0d0*dwavey(i,1)
                you2=-1.0d0*dwavey(i,1)
              endif    
              c(1)=(1.0d0-you1-you2)/(1.0d0-you1/3.0d0-you2/2.0d0)
              c(2)=you1/(1.0d0-you1/3.0d0-you2/2.0d0)      
              c(3)=you2/(1.0d0-you1/3.0d0-you2/2.0d0)      
              atot=alpha(1)*c(1)+alpha(2)*c(2)+alpha(3)*c(3)

c              refflux2(i)=-refflux1(i)*(atot)
            fakesumm=0.0d0
c            MM=200000
            x=dwavex(i,istar)
            y=dwavey(i,istar)
            rdint=pie*(1.0d0-x/3.0d0-y/6.0d0)
            do jkk=1,MM
c              call sobseq(nnn,xsob)
              rrad=sobrad(jkk)
              theta=sobtheta(jkk)!*2.0d0*pie
              xx=rrad*dcos(theta)
              yy=rrad*dsin(theta)
              dist=dsqrt((xx-delta/rstar)**2+yy**2)
              if(dist.lt.rplanet/rstar)then
                t1=0.0d0
              else
c                rmu=dsqrt(1.0d0-rrad*rrad)
                dark=1.0d0-x*(1.0d0-rmu(jkk))-y*(1.0d0-rmu(jkk))**2
                t1=dark*rrad
              endif
              fakesumm=fakesumm+t1
            enddo
            fakesumm=1.0d0-2.0d0*pie*fakesumm/dble(MM)/rdint
 
c            write(*,*)fakesumm,atot
              if(istar.eq.1)corr1(i)=-refflux1(i)*fakesumm!(atot)
              if(istar.eq.2)corr2(i)=-refflux2(i)*fakesumm!(atot)
c
              vtot=alfone(1)*c(1)+alfone(2)*c(2)+alfone(3)*c(3)
              if(delta.ne.0.0d0)then
                delvel=vstar/delta*(vtot/(1.0d0-atot))
              else
                delvel=0.0d0
              endif
              if(velK2.ne.0.0d0)then
                gimvel(i)=delvel/velK2
              else
                gimvel(i)=0.0d0
              endif
              if(istar.eq.2)gimvel(i)=-gimvel(i)
100           continue
          endif  ! end if ilaw=4
c
          return
          end
c
c  *************************************************************************
c
          subroutine getvisib3(istar,ialphmax,ibetmax,Nalf,ibetlim,
     %      phase,finc,Q,psi0,omega,gradx,grady,gradz,xarray,yarray,
     @      zarray,visib,Nhoriz1,xhoriz1,yhoriz1,Nhoriz2,
     @      xhoriz2,yhoriz2,Ncoords,xcoords,ycoords,
     @      projarray,iecheck,Neclipse,phiar,radarray,delphi,
     @      mmdx,MonteCarlo,phistart,thetamis,phimis,
     @      i3flag,iedgehor,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega)
c
c   January 2, 2013
c
c   This routine will find the visibilities of the third star, if
c   present
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          parameter(twopie=2.0d0*pie)
          dimension visib(ialphmax*ibetmax),xcoords(ialphmax*ibetmax*4),
     $        gradx(ialphmax*ibetmax),grady(ialphmax*ibetmax),
     $        gradz(ialphmax*ibetmax),ycoords(ialphmax*ibetmax*4),
     $        xhoriz1(Nhoriz1),yhoriz1(Nhoriz1),
     @        xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     @        zarray(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     @        xhoriz2(Nhoriz2),yhoriz2(Nhoriz2),
     @        ibetlim(ialphmax),phiar(ialphmax*ibetmax),
     @        ihid(200000), radarray(ialphmax*ibetmax),
     @        delphi(ialphmax*ibetmax),
     @        mmdx(ialphmax,ibetmax)
          dimension phistart(ialphmax),iedgehor(ialphmax*ibetmax)
c
c   Use the sub-random Sobel sequence instead of ran9.  xsob is needed
c   for this.
c
          dimension xsob(2)
c
c   Initialize some variables here
c
          proj=0.0d0
          theta=0.0d0
          ibet=1
c
c    There is a third body, so offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
          yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @      axisscale)
          tOmrad=TertOmega*pie/180.0d0
          xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
          yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
c
          FINCR = (finc/180.0d0)*pie       !orbital inclination in radians
          xp1=xtran(0.0d0,0.0d0,0.0d0,phase,fincr,Q,1,bdist)+xxoff 
          yp1=ytran(0.0d0,0.0d0,0.0d0,phase,fincr,Q,1,bdist)+yyoff
c
          xp=tertxtrans(0.0d0,0.0d0,0.0d0,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)
          yp=tertytrans(0.0d0,0.0d0,0.0d0,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)
          dist=dsqrt((xp-xp1)**2+(yp-yp1)**2)
c
c
c  initialize the visibities!
c
          do 1 i=1,nalf
            do 2 j=1,ibetlim(i)  !4*nbet
c              iidx=(i-1)*ibetlim(i)+j
              iidx=mmdx(i,j)
              visib(iidx)=0.0d0
              projarray(iidx)=-1.0d0
              ihid(iidx)=-1
              delphi(iidx)=-999.9d0
 2          continue
 1        continue
c
          PHASER = (tertphase/180.0d0)*pie     !orbital phase in radians
          FINCR = (tertincl/180.0d0)*pie       !orbital inclination in radians
c          
          AZ = DCOS(FINCR)
          IF (AZ.LT.0.0d0) AZ = 0.0d0
          AX = -DSIN(FINCR)*DCOS(PHASER)    ! l in Wilson & Sofia
          AY = DSIN(FINCR)*DSIN(PHASER)     ! m in Wilson & Sofia
c
c   find the projection factors.
c
          Ncoords=0
          Neclipse=0
          iimin=123456
          iimax=-12345
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)      !4*Nbet
              iidx=mmdx(ialf,ibet)
              PROJ = AX * GRADX(iidx) + AY*GRADY(iidx) + 
     @           AZ*GRADZ(iidx)
              projarray(iidx)=proj
              visib(iidx)=proj
              IF (PROJ.LT.0.) GO TO 502    ! is the surface element visible?
              xx=xarray(iidx)
              yy=yarray(iidx)
              zz=zarray(iidx)
              xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)
              yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @         tertbdist,axisscale,TertOmega)

c          FINCR = (tertincl/180.0d0)*pie       !orbital inclination in radians
c          bdist=tertbdist*axisscale
c              xp=xtran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist) 
c              yp=ytran(xx,yy,zz,tertphase,fincr,tertQ,1,bdist)
c          xc=xp*dcos(tOmrad)-yp*dsin(tOmrad)
c          yc=xp*dsin(tOmrad)+yp*dcos(tOmrad)
cc              xc=0.0d0
cc              yc=0.0d0
c              xp=xc
c              yp=yc
c
c  if I3flag=0, then the third body is behind  the binary.  Check
c  for eclipses
c
              if(i3flag.lt.1)then
                iyes1=-100
                call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes1,
     @              icut)
                if(iyes1.eq.100)then
                    Neclipse=Neclipse+1
                    visib(iidx)=0.0d0
                    ihid(iidx)=1
                  go to 502   
                endif
              endif
c
c   Check to see of the point in question is eclipsed by the other star.
c
              if(i3flag.lt.1)then 
                iyes2=-100
                call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes2,
     @               icut)
                if(iyes2.eq.100)then
                    ihid(iidx)=2     !eclipsed by secondary
                    Neclipse=Neclipse+1
                    visib(iidx)=0.0d0
                  go to 502   
                endif
              endif
              Ncoords=Ncoords+1    
              xcoords(Ncoords)=xp
              ycoords(Ncoords)=yp
c
502         CONTINUE
501       continue         ! continue the alpha loop
c
c
c   Now we have to go along the beta direction and find out which visible
c   point is nearest to the eclipsing horizon.
c
          do 602 ialf=1,Nalf 
            do 601 ibet=1,ibetlim(ialf)      !4*Nbet
              iidx=mmdx(ialf,ibet)
              if(projarray(iidx).le.0.0d0)go to 601
              if(ibet.lt.ibetlim(ialf))then
                index=ibet+1
              else
                index=1
              endif
c
              izz=ialf
              jzz=index
              jjdx=mmdx(izz,jzz)
              if(projarray(jjdx).le.0.0d0)go to 601
              izz=ialf
              jzz=ibet
              iidx=mmdx(izz,jzz)
              ksign=ihid(iidx)*ihid(jjdx)
c
              if(ksign.eq.-1)then  ! crossed through the horizon
                if(ihid(iidx).eq.-1)then
                  izz=ialf
                  jzz=ibet
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgehor(iidx)=10
c
                  izz=ialf
                  jzz=index
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgehor(iidx)=-10
                  index=ibet
                else
                  izz=ialf
                  jzz=index
                  iidx=mmdx(izz,jzz)
                  xvis=xarray(iidx)
                  yvis=yarray(iidx)
                  zvis=zarray(iidx)
                  rvis=radarray(iidx)
                  phivis=phiar(iidx)
                  iedgehor(iidx)=20
c
                  izz=ialf
                  jzz=ibet
                  iidx=mmdx(izz,jzz)
                  xhid=xarray(iidx)
                  yhid=yarray(iidx)
                  zhid=zarray(iidx)
                  rhid=radarray(iidx)
                  phihid=phiar(iidx)
                  iedgehor(iidx)=-10
                endif                
c
c                xpv=xtran(xvis,yvis,zvis,phase,fincr,Q,istar,bdist)  
c                ypv=ytran(xvis,yvis,zvis,phase,fincr,Q,istar,bdist)  
c                xpv=xpv+xxoff-xc
c                ypv=ypv+yyoff-yc
                xpv=tertxtrans(xvis,yvis,zvis,tertphase,tertincl,tertQ,
     @            tertbdist,axisscale,TertOmega)
                ypv=tertytrans(xvis,yvis,zvis,tertphase,tertincl,tertQ,
     @            tertbdist,axisscale,TertOmega)
c  
c                xph=xtran(xhid,yhid,zhid,phase,fincr,Q,istar,bdist)  
c                yph=ytran(xhid,yhid,zhid,phase,fincr,Q,istar,bdist)    
c                xph=xph+xxoff-xc
c                yph=yph+yyoff-yc
c
                xph=tertxtrans(xhid,yhid,zhid,tertphase,tertincl,tertQ,
     @            tertbdist,axisscale,TertOmega)
                yph=tertytrans(xhid,yhid,zhid,tertphase,tertincl,tertQ,
     @            tertbdist,axisscale,TertOmega)

                psi=1.d3
                overQ=1.0d0/30.0d0
                if(MonteCarlo.lt.10)then
                  if(ksign.eq.-1)call accphi(overQ,psi,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Nhoriz1,xhoriz1,yhoriz1,phiacc,bdist,
     @               tidephi,itide,ecc,thetamis,phimis,tertincl,
     @               tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @               tertOmega)
c
                  if(ksign.eq.-2)call accphi(overQ,psi,omega,phase,fincr,
     @               istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,
     @               rhid,phihid,Nhoriz2,xhoriz2,yhoriz2,phiacc,bdist,
     @               tidephi,itide,ecc,thetamis,phimis,tertincl,
     @               tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @               tertOmega)
c
                  iidx=mmdx(ialf,index)
                  diff=(phiar(iidx)-phiacc)
c
                  if(dabs(diff).lt.2.0d0)then
                    delphi(iidx)=(phiar(iidx)-phiacc)
                  endif
                  if(dabs(diff).ge.2.0d0)then
                    if(phiar(iidx).gt.4.0d0)then
                      phitemp=2.0d0*pie-phiar(iidx)
                      delphi(iidx)=(phitemp+phiacc)
                    endif
                    if(phiacc.gt.4.0d0)then
                      phitemp=2.0d0*pie-phiacc
                      delphi(iidx)=(phitemp+phiar(iidx))
                    endif
                  endif
                endif      !    if MonteCarlo < 10
              endif
c
601        continue
602      continue
c

c   UPDATE JULY 4, 2004
c
c   if -10 < MonteCarlo < 10, then we are done.
c
         if((MonteCarlo.lt.10).and.(MonteCarlo.gt.-10))return

c   UPDATE JULY 1, 2004
c
c   Add a loop which will use Monte Carlo integration to
c   determine what fraction of a pixel is partially eclipsed
c   by the horizon of the star in front.  The variable MonteCarlo
c   sets the number of integrations.
c
          dtheta=pie/dble(Nalf)
          overQ=Q
          if(istar.eq.2)overQ=1.0d0/Q
c
          iimin=iimin-1
          if(MonteCarlo.gt.10)then
            if(iimin.lt.1)iimin=1
          endif
          iimax=iimax+1
          if(MonteCarlo.gt.10)then
            if(iimax.gt.Nalf)iimax=Nalf
          endif
c
          do 702 ialf=1,Nalf
            r=0.0000001d0
            theta=-0.5d0*dtheta+dtheta*dble(ialf)
            do 701 ibet=1,ibetlim(ialf)      !4*Nbet
              iidx=mmdx(ialf,ibet)
c
              if(projarray(iidx).lt.0.0d0)go to 7701
c
c   UPDATE July 14, 2004
c
c   We have two options here.  If MonteCarlo > 10, then check
c   all pixels near the eclipsing horizon and get fractional
c   areas.  If MonteCarlo < -10, then check only the latitude row just
c   above the eclipsing horizon and the latitude row just below the
c   eclipsing horizon.
c
              if(MonteCarlo.gt.10)then
                if((iedgehor(iidx).eq.-10).or.(iedgehor(iidx).gt.5)
     %            .or.(ialf.eq.iimin).or.(ialf.eq.iimax)
     %            .or.(ialf.eq.iimin+1).or.(ialf.eq.iimax-1))then
                  dphi=twopie/dble(ibetlim(ialf))
                  phi=-0.5d0*dphi+dphi*dble(ibet)
                  phi=phi+phistart(ialf)
c
c   This loop will find random theta,phi locations on the pixel in
c   question, compute x,y,z coordinates on the star, and determine
c   if that location is eclipsed.  It will then determine the fraction
c   of the pixel that is eclipsed.
c
                  Nloop=MonteCarlo
                  NNhid=0
c
c   Do a check of the pixel corners and edges to see if they are eclipsed.
c   If all corners and all edges are eclipsed, then assume that the pixel
c   is completely hidden.  Likewise, if none of the corners or edges
c   are eclipsed, assume the pixel is completely visible
c
                  do 901 kk=-3,3
                    do 900 ll=-3,3
                      phinew=(dble(ll)/6.0d0)*dphi+phi
                      thetanew=(dble(kk)/6.0d0)*dtheta+theta          
                      snth=dsin(thetanew)
                      cnth=dcos(thetanew)
                      cox=dcos(phinew)*snth                !*dsin(theta)
                      coy=dsin(phinew)*snth                !*dsin(theta)
                      coz=cnth                          !dcos(theta)
                      CALL RAD(overQ,omega,cox,coy,coz,psi,r,xx,yy,zz,1,
     $                 bdist,tidephi,itide,ecc,thetamis,phimis)
                      call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,
     @                   cox,coy,tidephi,itide,ecc,thetamis,phimis)

c                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
c                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c                      xp=xp+xxoff
c                      yp=yp+yyoff
                      xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                    tertbdist,axisscale,TertOmega)
                      yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                    tertbdist,axisscale,TertOmega)

                      iyes=-1000
                      if(i3flag.lt.1)then
                        call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,
     &                     iyes,icut)
                        call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,
     &                     iyes,icut)
                      endif
c
                      if(iyes.eq.100)then
                        NNhid=NNhid+1
                      endif
 900                continue
 901              continue
c
                  if(NNhid.eq.0)go to 801   ! completely visible
                  if(NNhid.eq.49)then
                    NNhid=Nloop
                    go to 801        ! completely hidden
                  endif
                  NNhid=0
c
c   UPDATE July 7, 2004
c
c   Use the Sobel sequence instead of ran9.
c
                  nnn=2
                  do 800 jj=1,Nloop
c  
c                    phinew=(ran9(jdum)-0.5d0)*dphi+phi
c                    thetanew=(ran9(jdum)-0.5d0)*dtheta+theta          
c  
                    call sobseq(nnn,xsob)
                    phinew=(xsob(1)-0.5d0)*dphi+phi
                    thetanew=(xsob(2)-0.5d0)*dtheta+theta          
c  
                    snth=dsin(thetanew)
c                    snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                    cnth=dcos(thetanew)
                    cox=dcos(phinew)*snth                !*dsin(theta)
                    coy=dsin(phinew)*snth                !*dsin(theta)
                    coz=cnth                          !dcos(theta)
                    CALL RAD(overQ,omega,cox,coy,coz,psi,r,xx,yy,zz,1,
     $                bdist,tidephi,itide,ecc,thetamis,phimis)
                    call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,
     @                   tidephi,itide,ecc,thetamis,phimis)
c
c                    xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
c                    yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c                    xp=xp+xxoff
c                    yp=yp+yyoff
c
                    xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                tertbdist,axisscale,TertOmega)
                    yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                tertbdist,axisscale,TertOmega)
c
                    iyes=-1000
                    if(i3flag.lt.1)then
                      call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,
     @                   icut)
                      call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,
     @                  icut)
                    endif
                    if(iyes.eq.100)then
                      NNhid=NNhid+1
                    endif
 800              continue
 801              nvis=Nloop-NNhid
                  visib(iidx)=projarray(iidx)*(dble(nvis)/dble(Nloop))
                endif
              endif  ! end if MonteCarlo > 10
c
c  Check only the latitude row just above and just below.
c
              if(MonteCarlo.lt.-10)then
                if((ialf.eq.iimin).or.(ialf.eq.iimax))then
                  dphi=twopie/dble(ibetlim(ialf))
                  phi=-0.5d0*dphi+dphi*dble(ibet)
                  phi=phi+phistart(ialf)
c
c   This loop will find random theta,phi locations on the pixel in
c   question, compute x,y,z coordinates on the star, and determine
c   if that location is eclipsed.  It will then determine the fraction
c   of the pixel that is eclipsed.
c
                  Nloop=(abs(MonteCarlo))
                  NNhid=0
c
c   Do a check of the pixel corners and edges to see if they are eclipsed.
c   If all corners and all edges are eclipsed, then assume that the pixel
c   is completely hidden.  Likewise, if none of the corners or edges
c   are eclipsed, assume the pixel is completely visible
c
                  do 5901 kk=-3,3
                    do 5900 ll=-3,3
                      phinew=(dble(ll)/6.0d0)*dphi+phi
                      thetanew=(dble(kk)/6.0d0)*dtheta+theta          
                      snth=dsin(thetanew)
c                      snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                      cnth=dcos(thetanew)
                      cox=dcos(phinew)*snth                !*dsin(theta)
                      coy=dsin(phinew)*snth                !*dsin(theta)
                      coz=cnth                          !dcos(theta)
                      CALL RAD(overQ,omega,cox,coy,coz,psi,r,xx,yy,zz,1,
     $                   bdist,tidephi,itide,ecc,thetamis,phimis)
                      call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,tidephi,
     &                   itide,ecc,thetamis,phimis)

c                      xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
c                      yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c                      xp=xp+xxoff
c                      yp=yp+yyoff
c
                      xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                  tertbdist,axisscale,TertOmega)
                      yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                  tertbdist,axisscale,TertOmega)

                      iyes=-1000
                      if(i3flag.ge.1)then
                        call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,
     @                    iyes,icut)
                        call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,
     @                    iyes,icut)
                      endif
                      if(iyes.eq.100)then
                        NNhid=NNhid+1
                      endif
 5900               continue
 5901             continue
c
                  if(NNhid.eq.0)go to 5801   ! completely visible
                  if(NNhid.eq.49)then
                    NNhid=Nloop
                    go to 5801        ! completely hidden
                  endif
                  NNhid=0
c
c   UPDATE July 7, 2004
c
c   Use the Sobel sequence instead of ran9.
c
                  nnn=2
                  do 5800 jj=1,Nloop
c
                    call sobseq(nnn,xsob)
                    phinew=(xsob(1)-0.5d0)*dphi+phi
                    thetanew=(xsob(2)-0.5d0)*dtheta+theta          
c  
                    snth=dsin(thetanew)
c                    snth3=dsin(thetanew)/3.0d0  !*0.333333333333333d0
                    cnth=dcos(thetanew)
                    cox=dcos(phinew)*snth                !*dsin(theta)
                    coy=dsin(phinew)*snth                !*dsin(theta)
                    coz=cnth                          !dcos(theta)
                    CALL RAD(overQ,omega,cox,coy,coz,psi,r,xx,yy,zz,1,
     $               bdist,tidephi,itide,ecc,thetamis,phimis)
                    call POTEN(overQ,omega,xx,yy,zz,psi,
     $                   psix,psixx,psiy,psiz,1,bdist,cox,coy,
     &                   tidephi,itide,ecc,thetamis,phimis)

c                    xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist) 
c                    yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c                    xp=xp+xxoff
c                    yp=yp+yyoff
c
                    xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                 tertbdist,axisscale,TertOmega)
                    yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                 tertbdist,axisscale,TertOmega)

                    iyes=-1000
                    if(i3flag.ge.1)then
                      call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,
     @                  iyes,icut)
                      call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,
     @                  iyes,icut)
                    endif
                    if(iyes.eq.100)then
                      NNhid=NNhid+1
                    endif
 5800             continue
 5801             nvis=Nloop-NNhid
                  visib(iidx)=projarray(iidx)*(dble(nvis)/dble(Nloop))
                endif
              endif ! end if MonteCarlo < -10
c
c
7701         go to 701    !this part really does not work, so skip it.
 701        continue
 702      continue
c
          return
          end
c
c  *************************************************************************
c
          subroutine hidgrid3(ialphmax,ibetmax,Nalf,ibetlim,
     @      phase,finc,Q,xarray,yarray,zarray,projarray,
     @      garray,gscale,surf,Nhoriz1,xhoriz1,yhoriz1,rinty,extension,
     $      separation,flux,reff,iecheck,tarray,bdist,mmdx,
     @      tertincl,tertbdist,tertphase,tertQ,axisscale,isw30,isw7,
     @      tertOmega,icounttime,Nhoriz2,xhoriz2,yhoriz2,i3flag)
c
c   January 14, 2000
c
c   This routine will output files used for various external plotting
c   packages.
c
          implicit double precision(a-h,o-z)
c
          parameter(pie=3.14159265358979323d0)
          dimension ibetlim(ialphmax),
     $        xhoriz1(Nhoriz1),yhoriz1(Nhoriz1),
     @        xarray(ialphmax*ibetmax),yarray(ialphmax*ibetmax),
     @        zarray(ialphmax*ibetmax),rinty(ialphmax*ibetmax),
     @        garray(ialphmax*ibetmax),projarray(ialphmax*ibetmax),
     @        surf(ialphmax*ibetmax),tarray(ialphmax*ibetmax),
     @        savex(50000),savey(50000),
     @        mmdx(ialphmax,ibetmax)
          dimension xhoriz2(Nhoriz2),yhoriz2(Nhoriz2)
c
          character*9 extension
c
c    For the third body, offset all x and y sky coordinates
c
          xxoff=0.0d0
          yyoff=0.0d0
          xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
          yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertQ,
     @         axisscale)
          tOmrad=TertOmega*pie/180.0d0
          xxoff=xxoff1*dcos(tOmrad)-yyoff1*dsin(tOmrad)
          yyoff=xxoff1*dsin(tOmrad)+yyoff1*dcos(tOmrad)
c
c          FINCR = (FINC/180.0d0)*pie       !orbital inclination in radians
c          
          open(unit=40,
     %         file='star3inty.'//extension,status='unknown')
c
c   Check to see of the star in question is in front.  
c
c   Find the sky coordinates of the center of mass of the star.  This
c   will be recorded as the first line of the star?inty.???.?? file.
c
          xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @       tertbdist,axisscale,TertOmega)
          yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @                 tertbdist,axisscale,TertOmega)
c
          write(40,68)xp*separation,yp*separation,flux,reff*separation,
     %       separation

          isave=0
          DO 501 IALF = 1, NALF
            DO 502 IBET = 1,ibetlim(ialf)        
              iidx=mmdx(ialf,ibet)
              RRRR=sqrt(xarray(iidx)**2+yarray(iidx)**2+zarray(iidx)**2)
              iv1=1
              iv1_2=1
              IF (projarray(iidx).le.0.0d0) go to 502 ! is the surface 
              xx=xarray(iidx)                   ! element visible?
              yy=yarray(iidx)
              zz=zarray(iidx)
c              xp=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)   ! projected coords
c              yp=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              xp=xp+xxoff
c              yp=yp+yyoff
              xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              if(i3flag.eq.0)then    
                iyes1=-100
                iyes2=-100
                call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xp,yp,
     @                 iyes1,icut)
                call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xp,yp,
     @                  iyes2,icut)
                if((iyes1.eq.100))iv1=0   
                if((iyes2.eq.100))iv1_2=0    ! point could be visible
              endif
c       
c   Record the x,y,z coordinates of the nearby points.  These points
c   will be used for area filling
c
              xx1=xp
              yy1=yp
c
              isave=isave+1
              savex(isave)=xp*separation
              savey(isave)=yp*separation
c
              if(ibet.gt.1)then
                izz=ialf
                jzz=ibet-1
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
                izz=ialf
                jzz=ibetlim(ialf)
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              endif
              xx2=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              yy2=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
c
c              xx2=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              yy2=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              xx2=xx2+xxoff
c              yy2=yy2+yyoff
              if(ialf.gt.1)then
                if(ibet.gt.1)then
                  izz=ialf-1
                  jzz=min(ibet-1,ibetlim(ialf-1))
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                else
                  izz=ialf-1
                  jzz=ibetlim(ialf-1)
                  iidx=mmdx(izz,jzz)
                  xx=xarray(iidx)
                  yy=yarray(iidx)
                  zz=zarray(iidx)
                endif
              else
                xx=0.0d0
                yy=0.0d0
                zz=zarray(1)
              endif
c              xx3=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              yy3=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              xx3=xx3+xxoff
c              yy3=yy3+yyoff
              xx3=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              yy3=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              if(ialf.gt.1)then
                izz=ialf-1
                jzz=min(ibet,ibetlim(ialf-1))
                iidx=mmdx(izz,jzz)
                xx=xarray(iidx)
                yy=yarray(iidx)
                zz=zarray(iidx)
              else
                xx=0.0d0
                yy=0.0d0
                zz=zarray(1)
              endif
              xx4=tertxtrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
              yy4=tertytrans(xx,yy,zz,tertphase,tertincl,tertQ,
     @           tertbdist,axisscale,TertOmega)
c              xx4=xtran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              yy4=ytran(xx,yy,zz,phase,fincr,Q,istar,bdist)
c              xx4=xx4+xxoff
c              yy4=yy4+yyoff
c
c   Check the corners for eclipsed points.
c
              iv2=1
              iv3=1
              iv4=1
              iv2_2=1
              iv3_2=1
              iv4_2=1
              if(i3flag.eq.0)then
                iyes1=-100
                iyes2=-100
                iv2=1
                iv2_2=1
                call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,iyes1,
     @              icut)
                call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,iyes2,
     @            icut)
                if((iyes1.eq.100))iv2=0      
                if((iyes2.eq.100))iv2_2=0      
                iv3=1
                iyes1=-100
                iv3_2=1
                iyes2=-100
                call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,iyes1,
     @               icut)
                call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,iyes2,
     @             icut)
                if(iyes1.eq.100)iv3=0      
                if(iyes2.eq.100)iv3_2=0      
                iv4=1
                iyes1=-100
                iv4_2=1
                iyes2=-100
                call insidecircle(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,iyes1,
     @               icut)
                call insidecircle(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,iyes2,
     @             icut)
                if(iyes1.eq.100)iv4=0      
                if(iyes2.eq.100)iv4_2=0      
              endif
              if(iecheck.le.-1)then
                iv1=1
                iv2=1
                iv3=1
                iv4=1
              endif
c
c   There are 13 possibilities for which corners were hidden.  Do each
c   case separately.  This is for the tertiary.
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0).and.
     @           (iv3.eq.0))go to 897   !points hidden by secondary/primary
c
              if((iv1_2.eq.0).and.(iv2_2.eq.0).and.(iv3_2.eq.1).
     @          and.(iv4_2.eq.1))then
                ncorner=4
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c              
              if((iv1_2.eq.0).and.(iv2_2.eq.0).and.(iv3_2.eq.1)
     @           .and.(iv4_2.eq.0))then
                ncorner=4
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 99
              endif
c              
              if((iv1_2.eq.0).and.(iv2_2.eq.1).and.(iv3_2.eq.1)
     @               .and.(iv4_2.eq.1))then
                ncorner=5
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_2.eq.0).and.(iv2_2.eq.0).and.(iv3_2.eq.0)
     @            .and.(iv4_2.eq.1))then
                ncorner=4
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_2.eq.0).and.(iv2_2.eq.1).and.(iv3_2.eq.1)
     @              .and.(iv4_2.eq.0))then
                ncorner=4
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_2.eq.0).and.(iv2_2.eq.1).and.(iv3_2.eq.0)
     @             .and.(iv4_2.eq.0))then
                ncorner=4
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.1).and.(iv3_2.eq.1)
     @             .and.(iv4_2.eq.1))then
                if(iv1.eq.0)go to 897
                if(iv2.eq.0)go to 897
                if(iv3.eq.0)go to 897
                if(iv4.eq.0)go to 897
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c 
              if((iv1_2.eq.1).and.(iv2_2.eq.0).and.(iv3_2.eq.1)
     @             .and.(iv4_2.eq.1))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.1).and.(iv3_2.eq.0)
     @            .and.(iv4_2.eq.1))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.1).and.(iv3_2.eq.1)
     @             .and.(iv4_2.eq.0))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.0).and.(iv3_2.eq.0)
     @           .and.(iv4_2.eq.1))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.1).and.(iv3_2.eq.0)
     @            .and.(iv4_2.eq.0))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1_2.eq.1).and.(iv2_2.eq.0).and.(iv3_2.eq.0)
     @              .and.(iv4_2.eq.0))then  
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
 897          if((iv1_2.eq.0).and.(iv2_2.eq.0).and.(iv3_2.eq.0).and.
     @           (iv4_2.eq.0))go to 99
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1).
     @          and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.1)
     @           .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %            xx4new*separation,yy4new*separation,  
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3*separation,yy3*separation
                go to 99
              endif
c              
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1)
     @               .and.(iv4.eq.1))then
                ncorner=5
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.0).and.(iv3.eq.0)
     @            .and.(iv4.eq.1))then
                ncorner=4
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.1)
     @              .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
c
              if((iv1.eq.0).and.(iv2.eq.1).and.(iv3.eq.0)
     @             .and.(iv4.eq.0))then
                ncorner=4
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1new*separation,yy1new*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1)
     @             .and.(iv4.eq.1))then
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c 
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.1)
     @             .and.(iv4.eq.1))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     $            xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx3*separation,yy3*separation,
     $            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0)
     @            .and.(iv4.eq.1))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.1)
     @             .and.(iv4.eq.0))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx1new=xedge
                yy1new=yedge
                ncorner=5
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3*separation,yy3*separation,
     %            xx4new*separation,yy4new*separation,
     &            xx1new*separation,yy1new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0)
     @           .and.(iv4.eq.1))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4*separation,yy4*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.1).and.(iv3.eq.0)
     @            .and.(iv4.eq.0))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2*separation,yy2*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
              if((iv1.eq.1).and.(iv2.eq.0).and.(iv3.eq.0)
     @              .and.(iv4.eq.0))then  
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,
     @              xedge,yedge)
                xx2new=xedge
                yy2new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx3,yy3,
     @              xedge,yedge)
                xx3new=xedge
                yy3new=yedge
                call clip(Nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,
     @              xedge,yedge)
                xx4new=xedge
                yy4new=yedge
                ncorner=4
                izz=ialf
                jzz=ibet
c                iidx=(izz-1)*ibetlim(ialf)+jzz
c                iidx=kount(ialphmax,izz,ibetlim)+jzz
                iidx=mmdx(izz,jzz)
                write(40,69)rinty(iidx),ncorner,projarray(iidx),
     %            surf(iidx),dlog10(gscale*garray(iidx)),
     %            ialf,ibet,tarray(iidx),RRRR,
     %             xx1*separation,yy1*separation,
     %            xx2new*separation,yy2new*separation,
     %            xx3new*separation,yy3new*separation,
     %            xx4new*separation,yy4new*separation
                go to 99
              endif
c
 99           continue
c              endif   ! if Nalf = 1
502         CONTINUE
 501      CONTINUE               
          
 68       format(2(f14.8,3x),e16.9,f10.4,2x,f10.4)
 69       format(e16.9,1x,i3,1x,f9.7,1x,e12.6,1x,f8.5,1x,
     %       2(i3,1x),1x,f10.3,2x,f11.6/,10(f11.6,1x))
c
          close(40)
c
          return
          end
c
c &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine copyinty3(ialphmax3,ibetmax3,Nalph3,
     @              ibetlim3,mmdx3,rinty3,saveinty3)
c
c   May 1, 2000
c
c   This routine is needed to fix a bug in the output routine---the
c   incorrect intensities for the BB mode were being written.
c
          implicit double precision(a-h,o-z)
c
          dimension rinty3(ialphmax3*ibetmax3),
     $        saveinty3(ialphmax3*ibetmax3)
          dimension mmdx3(ialphmax3,ibetmax3)
          dimension ibetlim3(ialphmax3)
c
          do 10 ialf=1,Nalph3
            do 9 ibet=1,ibetlim3(ialf)
              iidx=mmdx3(ialf,ibet)
              saveinty3(iidx)=rinty3(iidx)
 9          continue
 10       continue
c
          return
          end
c
c  $^$^$^%&$@#$%^&^%$#@&^%$#@@
c
      include 'limbdarksubs.for'
c
      subroutine occultquad(z0,u1,u2,p,muo1,mu0,nz)
C  This routine computes the lightcurve for occultation
C  of a quadratically limb-darkened source without microlensing.
C  Please cite Mandel & Agol (2002) if you make use of this routine
C  in your research.  Please report errors or bugs to agol@tapir.caltech.edu
      implicit none
      integer i,nz
      double precision z0,u1,u2,p,muo1,mu0,
     &       mu(nz),lambdad(nz),etad(nz),lambdae(nz),lam,
     &       pi,x1,x2,x3,z,omega,kap0,kap1,q,Kk,Ek,Pk,n,ellec,ellk,rj
      if(abs(p-0.5d0).lt.1.d-3) p=0.5d0
C
C Input:
C
C rs   radius of the source (set to unity)
C z0   impact parameter in units of rs
C p    occulting star size in units of rs
C u1   linear    limb-darkening coefficient (gamma_1 in paper)
C u2   quadratic limb-darkening coefficient (gamma_2 in paper)
C
C Output:
C
C muo1 fraction of flux at each z0 for a limb-darkened source
C mu0  fraction of flux at each z0 for a uniform source
C
C Limb darkening has the form:
C  I(r)=[1-u1*(1-sqrt(1-(r/rs)^2))-u2*(1-sqrt(1-(r/rs)^2))^2]/(1-u1/3-u2/6)/pi
C 
C To use this routine
C
C Now, compute pure occultation curve:
      omega=1.d0-u1/3.d0-u2/6.d0
      pi=acos(-1.d0)
C Loop over each impact parameter:
c      nz=1
      do i=1,nz
C substitute z=z0(i) to shorten expressions
        z=z0  !(i)
        x1=(p-z)**2
        x2=(p+z)**2
        x3=p**2-z**2
C the source is unocculted:
C Table 3, I.
        if(z.ge.1.d0+p) then
          lambdad(i)=0.d0
          etad(i)=0.d0
          lambdae(i)=0.d0
          goto 10
        endif
C the  source is completely occulted:
C Table 3, II.
        if(p.ge.1.d0.and.z.le.p-1.d0) then
          lambdad(i)=1.d0
          etad(i)=1.d0
          lambdae(i)=1.d0
          goto 10
        endif
C the source is partly occulted and the occulting object crosses the limb:
C Equation (26):
        if(z.ge.abs(1.d0-p).and.z.le.1.d0+p) then
          kap1=acos(min((1.d0-p*p+z*z)/2.d0/z,1.d0))
          kap0=acos(min((p*p+z*z-1.d0)/2.d0/p/z,1.d0))
          lambdae(i)=p*p*kap0+kap1
          lambdae(i)=(lambdae(i)-0.5d0*sqrt(max(4.d0*z*z-
     &               (1.d0+z*z-p*p)**2,0.d0)))/pi
        endif
C the occulting object transits the source star (but doesn't
C completely cover it):
        if(z.le.1.d0-p) lambdae(i)=p*p
C the edge of the occulting star lies at the origin- special 
C expressions in this case:
        if(abs(z-p).lt.1.d-4*(z+p)) then
C Table 3, Case V.:
          if(z.ge.0.5d0) then
            lam=0.5d0*pi
            q=0.5d0/p
            Kk=ellk(q)
            Ek=ellec(q)
C Equation 34: lambda_3
            lambdad(i)=1.d0/3.d0+16.d0*p/9.d0/pi*(2.d0*p*p-1.d0)*Ek-
     &                 (32.d0*p**4-20.d0*p*p+3.d0)/9.d0/pi/p*Kk
C Equation 34: eta_1
            etad(i)=1.d0/2.d0/pi*(kap1+p*p*(p*p+2.d0*z*z)*kap0-
     &              (1.d0+5.d0*p*p+z*z)/4.d0*sqrt((1.d0-x1)*(x2-1.d0)))
            if(p.eq.0.5d0) then
C Case VIII: p=1/2, z=1/2
              lambdad(i)=1.d0/3.d0-4.d0/pi/9.d0
              etad(i)=3.d0/32.d0
            endif
            goto 10
          else
C Table 3, Case VI.:
            lam=0.5d0*pi
            q=2.d0*p
            Kk=ellk(q)
            Ek=ellec(q)
C Equation 34: lambda_4
            lambdad(i)=1.d0/3.d0+2.d0/9.d0/pi*(4.d0*(2.d0*p*p-1.d0)*Ek+
     &                 (1.d0-4.d0*p*p)*Kk)
C Equation 34: eta_2
            etad(i)=p*p/2.d0*(p*p+2.d0*z*z)
            goto 10
          endif
        endif
C the occulting star partly occults the source and crosses the limb:
C Table 3, Case III:
        if((z.gt.0.5d0+abs(p-0.5d0).and.z.lt.1.d0+p).or.(p.gt.0.5d0.
     &      and.z.gt.abs(1.d0-p)*1.0001d0.and.z.lt.p)) then
          lam=0.5d0*pi
          q=sqrt((1.d0-(p-z)**2)/4.d0/z/p)
          Kk=ellk(q)
          Ek=ellec(q)
          n=1.d0/x1-1.d0
          Pk=Kk-n/3.d0*rj(0.d0,1.d0-q*q,1.d0,1.d0+n)
C Equation 34, lambda_1:
          lambdad(i)=1.d0/9.d0/pi/sqrt(p*z)*(((1.d0-x2)*(2.d0*x2+
     &        x1-3.d0)-3.d0*x3*(x2-2.d0))*Kk+4.d0*p*z*(z*z+
     &        7.d0*p*p-4.d0)*Ek-3.d0*x3/x1*Pk)
          if(z.lt.p) lambdad(i)=lambdad(i)+2.d0/3.d0
C Equation 34, eta_1:
          etad(i)=1.d0/2.d0/pi*(kap1+p*p*(p*p+2.d0*z*z)*kap0-
     &          (1.d0+5.d0*p*p+z*z)/4.d0*sqrt((1.d0-x1)*(x2-1.d0)))
          goto 10
        endif
C the occulting star transits the source:
C Table 3, Case IV.:
        if(p.le.1.d0.and.z.le.(1.d0-p)*1.0001d0) then
          lam=0.5d0*pi
          q=sqrt((x2-x1)/(1.d0-x1))
          Kk=ellk(q)
          Ek=ellec(q)
          n=x2/x1-1.d0
          Pk=Kk-n/3.d0*rj(0.d0,1.d0-q*q,1.d0,1.d0+n)
C Equation 34, lambda_2:
          lambdad(i)=2.d0/9.d0/pi/sqrt(1.d0-x1)*((1.d0-5.d0*z*z+p*p+
     &         x3*x3)*Kk+(1.d0-x1)*(z*z+7.d0*p*p-4.d0)*Ek-3.d0*x3/x1*Pk)
          if(z.lt.p) lambdad(i)=lambdad(i)+2.d0/3.d0
          if(abs(p+z-1.d0).le.1.d-4) then
            lambdad(i)=2/3.d0/pi*acos(1.d0-2.d0*p)-4.d0/9.d0/pi*
     &            sqrt(p*(1.d0-p))*(3.d0+2.d0*p-8.d0*p*p)
          endif
C Equation 34, eta_2:
          etad(i)=p*p/2.d0*(p*p+2.d0*z*z)
        endif
 10     continue
C Now, using equation (33):
        muo1=1.d0-((1.d0-u1-2.d0*u2)*lambdae(i)+(u1+2.d0*u2)*
     &      lambdad(i)+u2*etad(i))/omega
C Equation 25:
        mu0=1.d0-lambdae(i)
      enddo
      return
      end

      FUNCTION rc(x,y)
      REAL*8 rc,x,y,ERRTOL,TINY,SQRTNY,BIG,TNBG,COMP1,COMP2,THIRD,C1,C2,
     *C3,C4
      PARAMETER (ERRTOL=.04d0,TINY=1.69d-38,SQRTNY=1.3d-19,BIG=3.d37,
     *TNBG=TINY*BIG,COMP1=2.236d0/SQRTNY,COMP2=TNBG*TNBG/25.d0,
     *THIRD=1.d0/3.d0,C1=.3d0,C2=1.d0/7.d0,C3=.375d0,C4=9.d0/22.d0)
      REAL*8 alamb,ave,s,w,xt,yt
      if(x.lt.0..or.y.eq.0..or.(x+abs(y)).lt.TINY.or.(x+
     *abs(y)).gt.BIG.or.(y.lt.-COMP1.and.x.gt.0..and.x.lt.COMP2))then
         write(*,*)'invalid arguments in rc'
         stop
      endif
      if(y.gt.0.d0)then
        xt=x
        yt=y
        w=1.
      else
        xt=x-y
        yt=-y
        w=sqrt(x)/sqrt(xt)
      endif
1     continue
        alamb=2.d0*sqrt(xt)*sqrt(yt)+yt
        xt=.25d0*(xt+alamb)
        yt=.25d0*(yt+alamb)
        ave=THIRD*(xt+yt+yt)
        s=(yt-ave)/ave
      if(abs(s).gt.ERRTOL)goto 1
      rc=w*(1.d0+s*s*(C1+s*(C2+s*(C3+s*C4))))/sqrt(ave)
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software

      FUNCTION rj(x,y,z,p)
      REAL*8 rj,p,x,y,z,ERRTOL,TINY,BIG,C1,C2,C3,C4,C5,C6,C7,C8
      PARAMETER (ERRTOL=.05d0,TINY=2.5d-13,BIG=9.d11,C1=3.d0/14.d0,
     *C2=1.d0/3.d0,C3=3.d0/22.d0,C4=3.d0/26.d0,C5=.75d0*C3,
     *C6=1.5d0*C4,C7=.5d0*C2,C8=C3+C3)
CU    USES rc,rf
      REAL*8 a,alamb,alpha,ave,b,beta,delp,delx,dely,delz,ea,eb,ec,ed,ee,
     *fac,pt,rcx,rho,sqrtx,sqrty,sqrtz,sum,tau,xt,yt,zt,rc,rf
      if(min(x,y,z).lt.0..or.min(x+y,x+z,y+z,abs(p)).lt.TINY.or.max(x,y,
     *z,abs(p)).gt.BIG)then
        rj=1.0d50
        return
      endif
      sum=0.d0
      fac=1.d0
      if(p.gt.0.d0)then
        xt=x
        yt=y
        zt=z
        pt=p
      else
        xt=min(x,y,z)
        zt=max(x,y,z)
        yt=x+y+z-xt-zt
        a=1.d0/(yt-p)
        b=a*(zt-yt)*(yt-xt)
        pt=yt+b
        rho=xt*zt/yt
        tau=p*pt/yt
        rcx=rc(rho,tau)
      endif
1     continue
        sqrtx=sqrt(xt)
        sqrty=sqrt(yt)
        sqrtz=sqrt(zt)
        alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz
        alpha=(pt*(sqrtx+sqrty+sqrtz)+sqrtx*sqrty*sqrtz)**2
        beta=pt*(pt+alamb)**2
        sum=sum+fac*rc(alpha,beta)
        fac=.25d0*fac
        xt=.25d0*(xt+alamb)
        yt=.25d0*(yt+alamb)
        zt=.25d0*(zt+alamb)
        pt=.25d0*(pt+alamb)
        ave=.2d0*(xt+yt+zt+pt+pt)
        delx=(ave-xt)/ave
        dely=(ave-yt)/ave
        delz=(ave-zt)/ave
        delp=(ave-pt)/ave
      if(max(abs(delx),abs(dely),abs(delz),abs(delp)).gt.ERRTOL)goto 1
      ea=delx*(dely+delz)+dely*delz
      eb=delx*dely*delz
      ec=delp**2
      ed=ea-3.d0*ec
      ee=eb+2.d0*delp*(ea-ec)
      rj=3.d0*sum+fac*(1.d0+ed*(-C1+C5*ed-C6*ee)+eb*(C7+delp*
     *(-C8+delp*C4))+delp*ea*(C2-delp*C3)-C2*delp*ec)/(ave*sqrt(ave))
      if (p.le.0.d0) rj=a*(b*rj+3.d0*(rcx-rf(xt,yt,zt)))
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software

      function ellec(k)
      implicit none
      double precision k,m1,a1,a2,a3,a4,b1,b2,b3,b4,ee1,ee2,ellec
C Computes polynomial approximation for the complete elliptic
C integral of the second kind (Hasting's approximation):
      m1=1.d0-k*k
      a1=0.44325141463d0
      a2=0.06260601220d0
      a3=0.04757383546d0
      a4=0.01736506451d0
      b1=0.24998368310d0
      b2=0.09200180037d0
      b3=0.04069697526d0
      b4=0.00526449639d0
      ee1=1.d0+m1*(a1+m1*(a2+m1*(a3+m1*a4)))
      ee2=m1*(b1+m1*(b2+m1*(b3+m1*b4)))*log(1.d0/m1)
      ellec=ee1+ee2
      return
      end

      function ellk(k)
      implicit none
      double precision a0,a1,a2,a3,a4,b0,b1,b2,b3,b4,ellk,
     &       ek1,ek2,k,m1
C Computes polynomial approximation for the complete elliptic
C integral of the first kind (Hasting's approximation):
      m1=1.d0-k*k
      a0=1.38629436112d0
      a1=0.09666344259d0
      a2=0.03590092383d0
      a3=0.03742563713d0
      a4=0.01451196212d0
      b0=0.5d0
      b1=0.12498593597d0
      b2=0.06880248576d0
      b3=0.03328355346d0
      b4=0.00441787012d0
      ek1=a0+m1*(a1+m1*(a2+m1*(a3+m1*a4)))
      ek2=(b0+m1*(b1+m1*(b2+m1*(b3+m1*b4))))*log(m1)
      ellk=ek1-ek2
      return
      end

      FUNCTION rf(x,y,z)
      REAL*8 rf,x,y,z,ERRTOL,TINY,BIG,THIRD,C1,C2,C3,C4
      PARAMETER (ERRTOL=.08d0,TINY=1.5d-38,BIG=3.d37,THIRD=1.d0/3.d0,
     *C1=1.d0/24.d0,C2=.1d0,C3=3.d0/44.d0,C4=1.d0/14.d0)
      REAL*8 alamb,ave,delx,dely,delz,e2,e3,sqrtx,sqrty,sqrtz,xt,yt,zt
      if(min(x,y,z).lt.0.d0.or.min(x+y,x+z,y+z).lt.TINY.or.max(x,y,
     *z).gt.BIG)then
        write(*,*)'invalid arguments in rf'
        stop
      endif
      xt=x
      yt=y
      zt=z
1     continue
        sqrtx=sqrt(xt)
        sqrty=sqrt(yt)
        sqrtz=sqrt(zt)
        alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz
        xt=.25d0*(xt+alamb)
        yt=.25d0*(yt+alamb)
        zt=.25d0*(zt+alamb)
        ave=THIRD*(xt+yt+zt)
        delx=(ave-xt)/ave
        dely=(ave-yt)/ave
        delz=(ave-zt)/ave
      if(max(abs(delx),abs(dely),abs(delz)).gt.ERRTOL)goto 1
      e2=delx*dely-delz**2
      e3=delx*dely*delz
      rf=(1.d0+(C1*e2-C2-C3*e3)*e2+C4*e3)/sqrt(ave)
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software 0NL&WR2.
c
c
          subroutine findconj(tertargrad,tertecc,pconj3,pconj4,
     @      phper2a,phper2b)
c
c   October 12, 2013
c
c   Will return the conjunction phases of primary and secondary
c
          implicit double precision(a-h,o-z)
c
          pie=3.14159265358979323d0

          trc=0.5d0*pie-tertargrad
 4131     if(trc.lt.0.d0) trc=trc+2.0d0*pie
          if(trc.lt.0.d0) goto 4131
 4149     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
          if(trc.ge.2.0d0*pie) goto 4149
          htrc=0.5d0*trc
          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 41109
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41109
          ecan=2.d0*datan(dsqrt((1.d0-tertecc)
     @        /(1.d0+tertecc))*dtan(htrc))
          goto 41108
41109     ecan=pie
41108     xmc=ecan-tertecc*dsin(ecan)
          phper2a=1.d0-xmc/(2.0d0*pie)
          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
          pconj3=(xmc+tertargrad)/(2.0d0*pie)-0.25d0
c
c   Make sure the conjunction phase is between 0 and 1
c
          if(pconj3.gt.1.0d0)pconj3=pconj3-1.0d0
          trc=0.5d0*pie-tertargrad+pie
 3839     if(trc.lt.0.d0) trc=trc+2.0d0*pie
          if(trc.lt.0.d0) goto 3839
 3840     if(trc.ge.2.0d0*pie) trc=trc-2.0d0*pie
          if(trc.ge.2.0d0*pie) goto 3840
          htrc=0.5d0*trc
          if(dabs(0.5*pie-htrc).lt.7.d-6) goto 37801
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 37801
          ecan=2.d0*datan(dsqrt((1.d0-tertecc)
     @         /(1.d0+tertecc))*dtan(htrc))
          goto 31803
37801     ecan=pie
31803     xmc=ecan-tertecc*dsin(ecan)
          phper2b=1.d0-xmc/(2.0d0*pie)
          if(xmc.lt.0.d0) xmc=xmc+2.0d0*pie
          pconj4=(xmc+tertargrad)/(2.0d0*pie)-0.25d0
c
c   Make sure the conjunction phase is between 0 and 1
c
          if(pconj4.gt.1.0d0)pconj4=pconj4-1.0d0
c
          return
          end
c
c $#@#^%%$@*&^%$#!**&^%
c
          subroutine planetparms(planetparm,Tref,Q,finc,separ,period,
     @       reff1,reff2,ecc,SA3,tertperiod,tertt0,tertecos,tertesin,
     @       tertincl,tertOmega,tertQ,itconj,tertconj,isw30,P2tconj,
     @       P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,P2ratrad,
     @       P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,P3Q,
     @       P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,
     @       P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,P5esin,
     @       P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,P6ecos,
     @       P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,P7T0,
     @       P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,P8tconj,P8period,
     @       P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,P8ratrad,argper,
     @       T0,Tconj,isw28)
c
          implicit double precision(a-h,o-z)
c
          character*1700 planetparm
c
          parameter(pie=3.14159265358979323d0)
c
           fincr=finc*3.141592653589879d0/180.0d0        ! radians
c           ppp=period*24.0d0               ! period in hours
           sifinc=dsin(fincr)
c
c   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
c   solve for the total mass in solar masses.  The separation is
c   entered in solar masses, so (R_sun/coef)**3=7.737294491.
c
c           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
c
c   Use the value of GM_sun found from the solar system.
c
           gmsun=1.32712440018d20  !mks units
           solarrad=6.9598d8
           earthradcgs=6371.0d0*1000.0d0*100.0d0
           earthmasstosolar=1.0d0/0.000003003d0
           earthradtosolar=109.24187725d0
           earthcm=6371.0d0*1000.0d0*100.0d0
           earthgram=5.97219d27
           daysinyear=365.25d0
           p=period*86400.0d0
           ppp=period*24.0d0
           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
           rM1=(separ*solarrad)**(3)*4.0d0*pie*pie
           rM1=rM1/(gmsun*p*p*(1.0d0+Q))
           rM2=Q*rM1
           R1=reff1*separ
           R2=reff2*separ
           volume=(4.0d0*pie/3.0d0)*(R2*solarrad*100.0d0)**3
           den=rM2*1.9889d33/volume
           rimpactEB=dcos(fincr)*separ/R1
           if(rimpactEB.lt.1.0d0)then
             term1=dsqrt((1.0d0+R2/R1)**2-
     @           rimpact1**2)
           else
             term1=0.0d0
           endif
           term2=period*R1/(pie*separ
     @         *dsqrt(1.0d0-ecc*ecc))
           term3=(1.0d0-ecc*ecc)/(1.0d0-ecc1*dcos(argper*pie/180.0d0))
           durationEB=term1*term2*term3*24.0d0
           AUEB=separ/214.939469384d0
c
c   planet 1 (circumbinary case)
c
           if(tertQ.ne.0.0d0)then
             planetM1=(rM1+rM2)/tertQ*earthmasstosolar
           else
             planetM1=0.0d0
           endif
           ttt=SA3
           if(ttt.lt.0.0d0)ttt=0.0d0
           planetR1=R1*dsqrt(ttt)*earthradtosolar
           den1=planetM1*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR1*earthcm)**3)
           if(tertQ.le.0.0d0)then
             totalmass=0.0d0
           else
             totalmass=(total_mass)*(1.0d0+1.0d0/tertQ)          
           endif
           AU1=((tertperiod/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
           ecc1=dsqrt((tertesin**2+tertecos**2))
           arg1=(datan2(tertesin,tertecos))*180.0d0/pie
c           if(arg1.lt.0.0d0)arg1=arg1+180.0d0

           if(itconj.ge.2)then
             call getT0(tertincl,tertperiod,ecc1,arg1,Tperi1,tertconj)
             T0_1=tertconj
           endif
           if(itconj.eq.1)then
             call getT0tran(tertincl,tertperiod,tertecc,tertarg,
     @         T0_1,tertconj)
           endif
           if(itconj.eq.0)then
             call getcontimes(finc,period,ecc1,arg1,T0_1,tertconj,
     @          tconj2)
           endif
           tt1=dsin(tertincl*pie/180.0d0)*dsin(fincr)
     @        *dcos(tertOmega*pie/180.0d0)
           tt2=dcos(tertincl*pie/180.0d0)*dcos(fincr)
           rmutual1=dacos(tt1+tt2)*180.0d0/pie
           rimpact1=dabs(dcos(tertincl*pie/180.0d0)*AU1*
     @        214.939469384d0/R1)
           if(rimpact1.lt.1.0d0)then
             term1=dsqrt((1.0d0+planetR1/earthradtosolar/R1)**2-
     @           rimpact1**2)
           else
             term1=0.0d0
           endif
           term2=tertperiod*R1/(pie*AU1*214.939469384d0
     @         *dsqrt(1.0d0-ecc1*ecc1))
           term3=(1.0d0-ecc1*ecc1)/(1.0d0-ecc1*dcos(arg1))
           duration1=term1*term2*term3*24.0d0
           rinc1=tertincl
           Omega1=tertOmega
           P1tconj=tertconj
c
c  planet 2 (body 4)
c
           if((P2period.le.0.0d0).or.(P2Q.le.0.0d0))then
             planetM2=0.0d0
             planetR2=0.0d0
             den2=0.0d0
             AU2=0.0d0
             ecc2=0.0d0
             arg2=0.0d0
             rinc2=0.0d0
             Omega2=0.0d0
             rimpact2=0.0d0
             rmutual2=0.0d0
             duration2=0.0d0*24.0d0
             T0_2=0.0d0
           else
             if(P2Q.ne.0.0d0)then
               planetM2=(rM1+rM2)/P2Q*earthmasstosolar
             else
               planetM2=0.0d0
             endif
             if(P2ratrad.le.0.0d0)then
               planetR2=0.0d0
             else
               planetR2=R1/P2ratrad*earthradtosolar
             endif
             if(planetR2.le.0.0d0)then
               den2=0.0d0
             else
               den2=planetM2*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR2*earthcm)**3)
             endif
             if(P2Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P2Q)          
             endif
             AU2=((P2period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc2=dsqrt((P2esin**2+P2ecos**2))
             arg2=(datan2(P2esin,P2ecos))*180.0d0/pie
c             if(arg2.lt.0.0d0)arg2=arg2+180.0d0
             if(itconj.ge.2)then
               call getT0(P2incl,P2period,ecc2,arg2,T0_2,P2tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P2incl,P2period,ecc2,arg2,
     @           T0_2,P2tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P2incl,P2period,ecc2,arg2,P2T0,
     @           P2conj,tconj2)
               T0_2=P2T0
             endif
             tt1=dsin(P2incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P2Omega*pie/180.0d0)
             tt2=dcos(P2incl*pie/180.0d0)*dcos(fincr)
             rmutual2=dacos(tt1+tt2)*180.0d0/pie
             rimpact2=dabs(dcos(P2incl*pie/180.0d0)*AU2*
     @           214.939469384d0/R1)
             if(rimpact2.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR2/earthradtosolar/R1)**2-
     @             rimpact2**2)
             else
               term1=0.0d0
             endif
             term2=P2period*R1/(pie*AU2*214.939469384d0
     @           *dsqrt(1.0d0-ecc2*ecc2))
             term3=(1.0d0-ecc2*ecc2)/(1.0d0-ecc2*dcos(arg2))
             duration2=term1*term2*term3*24.0d0
             rinc2=P2incl
             Omega2=P2Omega
           endif
c
c  planet 3
c
           if((P3period.le.0.0d0).or.(P3Q.le.0.0d0))then
             planetM3=0.0d0
             planetR3=0.0d0
             den3=0.0d0
             AU3=0.0d0
             ecc3=0.0d0
             arg3=0.0d0
             rinc3=0.0d0
             Omega3=0.0d0
             rimpact3=0.0d0
             rmutual3=0.0d0
             duration3=0.0d0*24.0d0
             T0_3=0.0d0
           else
             if(P3Q.ne.0.0d0)then
               planetM3=(rM1+rM2)/P3Q*earthmasstosolar
             else
               planetM3=0.0d0
             endif
             if(P3ratrad.le.0.0d0)then
               planetR3=0.0d0
             else
               planetR3=R1/P3ratrad*earthradtosolar
             endif
             if(planetR3.le.0.0d0)then
               den3=0.0d0
             else
               den3=planetM3*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR3*earthcm)**3)
             endif
             if(P3Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P3Q)          
             endif
             AU3=((P3period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc3=dsqrt((P3esin**2+P3ecos**2))
             arg3=(datan2(P3esin,P3ecos))*180.0d0/pie
c             if(arg3.lt.0.0d0)arg3=arg3+180.0d0
             if(itconj.ge.2)then
               call getT0(P3incl,P3period,ecc3,arg3,T0_3,P3tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P3incl,P3period,ecc3,arg3,
     @           T0_3,P3tconj)
             endif
             if(itconj.eq.0)then
              call getcontimes(P3incl,P3period,ecc3,arg3,P3T0,
     @           P3conj,tconj2)
               T0_3=P3T0
             endif
             tt1=dsin(P3incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P3Omega*pie/180.0d0)
             tt2=dcos(P3incl*pie/180.0d0)*dcos(fincr)
             rmutual3=dacos(tt1+tt2)*180.0d0/pie
             rimpact3=dabs(dcos(P3incl*pie/180.0d0)*AU3
     @              *214.939469384d0/R1)
             if(rimpact3.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR3/earthradtosolar/R1)**2-
     @             rimpact3**2)
             else
               term1=0.0d0
             endif
             term2=P3period*R1/(pie*AU3*214.939469384d0
     @           *dsqrt(1.0d0-ecc3*ecc3))
             term3=(1.0d0-ecc3*ecc3)/(1.0d0-ecc3*dcos(arg3))
             duration3=term1*term2*term3*24.0d0
             rinc3=P3incl
             Omega3=P3Omega
           endif
c
c  planet 4
c
           if((P4period.le.0.0d0).or.(P4Q.le.0.0d0))then
             planetM4=0.0d0
             planetR4=0.0d0
             den4=0.0d0
             AU4=0.0d0
             ecc4=0.0d0
             arg4=0.0d0
             rinc4=0.0d0
             Omega4=0.0d0
             rimpact4=0.0d0
             rmutual4=0.0d0
             duration4=0.0d0*24.0d0
             T0_4=0.0d0
           else
             if(P4Q.ne.0.0d0)then
               planetM4=(rM1+rM2)/P4Q*earthmasstosolar
             else
               planetM4=0.0d0
             endif
             if(P4ratrad.le.0.0d0)then
               planetR4=0.0d0
             else
               planetR4=R1/P4ratrad*earthradtosolar
             endif
             if(planetR4.le.0.0d0)then
               den4=0.0d0
             else
               den4=planetM4*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR4*earthcm)**3)
             endif
             if(P4Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P4Q)          
             endif
             AU4=((P4period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc4=dsqrt((P4esin**2+P4ecos**2))
             arg4=(datan2(P4esin,P4ecos))*180.0d0/pie
c             if(arg4.lt.0.0d0)arg4=arg4+180.0d0
             if(itconj.ge.2)then
               call getT0(P4incl,P4period,ecc4,arg4,T0_4,P4tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P4incl,P4period,ecc4,arg4,
     @           T0_4,P4tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P4incl,P4period,ecc4,arg4,P4T0,
     @             P4conj,tconj2)
               T0_4=P4T0
             endif
             tt1=dsin(P4incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P4Omega*pie/180.0d0)
             tt2=dcos(P4incl*pie/180.0d0)*dcos(fincr)
             rmutual4=dacos(tt1+tt2)*180.0d0/pie
             rimpact4=dabs(dcos(P4incl*pie/180.0d0)*AU4*
     @               214.939469384d0/R1)
             if(rimpact4.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR4/earthradtosolar/R1)**2-
     @             rimpact4**2)
             else
               term1=0.0d0
             endif
             term2=P4period*R1/(pie*AU4*214.939469384d0
     @           *dsqrt(1.0d0-ecc4*ecc4))
             term3=(1.0d0-ecc4*ecc4)/(1.0d0-ecc4*dcos(arg4))
             duration4=term1*term2*term3*24.0d0
             rinc4=P4incl
             Omega4=P4Omega
           endif
c
c  planet 5
c
           if((P5period.le.0.0d0).or.(P5Q.le.0.0d0))then
             planetM5=0.0d0
             planetR5=0.0d0
             den5=0.0d0
             AU5=0.0d0
             ecc5=0.0d0
             arg5=0.0d0
             rinc5=0.0d0
             Omega5=0.0d0
             rimpact5=0.0d0
             rmutual5=0.0d0
             duration5=0.0d0*24.0d0
             T0_5=0.0d0
           else
             if(P5Q.ne.0.0d0)then
               planetM5=(rM1+rM2)/P5Q*earthmasstosolar
             else
               planetM5=0.0d0
             endif
             if(P5ratrad.le.0.0d0)then
               planetR5=0.0d0
             else
               planetR5=R1/P5ratrad*earthradtosolar
             endif
             if(planetR5.le.0.0d0)then
               den5=0.0d0
             else
               den5=planetM5*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR5*earthcm)**3)
             endif
             if(P5Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P5Q)          
             endif
             AU5=((P5period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc5=dsqrt((P5esin**2+P5ecos**2))
             arg5=(datan2(P5esin,P5ecos))*180.0d0/pie
c             if(arg5.lt.0.0d0)arg5=arg5+180.0d0
             if(itconj.ge.2)then
               call getT0(P5incl,P5period,ecc5,arg5,T0_5,P5tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P5incl,P5period,ecc5,arg5,
     @           T0_5,P5tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P5incl,P5period,ecc5,arg5,P5T0,
     @              P5conj,tconj2)
               T0_5=P5T0
             endif
             tt1=dsin(P5incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P5Omega*pie/180.0d0)
             tt2=dcos(P5incl*pie/180.0d0)*dcos(fincr)
             rmutual5=dacos(tt1+tt2)*180.0d0/pie
             rimpact5=dabs(dcos(P5incl*pie/180.0d0)*AU5
     @          *214.939469384d0/R1)
             if(rimpact5.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR5/earthradtosolar/R1)**2-
     @             rimpact5**2)
             else
               term1=0.0d0
             endif
             term2=P5period*R1/(pie*AU5*214.939469384d0
     @           *dsqrt(1.0d0-ecc5*ecc5))
             term3=(1.0d0-ecc5*ecc5)/(1.0d0-ecc5*dcos(arg5))
             duration5=term1*term2*term3*24.0d0
             rinc5=P5incl
             Omega5=P5Omega
           endif
c
c  planet 6
c
           if((P6period.le.0.0d0).or.(P6Q.le.0.0d0))then
             planetM6=0.0d0
             planetR6=0.0d0
             den6=0.0d0
             AU6=0.0d0
             ecc6=0.0d0
             arg6=0.0d0
             rinc6=0.0d0
             Omega6=0.0d0
             rimpact6=0.0d0
             rmutual6=0.0d0
             duration6=0.0d0*24.0d0
             T0_6=0.0d0
           else
             if(P6Q.ne.0.0d0)then
               planetM6=(rM1+rM2)/P6Q*earthmasstosolar
             else
               planetM6=0.0d0
             endif
             if(P6ratrad.le.0.0d0)then
               planetR6=0.0d0
             else
               planetR6=R1/P6ratrad*earthradtosolar
             endif
             if(planetR6.le.0.0d0)then
               den6=0.0d0
             else
               den6=planetM6*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR6*earthcm)**3)
             endif
             if(P6Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P6Q)          
             endif
             AU6=((P6period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc6=dsqrt((P6esin**2+P6ecos**2))
             arg6=(datan2(P6esin,P6ecos))*180.0d0/pie
c             if(arg6.lt.0.0d0)arg6=arg6+180.0d0
             if(itconj.ge.2)then
               call getT0(P6incl,P6period,ecc6,arg6,T0_6,P6tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P6incl,P6period,ecc6,arg6,
     @           T0_6,P6tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P6incl,P6period,ecc6,arg6,P6T0,
     @             P6conj,tconj2)
               T0_6=P6T0
             endif
             tt1=dsin(P6incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P6Omega*pie/180.0d0)
             tt2=dcos(P6incl*pie/180.0d0)*dcos(fincr)
             rmutual6=dacos(tt1+tt2)*180.0d0/pie
             rimpact6=dabs(dcos(P6incl*pie/180.0d0)*AU6*
     @         214.939469384d0/R1)
             if(rimpact6.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR6/earthradtosolar/R1)**2-
     @             rimpact6**2)
             else
               term1=0.0d0
             endif
             term2=P6period*R1/(pie*AU6*214.939469384d0
     @           *dsqrt(1.0d0-ecc6*ecc6))
             term3=(1.0d0-ecc6*ecc6)/(1.0d0-ecc6*dcos(arg6))
             duration6=term1*term2*term3*24.0d0
             rinc6=P6incl
             Omega6=P6Omega
           endif
c
c  planet 7
c
           if((P7period.le.0.0d0).or.(P7Q.le.0.0d0))then
             planetM7=0.0d0
             planetR7=0.0d0
             den7=0.0d0
             AU7=0.0d0
             ecc7=0.0d0
             arg7=0.0d0
             rinc7=0.0d0
             Omega7=0.0d0
             rimpact7=0.0d0
             rmutual7=0.0d0
             duration7=0.0d0*24.0d0
             T0_7=0.0d0
           else
             if(P7Q.ne.0.0d0)then
               planetM7=(rM1+rM2)/P7Q*earthmasstosolar
             else
               planetM7=0.0d0
             endif
             if(P7ratrad.le.0.0d0)then
               planetR7=0.0d0
             else
               planetR7=R1/P7ratrad*earthradtosolar
             endif
             if(planetR7.le.0.0d0)then
               den7=0.0d0
             else
               den7=planetM7*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR7*earthcm)**3)
             endif
             if(P7Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P7Q)          
             endif
             AU7=((P7period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc7=dsqrt((P7esin**2+P7ecos**2))
             arg7=(datan2(P7esin,P7ecos))*180.0d0/pie
c             if(arg7.lt.0.0d0)arg7=arg7+180.0d0
             if(itconj.ge.2)then
               call getT0(P7incl,P7period,ecc7,arg7,T0_7,P7tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P7incl,P7period,ecc7,arg7,
     @           T0_7,P7tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P7incl,P7period,ecc7,arg7,P7T0,
     @             P7conj,tconj2)
               T0_7=P7T0
             endif
             tt1=dsin(P7incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P7Omega*pie/180.0d0)
             tt2=dcos(P7incl*pie/180.0d0)*dcos(fincr)
             rmutual7=dacos(tt1+tt2)*180.0d0/pie
             rimpact7=dabs(dcos(P7incl*pie/180.0d0)*AU7
     @          *214.939469384d0/R1)
             if(rimpact7.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR7/earthradtosolar/R1)**2-
     @             rimpact7**2)
             else
               term1=0.0d0
             endif
             term2=P7period*R1/(pie*AU7*214.939469384d0
     @           *dsqrt(1.0d0-ecc7*ecc7))
             term3=(1.0d0-ecc7*ecc7)/(1.0d0-ecc7*dcos(arg7))
             duration7=term1*term2*term3*24.0d0
             rinc7=P7incl
             Omega7=P7Omega
           endif
c
c  planet 8
c
           if((P8period.le.0.0d0).or.(P8Q.le.0.0d0))then
             planetM8=0.0d0
             planetR8=0.0d0
             den8=0.0d0
             AU8=0.0d0
             ecc8=0.0d0
             arg8=0.0d0
             rinc8=0.0d0
             Omega8=0.0d0
             rimpact8=0.0d0
             rmutual8=0.0d0
             duration8=0.0d0*24.0d0
             T0_8=0.0d0
           else
             if(P8Q.ne.0.0d0)then
               planetM8=(rM1+rM2)/P8Q*earthmasstosolar
             else
               planetM8=0.0d0
             endif
             if(P8ratrad.le.0.0d0)then
               planetR8=0.0d0
             else
               planetR8=R1/P8ratrad*earthradtosolar
             endif
             if(planetR8.le.0.0d0)then
               den8=0.0d0
             else
               den8=planetM8*earthgram/
     @           (4.0d0/3.0d0*pie*(planetR8*earthcm)**3)
             endif
             if(P8Q.le.0.0d0)then
               totalmass=0.0d0
             else
               totalmass=(total_mass)*(1.0d0+1.0d0/P8Q)          
             endif
             AU8=((P8period/daysinyear)**2*totalmass)**(1.0d0/3.0d0)
             ecc8=dsqrt((P8esin**2+P8ecos**2))
             arg8=(datan2(P8esin,P8ecos))*180.0d0/pie
c             if(arg8.lt.0.0d0)arg8=arg8+180.0d0
             if(itconj.ge.2)then
               call getT0(P8incl,P8period,ecc8,arg8,T0_8,P8tconj)
             endif
             if(itconj.eq.1)then
               call getT0tran(P8incl,P8period,ecc8,arg8,
     @           T0_8,P8tconj)
             endif
             if(itconj.eq.0)then
               call getcontimes(P8incl,P8period,ecc8,arg8,P8T0,
     @             P8conj,tconj2)
               T0_8=P8T0
             endif
             tt1=dsin(P8incl*pie/180.0d0)*dsin(fincr)
     @          *dcos(P8Omega*pie/180.0d0)
             tt2=dcos(P8incl*pie/180.0d0)*dcos(fincr)
             rmutual8=dacos(tt1+tt2)*180.0d0/pie
             rimpact8=dabs(dcos(P8incl*pie/180.0d0)*AU8
     @          *214.939469384d0/R1)
             if(rimpact8.lt.1.0d0)then
               term1=dsqrt((1.0d0+planetR8/earthradtosolar/R1)**2-
     @             rimpact8**2)
             else
               term1=0.0d0
             endif
             term2=P8period*R1/(pie*AU8*214.939469384d0
     @           *dsqrt(1.0d0-ecc8*ecc8))
             term3=(1.0d0-ecc8*ecc8)/(1.0d0-ecc8*dcos(arg8))
             duration8=term1*term2*term3*24.0d0
             rinc8=P8incl
             Omega8=P8Omega
           endif
c
            if((isw28.gt.0))then
              call getT0star(finc,period,ecc,argper,T0,Tconj)
            endif

           dummy=0.0d0
           write(planetparm,5000)rM1,R1,rM2,R2,AUEB,Tref,period,
     @       rM2*earthmasstosolar,R2*earthradtosolar,den,AUEB,
     @       ecc,argper,finc,dummy,Tconj,T0,dummy,
     @       rimpactEB,durationEB,
     @       tertperiod,
     &       planetM1,planetR1,den1,AU1,ecc1,arg1,rinc1,Omega1,P1tconj,
     @       T0_1,rmutual1,rimpact1,duration1,
     @       P2period,
     &       planetM2,planetR2,den2,AU2,ecc2,arg2,rinc2,Omega2,P2tconj,
     @       T0_2,rmutual2,rimpact2,duration2,
     @       P3period,
     &       planetM3,planetR3,den3,AU3,ecc3,arg3,rinc3,Omega3,P3tconj,
     @       T0_3,rmutual3,rimpact3,duration3,
     @       P4period,
     &       planetM4,planetR4,den4,AU4,ecc4,arg4,rinc4,Omega4,P4tconj,
     @       T0_4,rmutual4,rimpact4,duration4,
     @       P5period,
     &       planetM5,planetR5,den5,AU5,ecc5,arg5,rinc5,Omega5,P5tconj,
     @       T0_5,rmutual5,rimpact5,duration5,
     @       P6period,
     &       planetM6,planetR6,den6,AU6,ecc6,arg6,rinc6,Omega6,P6tconj,
     @       T0_6,rmutual6,rimpact6,duration6,
     @       P7period,
     &       planetM7,planetR7,den7,AU7,ecc7,arg7,rinc7,Omega7,P7tconj,
     @       T0_7,rmutual7,rimpact7,duration7,
     @       P8period,
     &       planetM8,planetR8,den8,AU8,ecc8,arg8,rinc8,Omega8,P8tconj,
     @       T0_8,rmutual8,rimpact8,duration8

  
c
 5000      format(2(f14.8,1x,f12.6,1x),f8.5,1x,f13.6,f14.8,1x,
     @       f15.8,1x,f12.6,1x,f6.3,1x,f10.7,1x,
     @       f12.10,1x,f15.10,1x,f15.10,1x,f8.5,1x,2(f12.5,1x),f7.5,1x,
     @       f8.5,1x,f8.5,1x,
     @       f16.10,1x,
     @       f12.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5,
     @       f16.10,1x,
     @       f10.4,1x,f10.4,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
     @       f15.10,1x,2(f12.5,1x),f12.9,1x,f8.5,1x,f8.5)
c
           return
           end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
           subroutine writedynparm(dynparm,rmass,dynQQ,dynPP,Tref)
c
           implicit double precision (a-h,o-z)
c
           dimension rmass(10),dynQQ(30),dynPP(30)
           character*1700 dynparm
c
           write(dynparm,100)Tref,(rmass(k),k=1,10),(dynQQ(j),j=1,30),
     @        (dynPP(i),i=1,30)
c
 100       format(f15.8,3x,10(1pe21.15,1x),3x,30(1pe22.15,1x),3x,
     @        30(1pe22.15,1x))
c
           return
           end
c
c #>!!!%(@^%#%*(&(#@#*$^@^$##*#@&(
c
           subroutine writeeclipse(Ncycle,Ttimes,Tseps,Nbody,
     @          Nmaxeclipse,Tdur1,Tdur2)
c
c   Will write the model eclipse times if in dynamics mode
c  
           implicit double precision(a-h,o-z)
c
           dimension Ncycle(34),Ttimes(34,Nmaxeclipse),
     @          Tseps(34,Nmaxeclipse),Tdur1(34,Nmaxeclipse),
     @          Tdur2(34,Nmaxeclipse)
c
           eb=1.0d0
c
           open(unit=20,file='ELCprimtime.dat',status='unknown')
c
           do ij=1,Ncycle(1)
             if(Tseps(1,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(1,ij),eb,Tseps(1,ij),
     @           Tdur1(1,ij),Tdur2(1,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELCsectime.dat',status='unknown')
c
           do ij=1,Ncycle(2)
             if(Tseps(2,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(2,ij),eb,Tseps(2,ij),
     @           Tdur1(2,ij),Tdur2(2,ij)
             endif
           enddo
c
           close(20)
c
c   transits and occultations of body 3
c
           open(unit=20,file='ELC3tran1time.dat',status='unknown')
c
           do ij=1,Ncycle(3)
             if(Tseps(3,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(3,ij),eb,Tseps(3,ij),
     @          Tdur1(3,ij),Tdur2(3,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC1occul3time.dat',status='unknown')
c
           do ij=1,Ncycle(4)
             if(Tseps(4,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(4,ij),eb,Tseps(4,ij),
     @          Tdur1(4,ij),Tdur2(4,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC3tran2time.dat',status='unknown')
c
           do ij=1,Ncycle(5)
             if(Tseps(5,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(5,ij),eb,Tseps(5,ij),
     @          Tdur1(5,ij),Tdur2(5,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC2occul3time.dat',status='unknown')
c
           do ij=1,Ncycle(6)
             if(Tseps(6,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(6,ij),eb,Tseps(6,ij),
     @           Tdur1(6,ij),Tdur2(6,ij)
             endif
           enddo
c
           close(20)
c
c   transits and occultations of body 4
c
           if(Nbody.lt.4)return
           open(unit=20,file='ELC4tran1time.dat',status='unknown')
c
           do ij=1,Ncycle(7)
             if(Tseps(7,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(7,ij),eb,Tseps(7,ij),
     @          Tdur1(7,ij),Tdur2(7,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC1occul4time.dat',status='unknown')
c
           do ij=1,Ncycle(8)
             if(Tseps(8,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(8,ij),eb,Tseps(8,ij),
     @          Tdur1(8,ij),Tdur2(8,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC4tran2time.dat',status='unknown')
c
           do ij=1,Ncycle(9)
             if(Tseps(9,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(9,ij),eb,Tseps(9,ij),
     @          Tdur1(9,ij),Tdur2(9,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC2occul4time.dat',status='unknown')
c
           do ij=1,Ncycle(10)
             if(Tseps(10,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(10,ij),eb,Tseps(10,ij),
     @          Tdur1(10,ij),Tdur2(10,ij)
             endif
           enddo
c
           close(20)
c
c   transits and occultations of body 5
c
           if(Nbody.lt.5)return
           open(unit=20,file='ELC5tran1time.dat',status='unknown')
c
           do ij=1,Ncycle(11)
             if(Tseps(11,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(11,ij),eb,Tseps(11,ij),
     @          Tdur1(11,ij),Tdur2(11,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC1occul5time.dat',status='unknown')
c
           do ij=1,Ncycle(12)
             if(Tseps(12,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(12,ij),eb,Tseps(12,ij),
     @          Tdur1(12,ij),Tdur2(12,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC5tran2time.dat',status='unknown')
c
           do ij=1,Ncycle(13)
             if(Tseps(13,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(13,ij),eb,Tseps(13,ij),
     @          Tdur1(13,ij),Tdur2(13,ij)
             endif
           enddo
c
           close(20)
c
           open(unit=20,file='ELC2occul5time.dat',status='unknown')
c
           do ij=1,Ncycle(14)
             if(Tseps(14,ij).le.1.0d0)then
               write(20,100)ij,Ttimes(14,ij),eb,Tseps(14,ij),
     @          Tdur1(14,ij),Tdur2(14,ij)
             endif
           enddo
c
           close(20)
c
 100       format(i5,2x,f20.12,2x,f3.1,2x,f15.12,3x,2(f20.12,1x))
           return
           end
c
c
c  &&&&&&&&&&&
c
c@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
c
c
          subroutine getT0star(finc,period,ecc,argper,T0,Tconj)
c
c   January 30, 2010.
c
c   This routine is the inverse of getcontimes.  Given a time of transit,
c   it will figure out the T0 needed.
c
          implicit double precision (a-h,o-z)
c
          pie=3.141592653589793d0
c
          fincr=finc*pie/180.0d0
          omegar=argper*pie/180.0d0
          ft=1.5d0*pie-omegar
3139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 3139
3140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 3140

          guess=ft
          do 22 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 23
            ft=guess
22        continue

 23       ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 31501
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 31501
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 31103
31501     ecan=pie
31103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
c
          ft=0.5d0*pie-omegar
4139      if(ft.lt.0.0d0)ft=ft+2.0d0*pie
          if(ft.lt.0.0d0)go to 4139
4140      if(ft.ge.2.0d0*pie)ft=ft-2.0d0*pie
          if(ft.ge.2.0d0*pie)go to 4140
c
          guess=ft
          do 422 jj=1,20
            guess=guess-deltap(fincr,omegar,ecc,guess)/
     &            deltapp(fincr,omegar,ecc,guess)
            diff=abs(guess-ft)
            if(diff.lt.1.0d-9)go to 423
            ft=guess
422       continue
c
 423      ft=guess
          htrc=0.5d0*ft
          if(dabs(0.5d0*pie-htrc).lt.7.0d-6)go to 41101
          if(dabs(4.712388980384690d0-htrc).lt.7.d-6) goto 41101
          ecan=2.d0*datan(dsqrt((1.d0-ecc)/(1.d0+ecc))*dtan(htrc))
          goto 41103
41101     ecan=pie
41103     xmc=ecan-ecc*dsin(ecan)
c          if(xmc.lt.0.0d0)xmc=xmc+2.0d0*pie
          deltaT=(xmc*period)/(2.0d0*pie)
          t0=tconj-deltaT
c
          return
          end
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine getSC(NSC,xSC,ySC)
c
          implicit double precision(a-h,o-z)
c
          dimension xSC(9999),ySC(9999)
c
c   Declare the variable bell to be character*1
c
          character*1 bell
c
          bell=char(7)
          ios=0
          open(unit=1,file='ELCSC.inp',status='old',err=100,
     @         iostat=ios)
c
          read(1,*,err=101)NSC
          if(NSC.gt.9999)NSC=9999
c
          do 10 i=1,NSC
            read(1,*,err=101,end=101)xSC(i),ySC(i)
 10       continue

          if(ios.eq.0)then 
            close(1)
            return
          endif
c
c   Come here if the input file ELCSC.inp does not exist. 
c
 100      NSC=0
          return
c
 101      write(*,1002)bell
          NSC=0
          close(1)
          return
c
c
c   Put this if-then block for successful completion.
c
c
 1000     format(a1,'Error:  File ELCgap.inp does not exist,',
     @       ' setting Ngap=0')
 1002     format(a1,'Error:  Bad entry in ELCSC.inp, setting NSC=0')
c
          return
          end
c
c  %%%%%%%%%%%%%%%%%%%%%%
c
          function apsidalrate(rk1,rk2,rM1,rM2,omega1,omega2,period,
     @       frac1,frac2,separ,ecc)
c
          implicit double precision(a-h,o-z)
c
          pie=3.141592653589793d0
          Q= rM2/rM1
          top=1.0d0+7.5d0*ecc**2+5.625d0*ecc**4+0.3125d0*ecc**6
          bot=(1.0d0+3.0d0*ecc**2+0.375*ecc**4)*(1.0d0-ecc**2)**(1.5d0)
          hut=top/bot
          fe=1.0d0/((1.0d0-ecc*ecc)**2)
          ge=(8.0d0+12.0d0*ecc*ecc+ecc**4)*fe**(2.5d0)/8.0d0
          c21=frac1**(5.0d0)*(hut*hut*omega1**2*(1.0d0+Q)*fe+15.0d0*Q*ge)
          c22=frac2**(5.0d0)*(hut*hut*omega2**2*(1.0d0+1.0d0/Q)*fe+
     @              15.0d0/Q*ge)
          dw=c21*rk1+c22*rk2
          U=period/dw    
          apsidalrate=360.0d0*dw  
 
          return
          end
cc
c @@$%$&&&&@&&@&@&@&@&#&#&$&$&$&$&$&&&&&&$&$&$
c
          subroutine counttime(Ngap,gaplow,gaphigh,
     @       ntime,timearray,tstart,tstop,tstep,Nmaxphase)
c
          implicit double precision(a-h,o-z)

          dimension gaplow(9999),gaphigh(9999)
          dimension timearray(9000000)
          
          call filltime(ntime,timearray,tstart,tstop,tstep)
c
          icount=0
          do 10 icounttime=1,ntime
            do ijk=1,Ngap
              if((timearray(icounttime).gt.gaplow(ijk)).and.
     @           (timearray(icounttime).lt.gaphigh(ijk)))then
                go to 10
              endif
            enddo
            icount=icount+1
 10       continue
          if(icount.gt.Nmaxphase)then 
            write(*,100),Nmaxphase,icount
            stop
          endif
c
 100      format('Error:  Nmaxphase is too small.  Its current ',
     @       'value is ',i7/
     @       'Requested light curve has a length of ',i7)
          return
          end
c
c  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@@@@@@@@@@@$$$$$$
c
          subroutine insgridinput(kkk,Nalph1,Nbet1,Nalph2,Nbet2,fill1,
     $      fill2,omega1,omega2,dphase,Q,finc,Teff1,Teff2,Tgrav1,Tgrav2,
     $      betarim,rinner,router,tdisk,xi,Ntheta,Nradius,alb1,alb2,
     &      Nref,rLx,Period,fm,separ,gamma,t3,g3,SA3,density,sw1,sw2,
     @      sw3,T0,idraw,iecheck,iidint,iatm,ism1,icnU,icnB,icnV,icnR,
     @      icnI,icnJ,icnH,icnK,iRVfilt,isw1,isw2,isw3,isw4,ilaw,wave,
     @      dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,
     @      sw8,sw9,ikeep,isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,
     @      spot2parm,spotdparm,primmass,primK,primrad,ratrad,frac1,
     @      frac2,ecosw,temprat,idark1,idark2,isw12,isw13,isw21,isw22,
     @      isw23,isw24,bigI,bigbeta,sw23,sw24,powercoeff,sw25,sw26,
     @      sw27,sw28,sw29,sw30,contam,Tconj,beam1,beam2,isw25,isw26,
     @      isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,ocose,
     @      osine,omegadot,contamS0,contamS1,contamS2,contamS3,
     @      sw47,sw48,sw49)
c
c   UPDATE August, 2014
c
c   This routine used by demcmcELC and geneticELC.  
c   If the file ELC.insert exists, read it in and distroy it.  Set kkk=99
c   on exit.  If the file does not exist, set kkk=0 and exit.
c
          implicit double precision(a-h,o-z)
c
          dimension wave(8),dbolx(8,2),dboly(8,2),dwavex(8,3),
     @      dwavey(8,3)
c
          dimension spot1parm(2,4),spot2parm(2,4),spotdparm(2,4)
          dimension powercoeff(8,9)
c
          character*4 extension
          character*1 bell
c
          ios=0
          open(unit=1,file='ELC.insert',status='old',err=100,
     @       iostat=ios)
c
          read(1,*,end=101,err=101)Nalph1
          read(1,*,end=101,err=101)Nbet1
          read(1,*,end=101,err=101)Nalph2
          read(1,*,end=101,err=101)Nbet2
          read(1,*,end=101,err=101)fill1
          read(1,*,end=101,err=101)fill2
          read(1,*,end=101,err=101)omega1
          read(1,*,end=101,err=101)omega2
          read(1,*,end=101,err=101)dphase
          read(1,*,end=101,err=101)Q
          read(1,*,end=101,err=101)finc
          read(1,*,end=101,err=101)Teff1
          read(1,*,end=101,err=101)Teff2
          read(1,*,end=101,err=101)Tgrav1
          read(1,*,end=101,err=101)Tgrav2
          read(1,*,end=101,err=101)betarim
          read(1,*,end=101,err=101)rinner
          read(1,*,end=101,err=101)router
          read(1,*,end=101,err=101)tdisk
          read(1,*,end=101,err=101)xi
          read(1,*,end=101,err=101)Ntheta
          read(1,*,end=101,err=101)Nradius
          read(1,*,end=101,err=101)alb1
          read(1,*,end=101,err=101)alb2
          read(1,*,end=101,err=101)Nref
          read(1,*,end=101,err=101)rLx
          read(1,*,end=101,err=101)Period
          read(1,*,end=101,err=101)fm
          read(1,*,end=101,err=101)separ
          read(1,*,end=101,err=101)gamma
          read(1,*,end=101,err=101)t3
          read(1,*,end=101,err=101)g3
          read(1,*,end=101,err=101)SA3
          read(1,*,end=101,err=101)density
          read(1,*,end=101,err=101)sw1
          read(1,*,end=101,err=101)sw2
          read(1,*,end=101,err=101)sw3
          read(1,*,end=101,err=101)T0
          read(1,*,end=101,err=101)idraw
          read(1,*,end=101,err=101)iecheck
          read(1,*,end=101,err=101)iidint
          read(1,*,end=101,err=101)iatm
          read(1,*,end=101,err=101)ism1
          read(1,*,end=101,err=101)icnU,icnB,icnV,icnR,icnI,icnJ,icnH,
     @          icnK
          read(1,*,end=101,err=101)iRVfilt
          read(1,*,end=101,err=101)isw1
          read(1,*,end=101,err=101)isw2
          read(1,*,end=101,err=101)isw3
          read(1,*,end=101,err=101)isw4
          read(1,*,end=101,err=101)ilaw
          do 10 i=1,8
            read(1,*,end=101,err=101)wave(i),dbolx(i,1),dboly(i,1),
     @         dbolx(i,2),dboly(i,2),dwavex(i,1),dwavey(i,1),
     @         dwavex(i,2),dwavey(i,2)
            dwavex(i,3)=dwavex(i,1)
            dwavey(i,3)=dwavey(i,1)
 10       continue
          read(1,*,end=101,err=101)ecc
          read(1,*,end=101,err=101)argper
          read(1,*,end=101,err=101)pshift
          read(1,*,end=101,err=101)sw5
          read(1,*,end=101,err=101)sw6
          read(1,*,end=101,err=101)sw7
          read(1,*,end=101,err=101)sw8
          read(1,*,end=101,err=101)sw9
          read(1,*,end=101,err=101)ikeep
          read(1,*,end=101,err=101)isynch
          read(1,*,end=101,err=101)isw5
          read(1,*,end=101,err=101)isw6
          read(1,*,end=101,err=101)isw7
          read(1,*,end=101,err=101)isw8
          read(1,*,end=101,err=101)isw9
          ios=0
          read(1,*,end=101,err=101)spot1parm(1,1)
          read(1,*,end=101,err=101)spot1parm(1,2)
          read(1,*,end=101,err=101)spot1parm(1,3)
          read(1,*,end=101,err=101)spot1parm(1,4)
          read(1,*,end=101,err=101)spot1parm(2,1)
          read(1,*,end=101,err=101)spot1parm(2,2)
          read(1,*,end=101,err=101)spot1parm(2,3)
          read(1,*,end=101,err=101)spot1parm(2,4)
          read(1,*,end=101,err=101)spot2parm(1,1)
          read(1,*,end=101,err=101)spot2parm(1,2)
          read(1,*,end=101,err=101)spot2parm(1,3)
          read(1,*,end=101,err=101)spot2parm(1,4)
          read(1,*,end=101,err=101)spot2parm(2,1)
          read(1,*,end=101,err=101)spot2parm(2,2)
          read(1,*,end=101,err=101)spot2parm(2,3)
          read(1,*,end=101,err=101)spot2parm(2,4)
          read(1,*,end=101,err=101)spotdparm(1,1)
          read(1,*,end=101,err=101)spotdparm(1,2)
          read(1,*,end=101,err=101)spotdparm(1,3)
          read(1,*,end=101,err=101)spotdparm(1,4)
          read(1,*,end=101,err=101)spotdparm(2,1)
          read(1,*,end=101,err=101)spotdparm(2,2)
          read(1,*,end=101,err=101)spotdparm(2,3)
          read(1,*,end=101,err=101)spotdparm(2,4)
          read(1,*,end=101,err=101)primmass
          read(1,*,end=101,err=101)primK
          read(1,*,end=101,err=101)primrad
          read(1,*,end=101,err=101)ratrad
          read(1,*,end=101,err=101)frac1
          read(1,*,end=101,err=101)frac2
          read(1,*,end=101,err=101)ecosw
          read(1,*,end=101,err=101)temprat
          read(1,*,end=101,err=101)idark1
          read(1,*,end=101,err=101)idark2
          read(1,*,end=101,err=101)isw12
          read(1,*,end=101,err=101)isw13
          read(1,*,end=101,err=101)isw21
          read(1,*,end=101,err=101)isw22
          read(1,*,end=101,err=101)isw23
          read(1,*,end=101,err=101)isw24
          read(1,*,end=101,err=101)(powercoeff(1,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(2,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(3,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(4,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(5,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(6,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(7,k),k=1,9)
          read(1,*,end=101,err=101)(powercoeff(8,k),k=1,9)
          read(1,*,end=101,err=101)bigI
          read(1,*,end=101,err=101)bigbeta
          read(1,*,end=101,err=101)sw23
          read(1,*,end=101,err=101)sw24
          read(1,*,end=101,err=101)sw25
          read(1,*,end=101,err=101)sw26
          read(1,*,end=101,err=101)sw27
          read(1,*,end=101,err=101)sw28
          read(1,*,end=101,err=101)sw29
          read(1,*,end=101,err=101)sw30
          read(1,*,end=101,err=101)contam
          read(1,*,end=101,err=101)Tconj
          read(1,*,end=101,err=101)beam1
          read(1,*,end=101,err=101)beam2
          read(1,*,end=101,err=101)isw25
          read(1,*,end=101,err=101)isw26
          read(1,*,end=101,err=101)isw27
          read(1,*,end=101,err=101)isw28
          read(1,*,end=101,err=101)isw29
          read(1,*,end=101,err=101)isw30
          read(1,*,end=101,err=101)isw31
          read(1,*,end=101,err=101)isw32
          read(1,*,end=101,err=101)isw33
          read(1,*,end=101,err=101)isw34
          read(1,*,end=101,err=101)ocose
          read(1,*,end=101,err=101)osine
          read(1,*,end=101,err=101)omegadot
          read(1,*,end=101,err=101)contamS0
          read(1,*,end=101,err=101)contamS1
          read(1,*,end=101,err=101)contamS2
          read(1,*,end=101,err=101)contamS3
          read(1,*,end=101,err=101)sw47
          read(1,*,end=101,err=101)sw48
          read(1,*,end=101,err=101)sw49
c
          if(ios.eq.0)then 
            close(1)
            kkk=99
            call system('rm ELC.insert')
            return
          endif
c
c   Come here if the input file ELC.???? does not exist.  
c
 100      if(ios.gt.0)then
            kkk=0
            return
          endif
c
c   Come here if there is an error reading the file
c
 101      kkk=0
          call system('rm ELC.insert')
c
          return
          end
c
c
c   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
c
          subroutine insgridbody3(kkk,Nalph3,Nbet3,tertperiod,tertt0,
     @      tertecos,tertesin,tertincl,tertOmega,tertQ,dwavex,dwavey,
     @      itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,
     @      P2tconj,P2period,P2T0,P2ecos,P2esin,P2incl,P2Omega,P2Q,
     @      P2ratrad,P3tconj,P3period,P3T0,P3ecos,P3esin,P3incl,P3Omega,
     @      P3Q,P3ratrad,P4tconj,P4period,P4T0,P4ecos,P4esin,P4incl,
     @      P4Omega,P4Q,P4ratrad,P5tconj,P5period,P5T0,P5ecos,P5esin,
     @      P5incl,P5Omega,P5Q,P5ratrad,P6tconj,P6period,P6T0,P6ecos,
     @      P6esin,P6incl,P6Omega,P6Q,P6ratrad,P7tconj,P7period,P7T0,
     @      P7ecos,P7esin,P7incl,P7Omega,P7Q,P7ratrad,P8tconj,P8period,
     &      P8T0,P8ecos,P8esin,P8incl,P8Omega,P8Q,P8ratrad)
c                      
c
          implicit double precision(a-h,o-z)
c
          dimension dwavex(8,3),dwavey(8,3)
c
c   Declare the variable bell to be character*1
c
          character*1 bell
          character*4 extension
c
          ios=0
          open(unit=1,file='ELCbody3.insert',status='old',err=100,
     @         iostat=ios)
c
          read(1,*,end=101,err=101)Nalph3
          read(1,*,end=101,err=101)Nbet3
          read(1,*,end=101,err=101)itconj
          read(1,*,end=101,err=101)it1
          read(1,*,end=101,err=101)it2
          read(1,*,end=101,err=101)it3
          read(1,*,end=101,err=101)it4
          read(1,*,end=101,err=101)tertconj
          read(1,*,end=101,err=101)tertperiod
          read(1,*,end=101,err=101)tertt0
          read(1,*,end=101,err=101)tertecos
          read(1,*,end=101,err=101)tertesin
          read(1,*,end=101,err=101)tertincl
          read(1,*,end=101,err=101)tertOmega
          read(1,*,end=101,err=101)tertQ
c
c  Load the limb darkening parameters. 
c         
          do 10 i=1,8
            read(1,*,end=101,err=101)dwavex(i,3),dwavey(i,3)
 10       continue
c
          read(1,*,end=101,err=101)tertratrad
          read(1,*,end=101,err=101)hh
          read(1,*,end=101,err=101)sw72
          read(1,*,end=101,err=101)sw73
          read(1,*)P2tconj
          read(1,*)P2period
          read(1,*)P2T0
          read(1,*)P2ecos
          read(1,*)P2esin
          read(1,*)P2incl
          read(1,*)P2Omega
          read(1,*)P2Q
          read(1,*)P2ratrad
c
          read(1,*)P3tconj
          read(1,*)P3period
          read(1,*)P3T0
          read(1,*)P3ecos
          read(1,*)P3esin
          read(1,*)P3incl
          read(1,*)P3Omega
          read(1,*)P3Q
          read(1,*)P3ratrad
c
          read(1,*)P4tconj
          read(1,*)P4period
          read(1,*)P4T0
          read(1,*)P4ecos
          read(1,*)P4esin
          read(1,*)P4incl
          read(1,*)P4Omega
          read(1,*)P4Q
          read(1,*)P4ratrad
c
          read(1,*)P5tconj
          read(1,*)P5period
          read(1,*)P5T0
          read(1,*)P5ecos
          read(1,*)P5esin
          read(1,*)P5incl
          read(1,*)P5Omega
          read(1,*)P5Q
          read(1,*)P5ratrad
c                                    
          read(1,*)P6tconj
          read(1,*)P6period
          read(1,*)P6T0
          read(1,*)P6ecos
          read(1,*)P6esin
          read(1,*)P6incl
          read(1,*)P6Omega
          read(1,*)P6Q
          read(1,*)P6ratrad
c
          read(1,*)P7tconj
          read(1,*)P7period
          read(1,*)P7T0
          read(1,*)P7ecos
          read(1,*)P7esin
          read(1,*)P7incl
          read(1,*)P7Omega
          read(1,*)P7Q
          read(1,*)P7ratrad
c
          read(1,*)P8tconj
          read(1,*)P8period
          read(1,*)P8T0
          read(1,*)P8ecos
          read(1,*)P8esin
          read(1,*)P8incl
          read(1,*)P8Omega
          read(1,*)P8Q
          read(1,*)P8ratrad
          if(ios.eq.0)then 
            close(1)
            kkk=99
            call system('rm ELCbody3.insert')
            return
          endif
c
c   Come here if the input file ELCbody3.insert does not exist. 
c
 100      if(ios.gt.0)then
            kkk=0
            return
          endif
c
c   Come here if there is an error reading the file
c
 101      kkk=0
          call system('rm ELCbody3.insert')
c
          return
          end
c
c!@$%&&&%%$$@@$$%%$$@@&&%$%&@@@@
c
          subroutine writetex(Nbody,rIBCinp,dynPP,dynQQ,rmass,Tref,hh)
c
          implicit real*8 (a-h,o-z)
c
          dimension rIBCinp(10,6),rmass(10),dynPP(30),dynQQ(30)
c
          open(unit=94,file='ELCdynamics.tex',status='unknown')
c
          if(Nbody.eq.3)then
            write(94,301)
            write(94,302)
            write(94,303)
            write(94,304)
            write(94,305)
            write(94,306)
            write(94,307)
            write(94,308)
            write(94,311)rIBCinp(1,1),rIBCinp(2,1)
            write(94,312)rIBCinp(1,2),rIBCinp(2,2)
            write(94,313)rIBCinp(1,3),rIBCinp(2,3)
            write(94,314)rIBCinp(1,4),rIBCinp(2,4)
            write(94,315)rIBCinp(1,5),rIBCinp(2,5)
            write(94,316)rIBCinp(1,6),rIBCinp(2,6)
            write(94,317)
            write(94,318)
            write(94,319)
            write(94,320)rmass(1),rmass(2),rmass(3)
            write(94,321)dynQQ(1),dynQQ(1+Nbody),dynQQ(1+2*Nbody)
            write(94,322)dynQQ(2),dynQQ(2+Nbody),dynQQ(2+2*Nbody)
            write(94,323)dynQQ(3),dynQQ(3+Nbody),dynQQ(3+2*Nbody)
            write(94,324)dynPP(1),dynPP(1+Nbody),dynPP(1+2*Nbody)
            write(94,325)dynPP(2),dynPP(2+Nbody),dynPP(2+2*Nbody)
            write(94,326)dynPP(3),dynPP(3+Nbody),dynPP(3+2*Nbody)
            write(94,327)
            write(94,328)Tref,hh
            write(94,329)
          endif
c
          if(Nbody.eq.4)then
            write(94,401)
            write(94,402)
            write(94,403)
            write(94,404)
            write(94,405)
            write(94,406)
            write(94,407)
            write(94,408)
            write(94,411)rIBCinp(1,1),rIBCinp(2,1),rIBCinp(3,1)
            write(94,412)rIBCinp(1,2),rIBCinp(2,2),rIBCinp(3,2)
            write(94,413)rIBCinp(1,3),rIBCinp(2,3),rIBCinp(3,3)
            write(94,414)rIBCinp(1,4),rIBCinp(2,4),rIBCinp(3,4)
            write(94,415)rIBCinp(1,5),rIBCinp(2,5),rIBCinp(3,5)
            write(94,416)rIBCinp(1,6),rIBCinp(2,6),rIBCinp(3,6)
            write(94,417)
            write(94,418)
            write(94,419)
            write(94,420)rmass(1),rmass(2),rmass(3),rmass(4)
            write(94,421)dynQQ(1),dynQQ(4),dynQQ(7),
     @          dynQQ(10)
            write(94,422)dynQQ(2),dynQQ(5),dynQQ(8),
     @          dynQQ(11)
            write(94,423)dynQQ(3),dynQQ(6),dynQQ(9),
     @          dynQQ(12)
            write(94,424)dynPP(1),dynPP(4),dynPP(7),
     @          dynPP(10)
            write(94,425)dynPP(2),dynPP(5),dynPP(8),
     @          dynPP(11)
            write(94,426)dynPP(3),dynPP(6),dynPP(9),
     @          dynPP(12)
            write(94,427)
            write(94,428)Tref,hh
            write(94,429)
          endif
c
          if(Nbody.eq.5)then
            write(94,501)
            write(94,502)
            write(94,503)
            write(94,504)
            write(94,505)
            write(94,506)
            write(94,507)
            write(94,508)
            write(94,511)rIBCinp(1,1),rIBCinp(2,1),rIBCinp(3,1),
     @          rIBCinp(4,1)
            write(94,512)rIBCinp(1,2),rIBCinp(2,2),rIBCinp(3,2),
     @          rIBCinp(4,2)
            write(94,513)rIBCinp(1,3),rIBCinp(2,3),rIBCinp(3,3),
     @          rIBCinp(4,3)
            write(94,514)rIBCinp(1,4),rIBCinp(2,4),rIBCinp(3,4),
     @          rIBCinp(4,4)
            write(94,515)rIBCinp(1,5),rIBCinp(2,5),rIBCinp(3,5),
     @          rIBCinp(4,5)
            write(94,516)rIBCinp(1,6),rIBCinp(2,6),rIBCinp(3,6),
     @          rIBCinp(4,6)
            write(94,517)
            write(94,518)
            write(94,519)
            write(94,520)rmass(1),rmass(2),rmass(3),rmass(4),rmass(5)
            write(94,521)dynQQ(1),dynQQ(4),dynQQ(7),
     @          dynQQ(10),dynQQ(13)
            write(94,522)dynQQ(2),dynQQ(5),dynQQ(8),
     @          dynQQ(11),dynQQ(14)
            write(94,523)dynQQ(3),dynQQ(6),dynQQ(9),
     @          dynQQ(12),dynQQ(15)
            write(94,524)dynPP(1),dynPP(4),dynPP(7),
     @          dynPP(10),dynPP(13)
            write(94,525)dynPP(2),dynPP(5),dynPP(8),
     @          dynPP(11),dynPP(14)
            write(94,526)dynPP(3),dynPP(6),dynPP(9),
     @          dynPP(12),dynPP(15)
            write(94,527)
            write(94,528)Tref,hh
            write(94,529)
          endif

 301      format('\begin{deluxetable}{rrrr}')
 302      format('\rotate')
 303      format('\tablecolumns{4}')
 304      format('\tabletypesize{\footnotesize}')
 305      format('\tablecaption{Initial Dynamical Parameters',
     @       '\tablenotemark{a}}')
 306      format('\tablewidth{0pt}')
 307      format('\tablehead{  ',/
     @       '\colhead{parameter\tablenotemark{b}} & ',/
     @       '\colhead{orbit 1}   & ',/
     @       '\colhead{orbit 2}   & ',/
     $       '\colhead{} }')
 308      format('\startdata')

 311      format('Period  (days) &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & \cr ')
 312      format('$e\cos\omega$ &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & \cr ')
 313      format('$e\sin\omega$ &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & \cr ')
 314      format('$i$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & \cr ')
 315      format('$\Omega$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & \cr ')
 316      format('$T_{\rm conj}$  (days)\tablenotemark{c} &',
     @        '$'1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 317      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 318      format('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ',
     @       '\multicolumn{1}{c}{body 1} & ', /
     @       '\multicolumn{1}{c}{body 2} & ', 
     @        '\multicolumn{1}{c}{body 3} \cr')
 319      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 320      format('Mass ($M_{\odot}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 321      format('$x$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 322      format('$y$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 323      format('$z$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 324      format('$v_x$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 325      format('$v_y$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 326      format('$v_z$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',' \cr ')
 327      format('\enddata')
 328      format('\tablenotetext{a}{Reference time = ',f15.5,','/
     @      'integration step size = ',f7.5,' days}',/
     @      '\tablenotetext{b}{Jacobian instantaneous (Keplerian) ',
     @       'elements}',/
     @      '\tablenotetext{c}{Times are relative to ',
     @       'BJD 2,455,000.000}',/
     @       '\tablenotetext{d}{Barycentric Cartesian coordinates}')
 329      format('\end{deluxetable}')
c
 401      format('\begin{deluxetable}{rrrrr}')
 402      format('\rotate')
 403      format('\tablecolumns{5}')
 404      format('\tabletypesize{\scriptsize}')
 405      format('\tablecaption{Initial Dynamical Parameters',
     @       '\tablenotemark{a}}')
 406      format('\tablewidth{0pt}')
 407      format('\tablehead{  ',/
     @       '\colhead{parameter\tablenotemark{b}} & ',/
     @       '\colhead{orbit 1}   & ',/
     @       '\colhead{orbit 2}   & ',/
     @       '\colhead{orbit 3}   & ',/
     $       '\colhead{} }')
 408      format('\startdata')

 411      format('Period  (days) &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 412      format('$e\cos\omega$ &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 413      format('$e\sin\omega$ &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 414      format('$i$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 415      format('$\Omega$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',' & \cr ')
 416      format('$T_{\rm conj}$  (days)\tablenotemark{c} &',
     @        '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 417      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 418      format('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ',
     @       '\multicolumn{1}{c}{body 1} & ', /
     @       '\multicolumn{1}{c}{body 2} & ', 
     @       '\multicolumn{1}{c}{body 3} & ', / 
     @        '\multicolumn{1}{c}{body 4} \cr')
 419      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 420      format('Mass ($M_{\odot}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 421      format('$x$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 422      format('$y$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 423      format('$z$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 424      format('$v_x$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 425      format('$v_y$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 426      format('$v_z$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$','  \cr ')
 427      format('\enddata')
 428      format('\tablenotetext{a}{Reference time = ',f15.5,','/
     @      'integration step size = ',f7.5,' days}',/
     @      '\tablenotetext{b}{Jacobian instantaneous (Keplerian) ',
     @       'elements}',/
     @      '\tablenotetext{c}{Times are relative to ',
     @       'BJD 2,455,000.000}',/
     @       '\tablenotetext{d}{Barycentric Cartesian coordinates}')
 429      format('\end{deluxetable}')
c
 501      format('\begin{deluxetable}{rrrrrr}')
 502      format('\rotate')
 503      format('\tablecolumns{6}')
 504      format('\tabletypesize{\scriptsize}')
 505      format('\tablecaption{Initial Dynamical Parameters',
     @       '\tablenotemark{a}}')
 506      format('\tablewidth{0pt}')
 507      format('\tablehead{  ',/
     @       '\colhead{parameter\tablenotemark{b}} & ',/
     @       '\colhead{orbit 1}   & ',/
     @       '\colhead{orbit 2}   & ',/
     @       '\colhead{orbit 3}   & ',/
     @       '\colhead{orbit 4}   & ',/
     $       '\colhead{} }')
 508      format('\startdata')

 511      format('Period  (days) &','$'1pe24.17,'$',' & ',
     $       '$'1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 512      format('$e\cos\omega$ &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 513      format('$e\sin\omega$ &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 514      format('$i$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 515      format('$\Omega$  (rad) &','$'1pe24.17,'$',' & ',
     $       '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 516      format('$T_{\rm conj}$  (days)\tablenotemark{c} &',
     @        '$',1pe24.17,'$',' & ','$'1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$',' & \cr ')
 517      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 518      format('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ',
     @       '\multicolumn{1}{c}{body 1} & ', /
     @       '\multicolumn{1}{c}{body 2} & ', 
     @       '\multicolumn{1}{c}{body 3} & ', / 
     @       '\multicolumn{1}{c}{body 4} & ', / 
     @        '\multicolumn{1}{c}{body 5} \cr')
 519      format('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
 520      format('Mass ($M_{\odot}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 521      format('$x$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 522      format('$y$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 523      format('$z$ (AU) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 524      format('$v_x$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 525      format('$v_y$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 526      format('$v_z$ (AU day$^{-1}$) & ','$',1pe24.17,'$',' & ',
     @        '$',1pe24.17,'$',' & ','$',1pe24.17,'$',
     @        ' & ','$',1pe24.17,'$',
     @       ' & ','$',1pe24.17,'$','  \cr ')
 527      format('\enddata')
 528      format('\tablenotetext{a}{Reference time = ',f15.5,','/
     @      'integration step size = ',f7.5,' days}',/
     @      '\tablenotetext{b}{Jacobian instantaneous (Keplerian) ',
     @       'elements}',/
     @      '\tablenotetext{c}{Times are relative to ',
     @       'BJD 2,455,000.000}',/
     @       '\tablenotetext{d}{Barycentric Cartesian coordinates}')
 529      format('\end{deluxetable}')
c

          close(94)
c
          return
          end
